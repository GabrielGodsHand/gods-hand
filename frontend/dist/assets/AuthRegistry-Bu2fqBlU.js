const i=!0,e="1.0.0-beta.5+0000000000000000000000000000000000000000",n="AuthRegistry",t=[{name:"_set_authorized",is_unconstrained:!0,custom_attributes:["public","internal"],abi:{parameters:[{name:"approver",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]},visibility:"private"},{name:"message_hash",type:{kind:"field"},visibility:"private"},{name:"authorize",type:{kind:"boolean"},visibility:"private"}],return_type:null,error_types:{"206160798890201757":{error_kind:"string",string:"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"6304245522015439386":{error_kind:"string",string:"Function _set_authorized can only be called internally"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"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",debug_symbols:"tZndbts8DIbvJcc90A8pSr2VYRiyLhsCBGmRtR/woei9j5T5KkkBG5mDncRPGPG1KFGU7Lxvfuy+v/36tj/+fP69efzyvvl+2h8O+1/fDs9P29f981Gt75tgHzGlzWN+0KtsHotes34Xu8p0JZ6urM0jGTCgORQCwCKwCCw1A8ShJUCZIIUIsFuwQioOOQDwE8FCsDAsTIDqUDJAHCQBcIsaASaYDZpDI0CdIIcEEIcYAe6eUwAUhwxLRhsyr2JQHBiWPs4dmkOPooM4CBoLGtcAGBa49yg61AmoR9HB704xAAiAxikDYLFUidXA3JsCkQMngDgU7WoKBsVBAoAA1aEmABo3uDe3cAgAc48KMQGsjSYSpwhoDpbWHcjy3hrbyHewkZ8AlgJLgcX6PAEBmoNl+ATVwTI8J4MyQbEMnwCWCEuExdJmAgI0h5wB1YESQBx6FMGAHUoAEKA6SAaIQ4W7jXyHHkUHt0iIAPPSNBYb+QmKQ4+iAwGqQ0bjjMa2CiaAheHeo+jQHGwVTIC7C9wFjQWNK+5eYWnmzgbmrmlcrdp0iBlQHXpxFANxyBHAgOZAGYDGDHeGpcC9mLuundqnoIO2IU2basnfoQVAnaAFbUxsYBb1ahYp6fpqln6sk9JspUzQJojBVohTBdmUcTSyrOLUSUA2I048qIF4tCsJZCvDyTxsSwmWTE4VZOPv1Jxi799Ew2aTwbY9RFvETgWUaVAD0fCwCZiIh6+tAuZOPKiBbBacBNR7P9HwaEOlnW1QSSEPgkqyBc6lk4BsTTg1kOXTRLazOVUQY5yTFaeJShg0bLZYuW/fffxqJwH1kZyogGxPsgSKfVNyaiAr6E7DxsPGw1aGrQybDD0ZNstSJwFZwjoNjwYP6rnRDyI9d7ut976T9b7HQX38OtGwWe+d1LeEfpzJg4bNsrjETgKyouI0lGscVEEtD2pOfUdyGrYxHzzmg8d8cMI9uGd2/fh42OCw9u31tNvZWe3i9KZnupftaXd83Twe3w6Hh81/28Nbb/T7ZXvs19ftSX/V+HbHH3pVwZ/7w87o4+HsHeZdNWOtMHV3ZS5DQhfslUicF+FQ0QXFOiRKu1JI8wqV7VTWFSrnMKewHEhJ50Bqmg2E5kWoBXENPYyUuW7wQiBEGM5KhdYFcjkjlWYDWRAhtsPbFAhTHhJ8nRh1oRu63NELPSieO1GuO9EWJBh9SOE8HTnJdV4thCFi9aFL6HZ/ng89tV9rLCRnZqQFXcxoCp8UFpIzxRYRiPnNauSFJZIQyGV6/5VCQ2qWyOvi0GFDHPliRv5KQ0ZiJVmKRP6tRiwFJScWqes0RDI0pKV1Gi1gTPVhd15jaaXRmJaoDyqzKy0tTEvR8zoWSrgYDj2oXWssJJgeHMeQhiiz/bi17FzsJZ/KTuL7604q9xaeJPcXnlTvLTyp3V94cri38Cwq3FR4FuO4sfAsatxYNDL9W41bC8+ixo2FZ1HjxsKzuNZurDy53VZ59BXcbOWhpW2+DInL2iV5Vd2R2bpDaWksRhz67CGzvaCFCqovDjCeNac2d/ijpRNopXEAPXciE9/eiVTT6ESYPYHSQv2soY7TuNbjWYmlfVGfxcdxXPMprzkJhzQkQpkvPUsSMY/Vqtm+TuL8XKEvCVZJ5FFCFdf1glM4L1VZJ1HOq722dYGci05O6wLJNPb3zKsCEcKECJU1Ao2Q3o1XBXF+TGxpXQ9GTjXhO0P4LPBVv26f9qerP4I+TOq0334/7Pzrz7fj08Wvr/+/4Bf8kfRyen7a/Xg77Uzp/G+SfnzR900POdev9opPv8ZaHvSsYl+j/aobhv7r8fXDOvMH",brillig_names:["_set_authorized"]},{name:"consume",is_unconstrained:!0,custom_attributes:["public"],abi:{parameters:[{name:"on_behalf_of",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]},visibility:"private"},{name:"inner_hash",type:{kind:"field"},visibility:"private"}],return_type:{abi_type:{kind:"field"},visibility:"public"},error_types:{"206160798890201757":{error_kind:"string",string:"Storage slot 0 not allowed. Storage slots must start from 1."},"715723737710351018":{error_kind:"string",string:"rejecting all"},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"12737498021964987455":{error_kind:"string",string:"unauthorized"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"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",debug_symbols:"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",brillig_names:["consume"]},{name:"is_consumable",is_unconstrained:!0,custom_attributes:["public","view"],abi:{parameters:[{name:"on_behalf_of",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]},visibility:"private"},{name:"message_hash",type:{kind:"field"},visibility:"private"}],return_type:{abi_type:{kind:"boolean"},visibility:"public"},error_types:{"206160798890201757":{error_kind:"string",string:"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"5444967152290923376":{error_kind:"string",string:"Function is_consumable can only be called statically"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"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",debug_symbols:"tZndbiI9DIbvZY45yI8TJ72V1WrFtnSFhGjFtp/0qeq9b5z4NbDSjOigPYFnTPxO7DieAB/T0+7n+68f++Pzy+/p4dvH9PO0Pxz2v34cXh63b/uXY7N+TE5evE/TQ9xMPrRLkvc03qNexzLeKU4P3gsUhRQArJBhybAwLJwVigMkQFWoBJBbhM0UfFUIEYCPIiwRFoKFWCF5QFbIDpAAuAUTQARdgxIArFA9IA2IzgEIoO7RR0BVCLAEjIniFQWqAsHS8yzQ89whK/QoOmBwxmCOAFgK3HsUAj2KDgmgdycXATqYvAfo3SnAIqXik4C45waRFSgpJAeQqbJAVcgRwArsAQmAwQXuBZYK9yruZTMllwBtTGiFlDwphKAgZT2gDQ4yWDLfQTI/AJYES4JF5jyAFaTCB2SF4gFyiypQFaTCB6glOwLAImUzgBX65DtkhegBeotMDiCCLFAUUgSwQvaArMAOAHfJfIceRQdYqo5hKf7oBBKgKkgUA1hBymYABgcMll0wABaCu0TRQXbBgKyQcfcM94zBjMGMuxdYiri3bc5V3KNAGVBcVpCaHyBTbd2vSHccQICiEAMgKxAGE9wTLAnuSdzb3imyBB1kCWIRSAolKsiGHdAGU5tYde2mlARYwcMiAVLbcVUCJBYoA7yTCAdJiErJqGWfipBEQLUTGRWQLIVSBmUbJw11kCR/kGQ/uU4FJM2nk5cyUsogmZ+S2WQRku9UQPIYGETeKIOSeUjilcxX9nAKQlIvShkkDyolMiqgah4VKsEFI6gE74zISFT6M1eqaZDsaKUMomDEoJSMkOcgTUkJGQ9sNmk1qT/Je/5SJzIqoJ7JQTwqyEeZgVIGyUNVyWzZbNlsbDY2WzG9YrZepoPIqCiRC0bw6I+kHhFJ7aZu67MfxBoH9fwNMpvMXkl8pe5JGonS2SZZk71A0hGVCqiYckH+qNezUHLOKIO8NzKbrUey9Ui2HiniHqlXdvr83Ew4v/14O+12cny7ONC1Y97r9rQ7vk0Px/fDYTP9tz2890G/X7fH/v62PbVP217aHZ/aexN83h92Qp+bs7ebd20Vlr26Ny7RJFp/uBLx8yIcJayuwa1KTCLXK4Uwr1CDg0JtJ8I5hS8EkmYDWRBJbfaq0U4R52mk63ymhWm0ExxmQZ7Ok8jXk8gLElL1XaH1HxOIga8EeGE5WPrEWA6u2SRCuc5mmZeI0te6QjslngXctUCdF2gHfWQyiNuchF9ajVBtMdw6hcqqkH1aFUbLGcKIF6vxFQn2tp68FAf9Ww2fM/pEe06WdRrMERpcwzqN6pDS9syd11jaZGSr0nppnt1kfmFZ2gEZBcruIh3tkHPdtJZ6jnOWUud5dh43dhy6qNG/Ok4I97ecEO/tOYHubzoh3dt1Qr6/7QS+t+0sKtzUdhbjuLHvLGrc2DSi/7catzaeRY0bG8+ixo2NZ3Gv3dh5Yr6t87ST/mzniUuPeDvr8GXv4riq70Sa6ztxoYO2r2U4s7VvWW52FrQwDS4RtcElzZ4caenwmW2/cs6zR0cKi5FUK692Ys+zIouhhHMoeV5ioYe2n56wJuXcuyKlmw/BLgR7IOX51rMk4W1FWlrKOolss/Bl3SyitVB/eRD/ikSy9WhblddJ5PNuL3VdIOemE8O6QCLZ8z2mVYEwYUGY8hqBalu9plVBtJ+17PvduhlYTVVOd4bwt8D3drl93J+u/k35FKnTfvvzsNPL5/fj48Wnb/+/4hP8G/N6enncPb2fdqJ0/kumvXxr/xlsIrnv8kNZu2w/PG18jXLp5dPW4SLF758ymT8=",brillig_names:["is_consumable"]},{name:"is_reject_all",is_unconstrained:!0,custom_attributes:["public","view"],abi:{parameters:[{name:"on_behalf_of",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]},visibility:"private"}],return_type:{abi_type:{kind:"boolean"},visibility:"public"},error_types:{"206160798890201757":{error_kind:"string",string:"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"9474245853673257536":{error_kind:"string",string:"Function is_reject_all can only be called statically"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACIh4CAAIJJwIDAAEKKgIDBCQCAAQAAACJJQAAAksnAgIAAC0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQYtDgIGACIGAgYtDgIGACIGAgYtDgIGKwIABQAAAAAAAAAAAgAAAAAAAAAALQgBBicCBwQFAAgBBwEnAwYEAQAiBgIHLQoHCC0OAggAIggCCC0OAggAIggCCC0OAggAIggCCC0OBQgtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4MgEUABi0IAQcAAAECAS4MgEQABycCCAQJLQgACS0KBQotCgQLLQoGDC0KBw0tCgMOAAgACAAlAAACXS0CAAAnAgMECC0IAAgtCgUJLQoECi0KBgstCgcMLQoBDQAIAAMAJQAAAl0tAgAALQsHAQsiAAGARAADJAIAAwAAAbsnAggEADwGCAEnAgEECC0IAAgtCgUJLQoECi0KBgstCgcMAAgAAQAlAAADiy0CAAAtCwQBASIAAYBGAAQtCwQDCioDAgELIgABgEQAAiQCAAIAAAIMJQAABJ4vCgADAAEcCgEDARwKAwIAHAoCAQEmKACABAR4AA0AAACABIADJACAAwAAAkoqAQABBfeh86+lrdTKPAQCASYqAQABBYN7SGg+6XpAPAQCASYlAAACIi0LBAYLIgAGgEQAByQCAAcAAAJ/JwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAAxcjAAACmC0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACicCCwEBJAIACgAAAsIlAAAEsC4CAAeAAygAgAQEAAQlAAAEwi4IgAUACgAiCgILACoLBgwtDgUMASIABoBGAAUOKgYFByQCAAcAAAMCJQAABVAtDgoBLQ4IAi0OBQMtDgkEIwAAA4onAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAADiy0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAABMIuCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARgADLQ4IBCMAAAOKJiUAAAIiLgiARQAFIwAAA5sNIgAFgEMABiQCAAYAAAQLIwAAA7AtCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAABCEjAAAEjS0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABMIuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAEjQEiAAWARgAGLQoGBSMAAAObKgEAAQUC3G4ngHYSnTwEAgEmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAE3SMAAAToLgCAA4AFIwAABU8uAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFOy4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAFCigBgAUEAAEDAIAGAAKABiMAAAVPJioBAAEFRafKcRlB5BU8BAIBJg==",debug_symbols:"tZjdbts8DIbvxcc5EKn/3MpQFGmbDgGCtMiSD/hQ5N5HynyVeICNzcNO4se0+JrUDyXna3jbv1y/Px9O7x8/hu23r+HlfDgeD9+fjx+vu8vh4yTWr8HpD7k6bP1mIArDNui1jle2e892zcOWSCAwIBlEAsCSYEmwZAcIgGpQPKAYVH0FbwYmD8gGjEcMi4fFwxIIEA2iAwRANUh4RSoGWQWdQjIoBIiAalADoIzgHQOyQcuiASyMNqxe0v3ee0A2aFk0iIBqENE4onFiACwZ7i0LheIAAYC3V7hXaxycA9jbA8GiM4WigronAU4GPgCqQdBQs0IxiAxIBskBAgCNM9wzLAXuRd2LQBuCBtKGZf5E5w2IANVApzVLYNHLS7koRINglqSZclWQxl6GKel4NVCvESKgGmimXl6RNAvPCsVAZ9QIyUDHYgS0qX6E7AigjaXDMzGgGmgWDVo8DaJBgCVoG1m5WTt8hGyQooGuyhHQWPu5QYFX1XiiQhqh6NwYIQCKQQu1ARozAWDxcPdw93DX2uKTQjGI0UAnyQjJQGf4CNWgWB+Wkg0qAcxSWdvI/Kmtf4pCMWgd1SAbaB3TmVD1pQ2yA0SDAkuBpcJSzULOuU4JRN2m88yogHTKGXUP3z3acOdGmnyztagbadgav1AC5W7TyI201jslLQlG3aYzMlCjYkRa3IygTMSdKogDqI32SHgvhW4LvR1GgSh2vdjf0WZsud02A7aw58t5v9cd7GFPk53uc3feny7D9nQ9HjfDf7vjtTX68bk7tetld5ankt/+9CZXEXw/HPdKt83d2827EqdE5i5cfJcgFyYiNC8iyzWaRpZK3SVSnSjwvEJlB4XKXOYU/iCROJvIgkiQNWcaoYobJOK0P+NCGD4FRCFbyz2INA0iLUjEZArsuAt4zhOBvDAcOVQMh5S5LiHb/ESizEv4yOgHehBwU4E6L8BUMRqsbnMStDAakZGGbG/rFGo2hURxVRrSZ0jDP4zGn0hk6uOZl/II/1ZDDq+oE5RyWaeRM9aHHHh5nUZ16FI5Gc9rLC2y0EeFYkizi4wWhiXJyQSLRE7ND9Vius54YXrlXnHyQ4dS9qvqDfu5esMLlVO2GlROks+S2SjYL+RRPKZGLnG+foelruiLNctJcVYiLmZS++ySbTPNiiymwvdU0rzEQvmMGbUvlnvhku+W396KHENBzhXzdWdJgvqI6FlinUTqUVBZF4Xv9VNwXRSxj4cs1bxOIt1Xe6nrErnXHM/rEvGhb+zyobpGIgcMSA5pjUDtS73GVUlUl/spa10EfU7JF8NfpvCrwJPc7l4P58nfOjeVOh92L8e93b5fT68PTy//f+IJ/hb6PH+87t+u570q3f8bkp9vLF8UnNyTfgbIrXwfbGSp6S3pU6nnshc83TSYnw==",brillig_names:["is_reject_all"]},{name:"public_dispatch",is_unconstrained:!0,custom_attributes:["public"],abi:{parameters:[{name:"selector",type:{kind:"field"},visibility:"private"}],return_type:null,error_types:{"206160798890201757":{error_kind:"string",string:"Storage slot 0 not allowed. Storage slots must start from 1."},"715723737710351018":{error_kind:"string",string:"rejecting all"},"2830029349304997821":{error_kind:"fmtstring",length:27,item_types:[{kind:"field"}]},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"5444967152290923376":{error_kind:"string",string:"Function is_consumable can only be called statically"},"6304245522015439386":{error_kind:"string",string:"Function _set_authorized can only be called internally"},"9474245853673257536":{error_kind:"string",string:"Function is_reject_all can only be called statically"},"12737498021964987455":{error_kind:"string",string:"unauthorized"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"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",debug_symbols:"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",brillig_names:["public_dispatch"]},{name:"set_authorized",is_unconstrained:!0,custom_attributes:["public"],abi:{parameters:[{name:"message_hash",type:{kind:"field"},visibility:"private"},{name:"authorize",type:{kind:"boolean"},visibility:"private"}],return_type:null,error_types:{"206160798890201757":{error_kind:"string",string:"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"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",debug_symbols:"tZndbhs5DIXfxde5kETqL69SFEWaukUAwwncZIFFkHdfUuKh4wVm4I7RG+szRzwjShRHY7/vfuy/v/369nT8+fx7d//lfff99HQ4PP36dnh+fHh9ej6K9X0X9CPGsrunu11McXcfg0IxoADIBgwLw5JhyQxoBoUA1aAmgN4iCvQ6IYUIsEspwhJhSbCkDOgGxIBmwATALXICiGCXtgRrs7V9tpWsbbNtyVrz69HaOloK0dp5naLeKClUgwTLmFuFMbcDGNAMGJ0ZnXMEwFLgrmOf0A109BNw9wb3hs4NnTvu3s3CQd1ZQd2zQMwGiQDNgHSoRaEacARkQDfIBEDnAvcCS4V7Vfcq0AggfZIkD/c0IYcAaAZROqeqUA105ifAQrAQLDrmCdlAs3oCA7qBZnVqCtVAs3oCLA2WBoumzIQ8oYzBD2BAN4gEaAYjiqJQDCgCMqAbMAOaQYa7zvyAEcUAWCr6aNYnSeOiMz+hGowoBmRAn1ADAaxz1V0wAZYUAcVAd8EEBtjdK8Od0Tmjc7a71wJLEXeKCuJOksZVK8yAxoBu0GWoRAptQgsJUAxiADAAnRMBYCG4k7rL3mm6BBO0j6RN0+QfUCKgG1TpzFFBLCxeXQU5K4ggy6J0FRygSzmhGqjgBJkWFsGudYolbXoPAAa0CTFozJNicMogDdJIPbqSrtEk3TBGBTQGNqmCituK9Mta+YNGa9RBmmCTdG8bwSPqTjGCb9QtkuOgBtJNYlRAmmBG7OQe7Crstuwq2VWKq2ii5aRUg1MF6b43aiDNtkHjEWeEeU665ydFcnKb1qM8ns1j/lhp3HcSO3WQ7lnNHKEG6smpGlFITm6LbotuS25L0CNy20jPQXowMGIn98juobkxIiJN2zxsY/SDdPQjDhrzN6i7TUc/iMdMlkEFFN2mWZyrUgpO7ARlJszfeGgZYZ555MEkv29xm68H+3qwrwdXv8fIbP74uNvh5PXt9bTf68Hr01FMDmgvD6f98XV3f3w7HO52/zwc3kan3y8Px9G+PpzkquT+/vhDWhH8+XTYK33cnb3DsmvMsZt3lEefC+RLhbisII9Z3F+wuULpFwppWaFlPTUMBSmIYUlhLQru0aOIbSkKXlGgwlDgyK4gW/tCIq9NZTGFFJILUKoXAmVZoFbGWtTai0ukdjkRdVmCtJIMBY6fBMKlQFsWkDKDmUzqtiTRVxIiIYrPi/knAr2aQIl5UxAyYwiCPq3Fn0jU6KtZV8KI9Hc1YinYXfLC1LZp1ErQqD1t0+jB60RPyxprW4zbudRwWdxicWVZSg1ITzlSnqdDjg2XGivpJScHn9IQ6+I4rq03TEv1JsXbC05Kt1acRLeXnMS31pyUby86qdxadVYVrio7q3FcWXdWNa4sGhT+rsa1hWdV48rCs6pxZeFZ3WtXVh7K11WeVGix8tDaA764xOfaVWlT3SmLdYfamoTHIafeujgKWqmgjfzQKG+5fenAxiuRcEP1434eBHG+fhDyA5wPIvDiINYOnqH5wVPq8aLE2nNR3gIxDH0PpC2n15BcIpTl0rMmEcl3q2T7NolyDqRtGwV5CRXcNoqcwnmr1m0S5bzbW98WyLnoyCvuNgn257u8326RqIwFqVy2CHRGeve8KYgesJ49bRuB51Sv+cYQ/i/wVb4+PD6dLv69+FCp09PD98Pevv58Oz5+uvr67wuu4N+Pl9Pz4/7H22mvSue/QOTji+aB/Cj/VX96kq+xxbvYin6NelV+XCSirx86mP8A",brillig_names:["set_authorized"]},{name:"set_authorized_private",is_unconstrained:!1,custom_attributes:["private"],abi:{parameters:[{name:"inputs",type:{kind:"struct",path:"aztec::context::inputs::private_context_inputs::PrivateContextInputs",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"historical_header",type:{kind:"struct",path:"authwit::aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"authwit::aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"authwit::aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]},visibility:"private"},{name:"approver",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]},visibility:"private"},{name:"message_hash",type:{kind:"field"},visibility:"private"},{name:"authorize",type:{kind:"boolean"},visibility:"private"}],return_type:{abi_type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"min_revertible_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"is_fee_payer",type:{kind:"boolean"}},{name:"max_block_number",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",fields:[{name:"_opt",type:{kind:"struct",path:"std::option::Option",fields:[{name:"_is_some",type:{kind:"boolean"}},{name:"_value",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}},{name:"note_hash_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifier_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"key_validation_requests_and_generators",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",fields:[{name:"request",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",fields:[{name:"pk_m",type:{kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint",fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}]}},{name:"sk_app",type:{kind:"field"}}]}},{name:"sk_app_generator",type:{kind:"field"}}]}}},{name:"note_hashes",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::note_hash::NoteHash",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifiers",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::nullifier::Nullifier",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"note_hash",type:{kind:"field"}}]}}},{name:"private_call_requests",type:{kind:"array",length:5,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_call_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_teardown_call_request",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"l2_to_l1_msgs",type:{kind:"array",length:2,type:{kind:"struct",path:"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",fields:[{name:"recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"content",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"private_logs",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_log::PrivateLogData",fields:[{name:"log",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::log::Log",fields:[{name:"fields",type:{kind:"array",length:18,type:{kind:"field"}}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"note_hash_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"contract_class_logs_hashes",type:{kind:"array",length:1,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::log_hash::LogHash",fields:[{name:"value",type:{kind:"field"}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"historical_header",type:{kind:"struct",path:"authwit::aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"authwit::aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"authwit::aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}}]},visibility:"databus"},error_types:{"4939791462094160055":{error_kind:"string",string:"Message not authorized by account"},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"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",debug_symbols:"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",brillig_names:["store_in_execution_cache_oracle_wrapper","call_private_function_internal","load","notify_created_nullifier_oracle_wrapper","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper"],verification_key:"AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8ACPfokPF0pNADZMhT3vFbPt2fHkbTp6GVACtCgBW1tJUEuKJPC4oDBI6h1FHz1Ey1bMI7jhceJIKxosuCKCEv/BLj8RhePumnXeRrVSHaj5p12zM01xANw9YsVEc1B0n9G0JZLN1rigP/7GTejrYxBK/ENJGi6ywQZUTrectPlgkemF8+eeRrv1oHWGHcw3ozT6n4vdyWmpTzjf+96TAZuhHOVdiZ5aMmOk8cnpKVxnj9LNzQWGggi/q7s20SWeScJFQGBQH8s6kDQ91hqDM1toljnLa9JzVHbbTHYNQgS0MOmOPLQTMBrOgepGgblnx9sKfOa068fGqHzspvPPoFORMqpG+67IWCmPjIbdHwWy7bFTihZ7T1PlX2Mff9P8hzBf5t4VjcX5g/ao2RV8agqbcmQ5pl0by9PDp8wCQ0RtcUZibM9rVOVfqJygZbSvMikH0cmtlTigyIstOGQazcLxaclgduRrE/+ukbozjj/zkZSyQr0X2EuLTyW6XeEIFbJ34e3MIBh/bZnQqcjCd6Eo8n4+S1X0QwM2Q7BxTO32ERhG3XjR3FaaW5IHNUc4FjfZjumN7m5SaIFHQ/qD0KTCmMMxH8kXD5LelAsEKquZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLsQ2OaZ9pnbNpzwUDK11XIL+rz3MitK5pKLdC+rrzrB6CxY/QqiAk6C5WHa0uLw5C9Y614IFLtDODilJ9QoCqE2ItSSS5jMY1+2OU9rwu1Sg3gmX9QciLRqDAvnJE6ZDBgMcltqlvfI9dIm/W8QUbmF9DcvtTo01DakchasgVI+ViHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk6o4uDu5wKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxua015bsn0E4YWuRKVxKct3D6sKlhhHfWKf0zqTShDD09yQw2Hv+h1T+PCDLbvfFKtQvU4pdsKfT4OAkUDvRsvO03KkY/tWgA/zcH2P9+RhmmEjVLm8hrP29pg7ocfjkGADu/NVWUEJXhtCA0EJ8P7KKhaz+T+GtHpKUm05AOzXknXhH9FCOqTq8znVFvLcjsiWjrjQUUsRfEWAi+bIJgCp/Ee6IIugnFsCDCNrzwAuuev5pH7zgL30gkPbiLbZRmGW6Qg7iT7VrfGN/vyyOrvt+AWxeIUHVIe8nSnZJH1RSmzuwhFu19PsDdPpPIDHSZoxC7OUVMKe/eGz1Eoxs8gBQPgdCWJVH/Ooq4wFS9+Hfudhf/35QatS0kI2lENWay/4GrTHYloJXD5vgjugw2yVWwG72OvHqMQt1YZpIODdgfMGrdjTBJkmkKPmVprPxVtd/5ovLQXXIVaPaFuqPwPs+X1cX6EC01gvaM94V0O6Hyv6sxSlxHNhs+jDwjxSI3JlW/Z1h8abx9Sih8+y461guPXqnaYLuXCE8R9Ns1kdQSzWR+TL0NlMdrTfkFWdHUqFcfj8e0Om/O1XtsGcc8P+9q6JDJ++2IcwIAgqo3xAByj0Ri/oQnDL46GyT4wvYk1PmI0LbKvCnYKtKsrVFwVph1BnHvYE2wqZMbJtn9FsYWXKyGsx7Eop3wvt3FcZmYct05kIVQGc6lRxanLyD8cD/Zr53T+xHQ5Kw9OSPjgB/EH0aHAOhOYxK8nZ7NlznnzuA5xP2LE7DHD0KmTgzq8vX4GvLCnAesgn92qLBoI+DBI82oEKu56sApYuJLhcLDe4P8p6rsFVrJ8d9jonXBimuavBvz/FQdIdUDEeh0hRoy4/lf6GArcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJ2fA5Wa7LlOBymgvADlTZwg7C8Ppm73VPNQmV4KkdpoJ+eV6//PhraWZmum2YDVateD+shv5yOZBnvdDZyX4uQDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"},{name:"set_reject_all",is_unconstrained:!0,custom_attributes:["public"],abi:{parameters:[{name:"reject",type:{kind:"boolean"},visibility:"private"}],return_type:null,error_types:{"206160798890201757":{error_kind:"string",string:"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcdAIBHgEcBLgiARwABJQAAAEwlAAAAaSgCAAEEgEgnAgIEADsOAAIAASgAgEMEAAMoAIBEAQAAKACARQQAACgAgEYEAAEmJQAAAgceAgACAScCAwAALQgBBCcCBQQEAAgBBQEnAwQEAQAiBAIFLQoFBi0OAwYAIgYCBi0OAwYAIgYCBi0OAwYrAgAFAAAAAAAAAAACAAAAAAAAAAAtCAEGJwIHBAUACAEHAScDBgQBACIGAgctCgcILQ4DCAAiCAIILQ4DCAAiCAIILQ4DCAAiCAIILQ4FCC0IAQUAAAECAS0OBAUtCAEEAAABAgEtDgYELQgBBgAAAQIBLgyARQAGLQgBBwAAAQIBLgyARAAHJwIIAAEnAgkECi0IAAotCgULLQoEDC0KBg0tCgcOLQoIDwAIAAkAJQAAAjAtAgAAJwIIBAktCAAJLQoFCi0KBAstCgYMLQoHDS0KAg4ACAAIACUAAAIwLQIAAC0LBwILIgACgEQACCQCAAgAAAGqJwIJBAA8BgkBJwICBAgtCAAILQoFCS0KBAotCgYLLQoHDAAIAAIAJQAAA14tAgAALQsEAgEiAAKARgAFLQsFBAoqBAMCCyIAAoBEAAMkAgADAAAB+yUAAARxHAoBAgAwCgACAAQmKACABAR4AA0AAACABIADJACAAwAAAi8qAQABBfeh86+lrdTKPAQCASYlAAACBy0LBAYLIgAGgEQAByQCAAcAAAJSJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAAuojAAACay0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACicCCwEBJAIACgAAApUlAAAEgy4CAAeAAygAgAQEAAQlAAAElS4IgAUACgAiCgILACoLBgwtDgUMASIABoBGAAUOKgYFByQCAAcAAALVJQAABSMtDgoBLQ4IAi0OBQMtDgkEIwAAA10nAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAADXi0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAABJUuCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARgADLQ4IBCMAAANdJiUAAAIHLgiARQAFIwAAA24NIgAFgEMABiQCAAYAAAPeIwAAA4MtCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAAA/QjAAAEYC0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABJUuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAEYAEiAAWARgAGLQoGBSMAAANuKgEAAQUC3G4ngHYSnTwEAgEmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAEsCMAAAS7LgCAA4AFIwAABSIuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFDi4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAE3SgBgAUEAAEDAIAGAAKABiMAAAUiJioBAAEFRafKcRlB5BU8BAIBJg==",debug_symbols:"tZjdbuM4DIXfJde5EPVHqa8yKIq0TQcBgrTIJAssirz7khKPnCxgY8eLuak+0+IRKVGymu/N+/71+vPlcPr4/LV5+vG9eT0fjsfDz5fj59vucvg8ifV74/QPkTRhK23aPJET8A4QAdUgwBJgibDEYpA8gA0yAbIB6xAkUAmQOnjnALAQLDQs1cAHQDEIHsAGkQDZIIlg1TZaW3ubg7XcW/bW5t4W8yuptxp8a/tzcM5aHcgLEAFgaXPbIAKKQYu8ATpHdI7JIMGS4K6xN9DgO7ABY3SGO6NzQeeC0SssVd3jdhOduieFakBs4D1AQ80CgQAJUA1iALBBQucE9wxLhntWdxZgNijSxzuFbFBjh+Q8QDp7CT6RWsQrqaAvCiLoZXWSCjbQZWxQHSACZFqCCGattCA1k7XSOrCBptwhGUT00b3QQBNsoAkGr8AGHAHVQONpoPF0GBbtI5uUNcEGmmADragOCYDOIQDgpVsgyPywLkGHBKgGWkgd2IDRmeFeYClwL3CvcNdCClIkxQWDdtI0SAaeANlAT5gONocleoBNZkmwsPaRailtfmS5axurARu0iWqQeyVUHbSD1UYNDgBLhCXCkmBJsGTo5GGpBhwAbFDQuaBzW+WsoCmLhVyLtVPuUZNrU9Rp2DReI/WtjSooDpvWYdTz1qUwiEF5KGcGtarsVEFtjRvVMW6dbOhHmHsh6BFhjPZVCXy7bTf4Br1czvu9foLuPkryqfranfeny+bpdD0et5u/dsdr6/Tra3dq7WV3lreSwf70Lq0IfhyOe6XbdvJ2865UXTZvqj4OgfSoQPMKyRWML1iGQq4PCn5eoSQ9P5tCScHNKSxlUUocWbg0l0VcUAh5KESa5oFyfJBICxIJM+mdHwLB84NAnhdgjtUUmGseEr48TgTPS4TkTSHSnYB7FCjzAnKdIGShbnMSdaEgPLK4X8zfEahsApnSqiRkxpBEuFuL35FgGqvJC2lQ+LMack3E7qLMZZ0Gc4AGV79Oo7o6nRPzGktbLI5VoRTz7BajhWXJ7FCeLFfUScM97jJaKC/OQ+JuQonDqtMmhLnTxtPSXIw8KMoJMReFXzo2A2E+S/B19uBdWNU4Eol1CkKu2P89CF/8CMLF2SAWzs0iH1VIyDE8K7FwchJlhzCEY1jzDXF+SLg8f+4sSVAYm1WqfZ1EnhIp66II4/wUXBdF8m7aqrxOIk+7vdR1iUxnjvxruE4ijq0a0qpEOGJBOOY1AnJtNoGaViUh93cI+HURjJqqnP5nCv8WeJbH3dvh/PBryk2lzofd63Fvjx/X09vd28vfX3iDX2O+zp9v+/frea9K008y8ueHl39wfPLPesWWR7lcb+Umro+kb1OQt+n5psH8Aw==",brillig_names:["set_reject_all"]},{name:"sync_private_state",is_unconstrained:!0,custom_attributes:["utility"],abi:{parameters:[],return_type:null,error_types:{"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=",debug_symbols:"nZPRioQgFIbf5Vx3oaWmvsowDFY2CGLh1MISvfvqoDu14DLMjSfzfF9/pRsMulvvN+PG6QHyskHnjbXmfrNTrxYzuXB3AxQH3IBsKsAEJA2FgmxDYSDFvleQ+2+L1zq2HwRBOyuv3QLSrdZW8KXs+mx6zMo966J8WEUVaDeEGoSjsTpe7dWLRmUUI0pYwjFiiP4qMCInCS5LWp4VPEBZ0OITX5d5WtPEU/p6B0zYuwF40+YAVJQCkDJPGpF4wvhHATjJAQQvBWBlPnz4xLOafRJA1HUSiIaWAvB/AvC8iVr05xdcw1T1xp/29h5V3qjO6jQdV9cfVpfvOa/kszH7qdfD6nU0HQ5IGC+YV3Vz3ePTfgA=",brillig_names:["sync_private_state"]},{name:"utility_is_consumable",is_unconstrained:!0,custom_attributes:["utility"],abi:{parameters:[{name:"on_behalf_of",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]},visibility:"private"},{name:"message_hash",type:{kind:"field"},visibility:"private"}],return_type:{abi_type:{kind:"boolean"},visibility:"public"},error_types:{"206160798890201757":{error_kind:"string",string:"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"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",debug_symbols:"tZndbhs5DIXfxde5kERRlPIqRVG4qVMYMJzATRZYBHn3JS2eGTvACN4xepPzOe580S8l1x+bX7uf779/7I/PL382j98+Nj9P+8Nh//vH4eVp+7Z/OepvPzbBfiT9SQ+bFDePrJE2j6JBm8emkTePsWiyZ/EUz+rZelLwjJ7JkzzdR+4j8+mfI/Gsnq1nDp7RM3mSZ/ZkT/dl92X3Zfex+bSXHD2TJ3lmT/YsnuJZPVvP4r7ivmK+qkme2ZM9i6d4Vs/WU4Jn9HSfuE/cJ+4T94n7xH3ivuq+6r7qvqq+FDTVl6ImexZP8VRfSpqtZwue0TN5kmf2ZM/iKZ7m08XWWs8YTFgMIiABCKBSOv9jBhSAACqgOcQAiIAEIADM0czZoAAEUAHN4bxhzhABCUCADIA5wZxgts1DyaA52PbpEAEJQIAMYEABCABmgtk2ErFBBCQAATKAAQUggApoDgwzw8wwM8wMM8PMMDPMDDPDbJuLxMDM1SABCJABZm4GBSCACmgOts06REACECAD1JyDQQGoOduyse3WoTnYhuug5myP25Zje8r2XIcMYEABCKAC1Mw2Grb1OlihtmGxzdeBOiTbO1wN7DdWv23vdGBAAQhA/1YJdgKouUSDBCBABjCgAARQAdrmkuwsCYAISAACZAADzGwnku2UDhXQHGyndIiABCCACbNBAQigApqDbZAOEZAABMgAmDPMtkGKHZ+2QTo0B9sgHSIgAQiA4WUML2N4GcNra76cz2B7y6bbVniHCmgOtsLPK8FWeAesDVvhHTKAAQUggApoDhXmCnOFucJcYa4w28I+N94WdrHf2DLukLzNtow7ZAADrMu2Vu0g6VAB2jAJdvUIgAhwMwUCZAADCkAAFeCDSXaUdIgAmM/7Qj4/Hza4WP14O+12dq+6uGnp/et1e9od3zaPx/fD4WHzz/bwfv5Hf163x3O+bU/6rrZ6d/ylqcLn/WFn9PkwPx2WH9XTMRd/XA/IwJNCD9ArSVyWSIWi6kMQSLx6Pi0/z4n9eea5D3qO3NqAagW/N4DbUgPy8vPZSvb5+VzqqgbUjAa0utSAsvy8Drw/X1JZ04Bm96SzoBEvNaAOGlCxiCQsT8FgIXGpEZMoYR4Dvl6KcbQWqWAU9cIxLyQ9rq8dg3HQK4Ir9FibDJTk2jBYjCIZi0GkzZORart20LKDGLOR44UhfDEMVqSehhjOZM8tOni0rdARprDO0LCvSuR1/dBhQz/oYkb+l0PiNKky6kn7uw69JGKT6DWxrnOIEBzS0jpHCxhTvc0NHKO9lqd50Xt2WdxraTAvRUKcisbFeOjnq2sHj86fMI1piLLYjlsrT+KlypPk/sqT6r2VJ7X7Kw+FeysPxfsrD6V7K8/QcFPlGfbjxsozdNxYNaj8XcetlWfouLHyDB03Vp7hXrux8uR4W+XRTziLlSePzvkyKS5rl9CqupPzUt3JeTSvMtWd0tpiKzKP9qt9HurrSz/3L95+h9M6FZ50WYS/KgazKhEXWLm8QZd0bRjUz3lZcAzrDDFMVUeWDaNehLkXbdHAg5VJqaERRBcnCWW+dqTRmTjv1HAxo1S+OAY30BoxmpXysmF0uk+jWagsGsYrk+t8kix+MOTBytQDHVN6ORBfBnP4+Xb6YKQfb5dPkpEi0lR8tXitU5SpFfr/d6sUNJ2IiutawSnMlVfWKcpcvGtb15H5DKG0riOUp7JJvKojkjEhkssaQcsoFY1XdaIFzGdL61owrakmfGcXvgq+68vt0/509cXfp6lO++3Pw85fPr8fny7effv3Fe/gi8PX08vT7tf7aWem+dtD/fGN9Kscncjv9vWLvoyNH1II9jLau9o4yvL90xrzHw==",brillig_names:["utility_is_consumable"]}],a={globals:{storage:[{fields:[{name:"contract_name",value:{kind:"string",value:"AuthRegistry"}},{name:"fields",value:{fields:[{name:"reject_all",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000001"}}],kind:"struct"}},{name:"approved_actions",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000002"}}],kind:"struct"}}],kind:"struct"}}],kind:"struct"}]},structs:{functions:[{fields:[{name:"parameters",type:{fields:[{name:"approver",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"message_hash",type:{kind:"field"}},{name:"authorize",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::_set_authorized_parameters"}}],kind:"struct",path:"AuthRegistry::_set_authorized_abi"},{fields:[{name:"parameters",type:{fields:[{name:"on_behalf_of",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"inner_hash",type:{kind:"field"}}],kind:"struct",path:"AuthRegistry::consume_parameters"}},{name:"return_type",type:{kind:"field"}}],kind:"struct",path:"AuthRegistry::consume_abi"},{fields:[{name:"parameters",type:{fields:[{name:"on_behalf_of",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"message_hash",type:{kind:"field"}}],kind:"struct",path:"AuthRegistry::is_consumable_parameters"}},{name:"return_type",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::is_consumable_abi"},{fields:[{name:"parameters",type:{fields:[{name:"on_behalf_of",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],kind:"struct",path:"AuthRegistry::is_reject_all_parameters"}},{name:"return_type",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::is_reject_all_abi"},{fields:[{name:"parameters",type:{fields:[{name:"message_hash",type:{kind:"field"}},{name:"authorize",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::set_authorized_parameters"}}],kind:"struct",path:"AuthRegistry::set_authorized_abi"},{fields:[{name:"parameters",type:{fields:[{name:"approver",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"message_hash",type:{kind:"field"}},{name:"authorize",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::set_authorized_private_parameters"}}],kind:"struct",path:"AuthRegistry::set_authorized_private_abi"},{fields:[{name:"parameters",type:{fields:[{name:"reject",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::set_reject_all_parameters"}}],kind:"struct",path:"AuthRegistry::set_reject_all_abi"},{fields:[{name:"parameters",type:{fields:[],kind:"struct",path:"AuthRegistry::sync_private_state_parameters"}}],kind:"struct",path:"AuthRegistry::sync_private_state_abi"},{fields:[{name:"parameters",type:{fields:[{name:"on_behalf_of",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"message_hash",type:{kind:"field"}}],kind:"struct",path:"AuthRegistry::utility_is_consumable_parameters"}},{name:"return_type",type:{kind:"boolean"}}],kind:"struct",path:"AuthRegistry::utility_is_consumable_abi"}]}},s={43:{path:"std/panic.nr",source:`pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {
    assert(false, message);
    crate::mem::zeroed()
}
`},50:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/auth_registry_contract/src/main.nr",source:`/**
 * @title AuthRegistry Contract
 * @notice Manages authorization of public actions through authentication witnesses (authwits)
 * @dev This contract allows users to approve/reject public actions that can be performed on their behalf by other
 * addresses
 */
use dep::aztec::macros::aztec;

#[aztec]
pub contract AuthRegistry {
    use dep::authwit::auth::{
        assert_current_call_valid_authwit, compute_authwit_message_hash, IS_VALID_SELECTOR,
    };
    use dep::aztec::{
        macros::{functions::{internal, private, public, utility, view}, storage::storage},
        protocol_types::address::AztecAddress,
        state_vars::{Map, PublicMutable},
    };

    #[storage]
    struct Storage<Context> {
        /// Map of addresses that have rejected all actions
        reject_all: Map<AztecAddress, PublicMutable<bool, Context>, Context>,
        /// Nested map of approvers to their authorized message hashes
        /// First key is the approver address, second key is the message hash, value is authorization status
        approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,
    }

    /**
     * Updates the \`authorized\` value for \`msg_sender\` for \`message_hash\`.
     *
     * @param message_hash The message hash being authorized
     * @param authorize True if the caller is authorized to perform the message hash, false otherwise
     */
    #[public]
    fn set_authorized(message_hash: Field, authorize: bool) {
        storage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);
    }

    /**
     * Updates the \`reject_all\` value for \`msg_sender\`.
     *
     * When \`reject_all\` is \`true\` any \`consume\` on \`msg_sender\` will revert.
     *
     * @param reject True if all actions should be rejected, false otherwise
     */
    #[public]
    fn set_reject_all(reject: bool) {
        storage.reject_all.at(context.msg_sender()).write(reject);
    }

    /**
     * Consumes an \`inner_hash\` on behalf of \`on_behalf_of\` if the caller is authorized to do so.
     *
     * Will revert even if the caller is authorized if \`reject_all\` is set to true for \`on_behalf_of\`.
     * This is to support "mass-revoke".
     *
     * @param on_behalf_of The address on whose behalf the action is being consumed
     * @param inner_hash The inner_hash of the authwit
     * @return \`IS_VALID_SELECTOR\` if the action was consumed, revert otherwise
     */
    #[public]
    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {
        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), "rejecting all");

        let message_hash = compute_authwit_message_hash(
            context.msg_sender(),
            context.chain_id(),
            context.version(),
            inner_hash,
        );

        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();

        assert_eq(true, authorized, "unauthorized");
        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);

        IS_VALID_SELECTOR
    }

    /**
     * Updates a public authwit using a private authwit
     *
     * Useful for the case where you want someone else to insert a public authwit for you.
     * For example, if Alice wants Bob to insert an authwit in public, such that they can execute
     * a trade, Alice can create a private authwit, and Bob can call this function with it.
     *
     * @param approver The address of the approver (Alice in the example)
     * @param message_hash The message hash to authorize
     * @param authorize True if the message hash should be authorized, false otherwise
     */
    #[private]
    fn set_authorized_private(approver: AztecAddress, message_hash: Field, authorize: bool) {
        assert_current_call_valid_authwit(&mut context, approver);
        AuthRegistry::at(context.this_address())
            ._set_authorized(approver, message_hash, authorize)
            .enqueue(&mut context);
    }

    /**
     * Internal function to update the \`authorized\` value for \`approver\` for \`messageHash\`.
     * Used along with \`set_authorized_private\` to update the public authwit.
     *
     * @param approver The address of the approver
     * @param message_hash The message hash being authorized
     * @param authorize True if the caller is authorized to perform the message hash, false otherwise
     */
    #[public]
    #[internal]
    fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {
        storage.approved_actions.at(approver).at(message_hash).write(authorize);
    }

    /**
     * Fetches the \`reject_all\` value for \`on_behalf_of\`.
     *
     * @param on_behalf_of The address to check
     * @return True if all actions are rejected, false otherwise
     */
    #[public]
    #[view]
    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {
        storage.reject_all.at(on_behalf_of).read()
    }

    /**
     * Fetches the \`authorized\` value for \`on_behalf_of\` for \`message_hash\`.
     *
     * @param on_behalf_of The address on whose behalf the action is being consumed
     * @param message_hash The message hash to check
     * @return True if the caller is authorized to perform the action, false otherwise
     */
    #[public]
    #[view]
    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> bool {
        storage.approved_actions.at(on_behalf_of).at(message_hash).read()
    }

    /**
     * Just like \`is_consumable\`, but a utility function and not public.
     */
    #[utility]
    unconstrained fn utility_is_consumable(
        on_behalf_of: AztecAddress,
        message_hash: Field,
    ) -> bool {
        storage.approved_actions.at(on_behalf_of).at(message_hash).read()
    }
}
`},52:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth.nr",source:`use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};
use dep::aztec::protocol_types::{
    abis::function_selector::FunctionSelector,
    address::AztecAddress,
    constants::{
        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,
        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,
    },
    hash::poseidon2_hash_with_separator,
    traits::ToField,
};

/**
 * Authenticaion witness helper library
 *
 * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties
 * (e.g. protocols or other users) to execute an action on their behalf.
 *
 * This library provides helper functions to manage such witnesses.
 * The authentication witness, is some "witness" (data) that authenticates a \`message_hash\`.
 * The simplest example of an authentication witness, is a signature. The signature is the "evidence",
 * that the signer has seen the message, agrees with it, and has allowed it.
 * It does not need to be a signature. It could be any kind of "proof" that the message is allowed.
 * Another proof could be knowing some kind of secret, or having some kind of "token" that allows the message.
 *
 * The \`message_hash\` is a hash of the following structure:
 * hash(consumer, chain_id, version, inner_hash)
 * - consumer: the address of the contract that is "consuming" the message,
 * - chain_id: the chain id of the chain that the message is being consumed on,
 * - version: the version of the chain that the message is being consumed on,
 * - inner_hash: the hash of the "inner" message that is being consumed, this is the "actual" message or action.
 *
 * While the \`inner_hash\` could be anything, such as showing you signed a specific message, it will often be
 * a hash of the "action" to approve, along with who made the call. As part of this library, we provide a few
 * helper functions to deal with such messages.
 *
 * For example, we provide helper function that is used for checking that the message is an encoding of the current call.
 * This can be used to let some contract "allow" another contract to act on its behalf, as long as it can
 * show that it is acting on behalf of the contract.
 *
 * If we take a case of allowing a contract to transfer tokens on behalf of an account, the \`inner_hash\` can be
 * derived as:
 * inner_hash = hash(caller, "transfer", hash(to, amount))
 *
 * Where the \`caller\` would be the address of the contract that is trying to transfer the tokens, and \`to\` and \`amount\`
 * the arguments for the transfer.
 *
 * Note that we have both a \`caller\` and a \`consumer\`, the \`consumer\` will be the contract that is consuming the message,
 * in the case of the transfer, it would be the \`Token\` contract itself, while the caller, will be the actor that is
 * allowed to transfer the tokens.
 *
 *
 * The authentication mechanism works differently in public and private contexts. In private, we recall that everything
 * is executed on the user's device, so we can use \`oracles\` to "ask" the user (not contract) for information. In public
 * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a "registry"
 * to store the messages that we have approved.
 *
 * A simple example would be a "token" that is being "pulled" from one account into another. We will first outline
 * how this would look in private, and then in public later.
 *
 * Say that a user \`Alice\` wants to deposit some tokens into a DeFi protocol (say a DEX).
 * \`Alice\` would make a \`deposit\` transaction, that she is executing using her account contract.
 * The account would call the \`DeFi\` contract to execute \`deposit\`, which would try to pull funds from the \`Token\`
 * contract. Since the \`DeFi\` contract is trying to pull funds from an account that is not its own, it needs to
 * convince the \`Token\` contract that it is allowed to do so.
 *
 * This is where the authentication witness comes in The \`Token\` contract computes a \`message_hash\` from the
 * \`transfer\` call, and then asks \`Alice Account\` contract to verify that the \`DeFi\` contract is allowed to
 * execute that call.
 *
 * \`Alice Account\` contract can then ask \`Alice\` if she wants to allow the \`DeFi\` contract to pull funds from her
 * account. If she does, she will sign the \`message_hash\` and return the signature to the \`Alice Account\` which
 * will validate it and return success to the \`Token\` contract which will then allow the \`DeFi\` contract to pull
 * funds from \`Alice\`.
 *
 * To ensure that the same "approval" cannot be used multiple times, we also compute a \`nullifier\` for the
 * authentication witness, and emit it from the \`Token\` contract (consumer).
 *
 * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.
 *
 *
 *  Person          Contract              Contract               Contract
 *  Alice          Alice Account          Token                   DeFi
 *   |                  |                  |                      |
 *   | Defi.deposit(Token, 1000)           |                      |
 *   |----------------->|                  |                      |
 *   |                  | deposit(Token, 1000)                    |
 *   |                  |---------------------------------------->|
 *   |                  |                  |                      |
 *   |                  |                  | transfer(Alice, Defi, 1000)
 *   |                  |                  |<---------------------|
 *   |                  |                  |                      |
 *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)
 *   |                  |<-----------------|                      |
 *   |                  |                  |                      |
 *   | Please give me AuthWit for DeFi     |                      |
 *   | calling transfer(Alice, Defi, 1000) |                      |
 *   |<-----------------|                  |                      |
 *   |                  |                  |                      |
 *   |                  |                  |                      |
 *   | AuthWit for transfer(Alice, Defi, 1000)                    |
 *   |----------------->|                  |                      |
 *   |                  | AuthWit validity |                      |
 *   |                  |----------------->|                      |
 *   |                  |                  |                      |
 *   |                  |       throw if invalid AuthWit          |
 *   |                  |                  |                      |
 *   |                  |       emit AuthWit nullifier            |
 *   |                  |                  |                      |
 *   |                  |       transfer(Alice, Defi, 1000)       |
 *   |                  |                  |                      |
 *   |                  |                  |                      |
 *   |                  |                  | success              |
 *   |                  |                  |--------------------->|
 *   |                  |                  |                      |
 *   |                  |                  |                      |
 *   |                  |                  |           deposit(Token, 1000)
 *   |                  |                  |                      |
 *   |                  |                  |                      |
 *
 *
 * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store
 * the messages that we have approved.
 *
 * To approve a message, \`Alice Account\` can make a \`set_authorized\` call to the registry, to set a \`message_hash\`
 * as authorized. This is essentially a mapping from \`message_hash\` to \`true\` for \`Alice Contract\`. Every account
 * has its own map in the registry, so \`Alice\` cannot approve a message for \`Bob\`.
 *
 * The \`Token\` contract can then try to "spend" the approval by calling \`consume\` on the registry. If the message
 * was approved, the value is updated to \`false\`, and we return the success flag. For more information on the
 * registry, see \`main.nr\` in \`auth_registry_contract\`.
 *
 * Person          Contract              Contract            Contract               Contract
 * Alice          Alice Account          Registry             Token                   DeFi
 *   |                  |                    |                   |                      |
 *   | Registry.set_authorized(..., true)    |                   |                      |
 *   |----------------->|                    |                   |                      |
 *   |                  | set_authorized(..., true)              |                      |
 *   |                  |------------------->|                   |                      |
 *   |                  |                    |                   |                      |
 *   |                  |         set authorized to true         |                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   |                      |
 *   | Defi.deposit(Token, 1000)             |                   |                      |
 *   |----------------->|                    |                   |                      |
 *   |                  | deposit(Token, 1000)                   |                      |
 *   |                  |-------------------------------------------------------------->|
 *   |                  |                    |                   |                      |
 *   |                  |                    |              transfer(Alice, Defi, 1000) |
 *   |                  |                    |                   |<---------------------|
 *   |                  |                    |                   |                      |
 *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)
 *   |                  |                    |<------------------|                      |
 *   |                  |                    |                   |                      |
 *   |                  |          throw if invalid AuthWit      |                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   |                      |
 *   |                  |           set authorized to false      |                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    | AuthWit validity  |                      |
 *   |                  |                    |------------------>|                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   | transfer(Alice, Defi, 1000)
 *   |                  |                    |                   |<-------------------->|
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   | success              |
 *   |                  |                    |                   |--------------------->|
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   |     deposit(Token, 1000)
 *   |                  |                    |                   |                      |
 *
 *
 * --- FAQ ---
 * Q:   Why are we using a success flag of \`poseidon2_hash_bytes("IS_VALID()")\` instead of just returning a boolean?
 * A:   We want to make sure that we don't accidentally return \`true\` if there is a collision in the function selector.
 *      By returning a hash of \`IS_VALID()\`, it becomes very unlikely that there is both a collision and we return
 *      a success flag.
 *
 * Q:   Why are we using static calls?
 * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it
 *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.
 *
 * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?
 * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be
 *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the
 *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.
 *
 * Q:   Why is the chain id and the version part of the message hash?
 * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific
 *      chain to avoid a case where the same message could be used across multiple chains.
 */

pub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes("IS_VALID()")

/**
 * Assert that \`on_behalf_of\` has authorized the current call with a valid authentication witness
 *
 * Compute the \`inner_hash\` using the \`msg_sender\`, \`selector\` and \`args_hash\` and then make a call out to the
 * \`on_behalf_of\` contract to verify that the \`inner_hash\` is valid.
 *
 * @param on_behalf_of The address that has allegedly authorized the current call
 */
// docs:start:assert_current_call_valid_authwit
pub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {
    let inner_hash = compute_inner_authwit_hash([
        context.msg_sender().to_field(),
        context.selector().to_field(),
        context.args_hash,
    ]);
    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);
}
// docs:end:assert_current_call_valid_authwit

/**
 * Assert that a specific \`inner_hash\` is valid for the \`on_behalf_of\` address
 *
 * Used as an internal function for \`assert_current_call_valid_authwit\` and can be used as a standalone function when
 * the \`inner_hash\` is from a different source, e.g., say a block of text etc.
 *
 * @param on_behalf_of The address that has allegedly authorized the current call
 * @param inner_hash The hash of the message to authorize
 */
pub fn assert_inner_hash_valid_authwit(
    context: &mut PrivateContext,
    on_behalf_of: AztecAddress,
    inner_hash: Field,
) {
    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.
    let result: Field = context
        .static_call_private_function(
            on_behalf_of,
            comptime { FunctionSelector::from_signature("verify_private_authwit(Field)") },
            [inner_hash],
        )
        .get_preimage();
    assert(result == IS_VALID_SELECTOR, "Message not authorized by account");
    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.
    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.
    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);
    context.push_nullifier(nullifier);
}

/**
 * Assert that \`on_behalf_of\` has authorized the current call in the authentication registry
 *
 * Compute the \`inner_hash\` using the \`msg_sender\`, \`selector\` and \`args_hash\` and then make a call out to the
 * \`on_behalf_of\` contract to verify that the \`inner_hash\` is valid.
 *
 * Note that the authentication registry will take the \`msg_sender\` into account as the consumer, so this will only
 * work if the \`msg_sender\` is the same as the \`consumer\` when the \`message_hash\` was inserted into the registry.
 *
 * @param on_behalf_of The address that has allegedly authorized the current call
 */
// docs:start:assert_current_call_valid_authwit_public
pub unconstrained fn assert_current_call_valid_authwit_public(
    context: &mut PublicContext,
    on_behalf_of: AztecAddress,
) {
    let inner_hash = compute_inner_authwit_hash([
        (*context).msg_sender().to_field(),
        (*context).selector().to_field(),
        (*context).get_args_hash(),
    ]);
    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);
}
// docs:end:assert_current_call_valid_authwit_public

/**
 * Assert that \`on_behalf_of\` has authorized a specific \`inner_hash\` in the authentication registry
 *
 * Compute the \`inner_hash\` using the \`msg_sender\`, \`selector\` and \`args_hash\` and then make a call out to the
 * \`on_behalf_of\` contract to verify that the \`inner_hash\` is valid.
 *
 * Note that the authentication registry will take the \`msg_sender\` into account as the consumer, so this will only
 * work if the \`msg_sender\` is the same as the \`consumer\` when the \`message_hash\` was inserted into the registry.
 *
 * @param on_behalf_of The address that has allegedly authorized the \`inner_hash\`
 */
pub unconstrained fn assert_inner_hash_valid_authwit_public(
    context: &mut PublicContext,
    on_behalf_of: AztecAddress,
    inner_hash: Field,
) {
    let results: [Field] = context.call_public_function(
        CANONICAL_AUTH_REGISTRY_ADDRESS,
        comptime { FunctionSelector::from_signature("consume((Field),Field)") },
        [on_behalf_of.to_field(), inner_hash].as_slice(),
        GasOpts::default(),
    );
    assert(results.len() == 1, "Invalid response from registry");
    assert(results[0] == IS_VALID_SELECTOR, "Message not authorized by account");
}

/**
 * Compute the \`message_hash\` from a function call to be used by an authentication witness
 *
 * Useful for when you need a non-account contract to approve during execution. For example if you need a contract
 * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow
 * B to transfer T on its behalf.
 *
 * @param caller The address of the contract that is calling the function, in the example above, this would be B
 * @param consumer The address of the contract that is consuming the message, in the example above, this would be T
 * @param chain_id The chain id of the chain that the message is being consumed on
 * @param version The version of the chain that the message is being consumed on
 * @param selector The function selector of the function that is being called
 * @param args The arguments of the function that is being called
 */
// docs:start:compute_authwit_message_hash_from_call
pub fn compute_authwit_message_hash_from_call<let N: u32>(
    caller: AztecAddress,
    consumer: AztecAddress,
    chain_id: Field,
    version: Field,
    selector: FunctionSelector,
    args: [Field; N],
) -> Field {
    let args_hash = hash_args_array(args);
    let inner_hash =
        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);
    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)
}
// docs:end:compute_authwit_message_hash_from_call

/**
 * Computes the \`inner_hash\` of the authentication witness
 *
 * This is used internally, but also useful in cases where you want to compute the \`inner_hash\` for a specific message
 * that is not necessarily a call, but just some "bytes" or text.
 *
 * @param args The arguments to hash
 */
pub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {
    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)
}

/**
 * Computes the \`authwit_nullifier\` for a specific \`on_behalf_of\` and \`inner_hash\`
 *
 * Using the \`on_behalf_of\` and the \`inner_hash\` to ensure that the nullifier is siloed for a specific \`on_behalf_of\`.
 *
 * @param on_behalf_of The address that has authorized the \`inner_hash\`
 * @param inner_hash The hash of the message to authorize
 */
pub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {
    poseidon2_hash_with_separator(
        [on_behalf_of.to_field(), inner_hash],
        GENERATOR_INDEX__AUTHWIT_NULLIFIER,
    )
}

/**
 * Computes the \`message_hash\` for the authentication witness
 *
 * @param consumer The address of the contract that is consuming the message
 * @param chain_id The chain id of the chain that the message is being consumed on
 * @param version The version of the chain that the message is being consumed on
 * @param inner_hash The hash of the "inner" message that is being consumed
 */
pub fn compute_authwit_message_hash(
    consumer: AztecAddress,
    chain_id: Field,
    version: Field,
    inner_hash: Field,
) -> Field {
    poseidon2_hash_with_separator(
        [consumer.to_field(), chain_id, version, inner_hash],
        GENERATOR_INDEX__AUTHWIT_OUTER,
    )
}

/**
 * Helper function to set the authorization status of a message hash
 *
 * Wraps a public call to the authentication registry to set the authorization status of a \`message_hash\`
 *
 * @param message_hash The hash of the message to authorize
 * @param authorize True if the message should be authorized, false if it should be revoked
 */
pub unconstrained fn set_authorized(
    context: &mut PublicContext,
    message_hash: Field,
    authorize: bool,
) {
    let res = context.call_public_function(
        CANONICAL_AUTH_REGISTRY_ADDRESS,
        comptime { FunctionSelector::from_signature("set_authorized(Field,bool)") },
        [message_hash, authorize as Field].as_slice(),
        GasOpts::default(),
    );
    assert(res.len() == 0);
}

/**
 * Helper function to reject all authwits
 *
 * Wraps a public call to the authentication registry to set the \`reject_all\` flag
 *
 * @param reject True if all authwits should be rejected, false otherwise
 */
pub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {
    let res = context.call_public_function(
        CANONICAL_AUTH_REGISTRY_ADDRESS,
        comptime { FunctionSelector::from_signature("set_reject_all(bool)") },
        [context.this_address().to_field(), reject as Field].as_slice(),
        GasOpts::default(),
    );
    assert(res.len() == 0);
}
`},61:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",source:`use dep::protocol_types::{
    abis::function_selector::FunctionSelector,
    address::AztecAddress,
    traits::{Deserialize, ToField},
};

use crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};

use crate::hash::{hash_args, hash_calldata};
use crate::oracle::execution_cache;

pub trait CallInterface<let N: u32> {
    fn get_args(self) -> [Field];
    fn get_selector(self) -> FunctionSelector;
    fn get_name(self) -> str<N>;
    fn get_contract_address(self) -> AztecAddress;
    fn get_is_static(self) -> bool;
}

// PrivateCallInterface

pub struct PrivateCallInterface<let N: u32, T> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args_hash: Field,
    args: [Field],
    return_type: T,
    is_static: bool,
}

impl<let N: u32, T> PrivateCallInterface<N, T> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
        is_static: bool,
    ) -> Self {
        let args_hash = hash_args(args);
        Self {
            target_contract,
            selector,
            name,
            args_hash,
            args,
            return_type: std::mem::zeroed(),
            is_static,
        }
    }

    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T
    where
        T: Deserialize<M>,
    {
        execution_cache::store(self.args, self.args_hash);
        let returns_hash = context.call_private_function_with_args_hash(
            self.target_contract,
            self.selector,
            self.args_hash,
            false,
        );
        let returns: T = returns_hash.get_preimage();
        returns
    }

    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T
    where
        T: Deserialize<M>,
    {
        execution_cache::store(self.args, self.args_hash);
        let returns_hash = context.call_private_function_with_args_hash(
            self.target_contract,
            self.selector,
            self.args_hash,
            true,
        );
        returns_hash.get_preimage()
    }
}

impl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {
    fn get_args(self) -> [Field] {
        self.args
    }

    fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    fn get_name(self) -> str<N> {
        self.name
    }

    fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }

    fn get_is_static(self) -> bool {
        self.is_static
    }
}

// PrivateVoidCallInterface

pub struct PrivateVoidCallInterface<let N: u32> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args_hash: Field,
    args: [Field],
    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)
    is_static: bool,
}

impl<let N: u32> PrivateVoidCallInterface<N> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
        is_static: bool,
    ) -> Self {
        let args_hash = hash_args(args);
        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }
    }

    pub fn call(self, context: &mut PrivateContext) {
        execution_cache::store(self.args, self.args_hash);
        context
            .call_private_function_with_args_hash(
                self.target_contract,
                self.selector,
                self.args_hash,
                false,
            )
            .assert_empty();
    }

    pub fn view(self, context: &mut PrivateContext) {
        execution_cache::store(self.args, self.args_hash);
        context
            .call_private_function_with_args_hash(
                self.target_contract,
                self.selector,
                self.args_hash,
                true,
            )
            .assert_empty();
    }
}

impl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {
    fn get_args(self) -> [Field] {
        self.args
    }

    fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    fn get_name(self) -> str<N> {
        self.name
    }

    fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }

    fn get_is_static(self) -> bool {
        self.is_static
    }
}

// PrivateStaticCallInterface

pub struct PrivateStaticCallInterface<let N: u32, T> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args_hash: Field,
    args: [Field],
    return_type: T,
    is_static: bool,
}

impl<let N: u32, T> PrivateStaticCallInterface<N, T> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
    ) -> Self {
        let args_hash = hash_args(args);
        Self {
            target_contract,
            selector,
            name,
            args_hash,
            args,
            return_type: std::mem::zeroed(),
            is_static: true,
        }
    }

    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T
    where
        T: Deserialize<M>,
    {
        execution_cache::store(self.args, self.args_hash);
        let returns = context.call_private_function_with_args_hash(
            self.target_contract,
            self.selector,
            self.args_hash,
            true,
        );
        returns.get_preimage()
    }
}

impl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {
    fn get_args(self) -> [Field] {
        self.args
    }

    fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    fn get_name(self) -> str<N> {
        self.name
    }

    fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }

    fn get_is_static(self) -> bool {
        self.is_static
    }
}

// PrivateStaticVoidCallInterface

pub struct PrivateStaticVoidCallInterface<let N: u32> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args_hash: Field,
    args: [Field],
    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)
    is_static: bool,
}

impl<let N: u32> PrivateStaticVoidCallInterface<N> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
    ) -> Self {
        let args_hash = hash_args(args);
        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }
    }

    pub fn view(self, context: &mut PrivateContext) {
        execution_cache::store(self.args, self.args_hash);
        context
            .call_private_function_with_args_hash(
                self.target_contract,
                self.selector,
                self.args_hash,
                true,
            )
            .assert_empty();
    }
}

impl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {
    fn get_args(self) -> [Field] {
        self.args
    }

    fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    fn get_name(self) -> str<N> {
        self.name
    }

    fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }

    fn get_is_static(self) -> bool {
        self.is_static
    }
}

// PublicCallInterface

pub struct PublicCallInterface<let N: u32, T> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args: [Field],
    gas_opts: GasOpts,
    return_type: T,
    is_static: bool,
}

impl<let N: u32, T> PublicCallInterface<N, T> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
        is_static: bool,
    ) -> Self {
        Self {
            target_contract,
            selector,
            name,
            args,
            gas_opts: GasOpts::default(),
            return_type: std::mem::zeroed(),
            is_static,
        }
    }

    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {
        self.gas_opts = gas_opts;
        self
    }

    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T
    where
        T: Deserialize<M>,
    {
        let returns = context.call_public_function(
            self.target_contract,
            self.selector,
            self.args,
            self.gas_opts,
        );
        Deserialize::deserialize(returns.as_array::<M>())
    }

    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T
    where
        T: Deserialize<M>,
    {
        let returns = context.static_call_public_function(
            self.target_contract,
            self.selector,
            self.args,
            self.gas_opts,
        );
        Deserialize::deserialize(returns.as_array::<M>())
    }

    pub fn enqueue(self, context: &mut PrivateContext) {
        let calldata = self.args.push_front(self.selector.to_field());
        let calldata_hash = hash_calldata(calldata);
        execution_cache::store(calldata, calldata_hash);
        context.call_public_function_with_calldata_hash(
            self.target_contract,
            calldata_hash,
            /*static=*/
            false,
        )
    }

    pub fn enqueue_view(self, context: &mut PrivateContext) {
        let calldata = self.args.push_front(self.selector.to_field());
        let calldata_hash = hash_calldata(calldata);
        execution_cache::store(calldata, calldata_hash);
        context.call_public_function_with_calldata_hash(
            self.target_contract,
            calldata_hash,
            /*static=*/
            true,
        )
    }
}

impl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {
    fn get_args(self) -> [Field] {
        self.args
    }

    fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    fn get_name(self) -> str<N> {
        self.name
    }

    fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }

    fn get_is_static(self) -> bool {
        self.is_static
    }
}

// PublicVoidCallInterface

pub struct PublicVoidCallInterface<let N: u32> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args: [Field],
    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)
    is_static: bool,
    gas_opts: GasOpts,
}

impl<let N: u32> PublicVoidCallInterface<N> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
        is_static: bool,
    ) -> Self {
        Self {
            target_contract,
            selector,
            name,
            args,
            return_type: (),
            is_static,
            gas_opts: GasOpts::default(),
        }
    }

    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {
        self.gas_opts = gas_opts;
        self
    }

    pub unconstrained fn call(self, context: &mut PublicContext) {
        let returns = context.call_public_function(
            self.target_contract,
            self.selector,
            self.args,
            self.gas_opts,
        );
        assert(returns.len() == 0);
    }

    pub unconstrained fn view(self, context: &mut PublicContext) {
        let returns = context.static_call_public_function(
            self.target_contract,
            self.selector,
            self.args,
            self.gas_opts,
        );
        assert(returns.len() == 0);
    }

    pub fn enqueue(self, context: &mut PrivateContext) {
        let calldata = self.args.push_front(self.selector.to_field());
        let calldata_hash = hash_calldata(calldata);
        execution_cache::store(calldata, calldata_hash);
        context.call_public_function_with_calldata_hash(
            self.target_contract,
            calldata_hash,
            /*static=*/
            false,
        )
    }

    pub fn enqueue_view(self, context: &mut PrivateContext) {
        let calldata = self.args.push_front(self.selector.to_field());
        let calldata_hash = hash_calldata(calldata);
        execution_cache::store(calldata, calldata_hash);
        context.call_public_function_with_calldata_hash(
            self.target_contract,
            calldata_hash,
            /*static=*/
            true,
        )
    }

    pub fn set_as_teardown(self, context: &mut PrivateContext) {
        let calldata = self.args.push_front(self.selector.to_field());
        let calldata_hash = hash_calldata(calldata);
        execution_cache::store(calldata, calldata_hash);
        context.set_public_teardown_function_with_calldata_hash(
            self.target_contract,
            calldata_hash,
            false,
        )
    }
}

impl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {
    fn get_args(self) -> [Field] {
        self.args
    }

    fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    fn get_name(self) -> str<N> {
        self.name
    }

    fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }

    fn get_is_static(self) -> bool {
        self.is_static
    }
}

// PublicStaticCallInterface

pub struct PublicStaticCallInterface<let N: u32, T> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args: [Field],
    return_type: T,
    is_static: bool,
    gas_opts: GasOpts,
}

impl<let N: u32, T> PublicStaticCallInterface<N, T> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
    ) -> Self {
        Self {
            target_contract,
            selector,
            name,
            args,
            return_type: std::mem::zeroed(),
            is_static: true,
            gas_opts: GasOpts::default(),
        }
    }

    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {
        self.gas_opts = gas_opts;
        self
    }

    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T
    where
        T: Deserialize<M>,
    {
        let returns = context.static_call_public_function(
            self.target_contract,
            self.selector,
            self.args,
            self.gas_opts,
        );
        Deserialize::deserialize(returns.as_array::<M>())
    }

    pub fn enqueue_view(self, context: &mut PrivateContext) {
        let calldata = self.args.push_front(self.selector.to_field());
        let calldata_hash = hash_calldata(calldata);
        execution_cache::store(calldata, calldata_hash);
        context.call_public_function_with_calldata_hash(
            self.target_contract,
            calldata_hash,
            /*static=*/
            true,
        )
    }
}

impl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {
    fn get_args(self) -> [Field] {
        self.args
    }

    fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    fn get_name(self) -> str<N> {
        self.name
    }

    fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }

    fn get_is_static(self) -> bool {
        self.is_static
    }
}

// PublicStaticVoidCallInterface

pub struct PublicStaticVoidCallInterface<let N: u32> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args: [Field],
    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)
    is_static: bool,
    gas_opts: GasOpts,
}

impl<let N: u32> PublicStaticVoidCallInterface<N> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
    ) -> Self {
        Self {
            target_contract,
            selector,
            name,
            args,
            return_type: (),
            is_static: true,
            gas_opts: GasOpts::default(),
        }
    }

    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {
        self.gas_opts = gas_opts;
        self
    }

    pub unconstrained fn view(self, context: &mut PublicContext) {
        let returns = context.static_call_public_function(
            self.target_contract,
            self.selector,
            self.args,
            self.gas_opts,
        );
        assert(returns.len() == 0);
    }

    pub fn enqueue_view(self, context: &mut PrivateContext) {
        let calldata = self.args.push_front(self.selector.to_field());
        let calldata_hash = hash_calldata(calldata);
        execution_cache::store(calldata, calldata_hash);
        context.call_public_function_with_calldata_hash(
            self.target_contract,
            calldata_hash,
            /*static=*/
            true,
        )
    }
}

impl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {
    fn get_args(self) -> [Field] {
        self.args
    }

    fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    fn get_name(self) -> str<N> {
        self.name
    }

    fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }

    fn get_is_static(self) -> bool {
        self.is_static
    }
}

// UtilityCallInterface

pub struct UtilityCallInterface<let N: u32, T> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args_hash: Field,
    args: [Field],
    return_type: T,
}

impl<let N: u32, T> UtilityCallInterface<N, T> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
    ) -> Self {
        let args_hash = hash_args(args);
        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }
    }

    pub fn get_args(self) -> [Field] {
        self.args
    }

    pub fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    pub fn get_name(self) -> str<N> {
        self.name
    }

    pub fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }
}

// UtilityVoidCallInterface

pub struct UtilityVoidCallInterface<let N: u32> {
    target_contract: AztecAddress,
    selector: FunctionSelector,
    name: str<N>,
    args_hash: Field,
    args: [Field],
    return_type: (),
}

impl<let N: u32> UtilityVoidCallInterface<N> {
    pub fn new(
        target_contract: AztecAddress,
        selector: FunctionSelector,
        name: str<N>,
        args: [Field],
    ) -> Self {
        let args_hash = hash_args(args);
        Self { target_contract, selector, name, args_hash, args, return_type: () }
    }

    pub fn get_args(self) -> [Field] {
        self.args
    }

    pub fn get_selector(self) -> FunctionSelector {
        self.selector
    }

    pub fn get_name(self) -> str<N> {
        self.name
    }

    pub fn get_contract_address(self) -> AztecAddress {
        self.target_contract
    }
}
`},68:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",source:`use crate::{
    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},
    hash::{ArgsHasher, hash_args_array, hash_calldata_array},
    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},
    messaging::process_l1_to_l2_message,
    oracle::{
        block_header::get_block_header_at,
        call_private_function::call_private_function_internal,
        enqueue_public_function_call::{
            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,
            notify_set_public_teardown_function_call,
        },
        execution_cache,
        key_validation_request::get_key_validation_request,
        notes::{notify_created_nullifier, notify_nullified_note},
    },
};
use dep::protocol_types::{
    abis::{
        call_context::CallContext,
        function_selector::FunctionSelector,
        gas_settings::GasSettings,
        log_hash::LogHash,
        max_block_number::MaxBlockNumber,
        note_hash::NoteHash,
        nullifier::Nullifier,
        private_call_request::PrivateCallRequest,
        private_circuit_public_inputs::PrivateCircuitPublicInputs,
        private_log::{PrivateLog, PrivateLogData},
        public_call_request::PublicCallRequest,
        read_request::ReadRequest,
        side_effect::Counted,
        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},
    },
    address::{AztecAddress, EthAddress},
    block_header::BlockHeader,
    constants::{
        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,
        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,
        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,
        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,
        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,
        PRIVATE_LOG_SIZE_IN_FIELDS,
    },
    messaging::l2_to_l1_message::L2ToL1Message,
    traits::{Empty, Hash, ToField},
    utils::arrays::array_concat,
};

// When finished, one can call .finish() to convert back to the abi
pub struct PrivateContext {
    // docs:start:private-context
    pub inputs: PrivateContextInputs,
    pub side_effect_counter: u32,

    pub min_revertible_side_effect_counter: u32,
    pub is_fee_payer: bool,

    pub args_hash: Field,
    pub return_hash: Field,

    pub max_block_number: MaxBlockNumber,

    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,
    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,
    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,

    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,
    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,

    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,
    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,
    pub public_teardown_call_request: PublicCallRequest,
    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,
    // docs:end:private-context

    // Header of a block whose state is used during private execution (not the block the transaction is included in).
    pub historical_header: BlockHeader,

    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,
    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,

    // Contains the last key validation request for each key type. This is used to cache the last request and avoid
    // fetching the same request multiple times.
    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).
    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],
}

impl PrivateContext {
    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {
        PrivateContext {
            inputs,
            side_effect_counter: inputs.start_side_effect_counter + 1,
            min_revertible_side_effect_counter: 0,
            is_fee_payer: false,
            args_hash,
            return_hash: 0,
            max_block_number: MaxBlockNumber::empty(),
            note_hash_read_requests: BoundedVec::new(),
            nullifier_read_requests: BoundedVec::new(),
            key_validation_requests_and_generators: BoundedVec::new(),
            note_hashes: BoundedVec::new(),
            nullifiers: BoundedVec::new(),
            historical_header: inputs.historical_header,
            private_call_requests: BoundedVec::new(),
            public_call_requests: BoundedVec::new(),
            public_teardown_call_request: PublicCallRequest::empty(),
            l2_to_l1_msgs: BoundedVec::new(),
            private_logs: BoundedVec::new(),
            contract_class_logs_hashes: BoundedVec::new(),
            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],
        }
    }

    pub fn msg_sender(self) -> AztecAddress {
        self.inputs.call_context.msg_sender
    }

    pub fn this_address(self) -> AztecAddress {
        self.inputs.call_context.contract_address
    }

    pub fn chain_id(self) -> Field {
        self.inputs.tx_context.chain_id
    }

    pub fn version(self) -> Field {
        self.inputs.tx_context.version
    }

    pub fn gas_settings(self) -> GasSettings {
        self.inputs.tx_context.gas_settings
    }

    pub fn selector(self) -> FunctionSelector {
        self.inputs.call_context.function_selector
    }

    pub fn get_args_hash(self) -> Field {
        self.args_hash
    }

    pub fn push_note_hash(&mut self, note_hash: Field) {
        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });
    }

    pub fn push_nullifier(&mut self, nullifier: Field) {
        notify_created_nullifier(nullifier);
        self.nullifiers.push(
            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },
        );
    }

    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {
        let nullifier_counter = self.next_counter();
        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);
        self.nullifiers.push(
            Nullifier {
                value: nullifier,
                note_hash: nullified_note_hash,
                counter: nullifier_counter,
            },
        );
    }

    // Returns the header of a block whose state is used during private execution (not the block the transaction is
    // included in).
    pub fn get_block_header(self) -> BlockHeader {
        self.historical_header
    }

    // Returns the header of an arbitrary block whose block number is less than or equal to the block number
    // of historical header.
    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {
        get_block_header_at(block_number, self)
    }

    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {
        self.return_hash = returns_hasher.hash();
        execution_cache::store(returns_hasher.fields, self.return_hash);
    }

    pub fn finish(self) -> PrivateCircuitPublicInputs {
        PrivateCircuitPublicInputs {
            call_context: self.inputs.call_context,
            args_hash: self.args_hash,
            returns_hash: self.return_hash,
            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,
            is_fee_payer: self.is_fee_payer,
            max_block_number: self.max_block_number,
            note_hash_read_requests: self.note_hash_read_requests.storage(),
            nullifier_read_requests: self.nullifier_read_requests.storage(),
            key_validation_requests_and_generators: self
                .key_validation_requests_and_generators
                .storage(),
            note_hashes: self.note_hashes.storage(),
            nullifiers: self.nullifiers.storage(),
            private_call_requests: self.private_call_requests.storage(),
            public_call_requests: self.public_call_requests.storage(),
            public_teardown_call_request: self.public_teardown_call_request,
            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),
            start_side_effect_counter: self.inputs.start_side_effect_counter,
            end_side_effect_counter: self.side_effect_counter,
            private_logs: self.private_logs.storage(),
            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),
            historical_header: self.historical_header,
            tx_context: self.inputs.tx_context,
        }
    }

    pub fn set_as_fee_payer(&mut self) {
        dep::protocol_types::debug_log::debug_log_format(
            "Setting {0} as fee payer",
            [self.this_address().to_field()],
        );
        self.is_fee_payer = true;
    }

    pub fn end_setup(&mut self) {
        // dep::protocol_types::debug_log::debug_log_format(
        //     "Ending setup at counter {0}",
        //     [self.side_effect_counter as Field]
        // );
        self.min_revertible_side_effect_counter = self.side_effect_counter;
        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);
    }

    // docs:start:max-block-number
    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {
        // docs:end:max-block-number
        self.max_block_number =
            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);
    }

    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {
        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };
        self.note_hash_read_requests.push(side_effect);
    }

    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {
        let request = ReadRequest { value: nullifier, counter: self.next_counter() };
        self.nullifier_read_requests.push(request);
    }

    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {
        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)
    }

    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {
        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)
    }

    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {
        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(
            KeyValidationRequest::empty(),
        );

        if cached_request.pk_m.hash() == pk_m_hash {
            // We get a match so the cached request is the latest one
            cached_request.sk_app
        } else {
            // We didn't get a match meaning the cached result is stale
            // Typically we'd validate keys by showing that they are the preimage of \`pk_m_hash\`, but that'd require
            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn
            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to
            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes
            // to \`pk_m_hash\`.

            // Safety: Kernels verify that the key validation request is valid and below we verify that a request
            // for the correct public key has been received.
            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };
            assert_eq(request.pk_m.hash(), pk_m_hash, "Obtained invalid key validation request");

            self.key_validation_requests_and_generators.push(
                KeyValidationRequestAndGenerator {
                    request,
                    sk_app_generator: sk_generators[key_index as u32],
                },
            );
            self.last_key_validation_requests[key_index as u32] = Option::some(request);
            request.sk_app
        }
    }

    // docs:start:context_message_portal
    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {
        // docs:end:context_message_portal
        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };
        self.l2_to_l1_msgs.push(message);
    }

    // docs:start:context_consume_l1_to_l2_message
    // docs:start:consume_l1_to_l2_message
    pub fn consume_l1_to_l2_message(
        &mut self,
        content: Field,
        secret: Field,
        sender: EthAddress,
        leaf_index: Field,
    ) {
        // docs:end:context_consume_l1_to_l2_message
        let nullifier = process_l1_to_l2_message(
            self.historical_header.state.l1_to_l2_message_tree.root,
            self.this_address(),
            sender,
            self.chain_id(),
            self.version(),
            content,
            secret,
            leaf_index,
        );

        // Push nullifier (and the "commitment" corresponding to this can be "empty")
        self.push_nullifier(nullifier)
    }
    // docs:end:consume_l1_to_l2_message

    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {
        let counter = self.next_counter();
        let private_log =
            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };
        self.private_logs.push(private_log);
    }

    pub fn emit_raw_note_log(
        &mut self,
        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],
        length: u32,
        note_hash_counter: u32,
    ) {
        let counter = self.next_counter();
        let private_log =
            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };
        self.private_logs.push(private_log);
    }

    pub fn call_private_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) -> ReturnsHash {
        let args_hash = hash_args_array(args);
        execution_cache::store(args, args_hash);
        self.call_private_function_with_args_hash(
            contract_address,
            function_selector,
            args_hash,
            false,
        )
    }

    pub fn static_call_private_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) -> ReturnsHash {
        let args_hash = hash_args_array(args);
        execution_cache::store(args, args_hash);
        self.call_private_function_with_args_hash(
            contract_address,
            function_selector,
            args_hash,
            true,
        )
    }

    pub fn call_private_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) -> ReturnsHash {
        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)
    }

    pub fn static_call_private_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) -> ReturnsHash {
        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)
    }

    pub fn call_private_function_with_args_hash(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args_hash: Field,
        is_static_call: bool,
    ) -> ReturnsHash {
        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;
        let start_side_effect_counter = self.side_effect_counter;

        // Safety: The oracle simulates the private call and returns the value of the side effects counter after
        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is
        // the number of side effects that took place), along with the hash of the return values. We validate these
        // by requesting a private kernel iteration in which the return values are constrained to hash
        // to \`returns_hash\` and the side effects counter to increment from start to end.
        let (end_side_effect_counter, returns_hash) = unsafe {
            call_private_function_internal(
                contract_address,
                function_selector,
                args_hash,
                start_side_effect_counter,
                is_static_call,
            )
        };

        self.private_call_requests.push(
            PrivateCallRequest {
                call_context: CallContext {
                    msg_sender: self.this_address(),
                    contract_address,
                    function_selector,
                    is_static_call,
                },
                args_hash,
                returns_hash,
                start_side_effect_counter,
                end_side_effect_counter,
            },
        );

        // TODO (fees) figure out why this crashes the prover and enable it
        // we need this in order to pay fees inside child call contexts
        // assert(
        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)
        //     | (item.public_inputs.min_revertible_side_effect_counter
        //         > self.min_revertible_side_effect_counter)
        // );
        // if item.public_inputs.min_revertible_side_effect_counter
        //     > self.min_revertible_side_effect_counter {
        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;
        // }
        self.side_effect_counter = end_side_effect_counter + 1;
        ReturnsHash::new(returns_hash)
    }

    pub fn call_public_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn static_call_public_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)
    }

    pub fn call_public_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) {
        let calldata_hash = hash_calldata_array([function_selector.to_field()]);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn static_call_public_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) {
        let calldata_hash = hash_calldata_array([function_selector.to_field()]);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)
    }

    pub fn call_public_function_with_calldata_hash(
        &mut self,
        contract_address: AztecAddress,
        calldata_hash: Field,
        is_static_call: bool,
    ) {
        let counter = self.next_counter();

        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;

        notify_enqueued_public_function_call(
            contract_address,
            calldata_hash,
            counter,
            is_static_call,
        );

        let call_request = PublicCallRequest {
            msg_sender: self.this_address(),
            contract_address,
            is_static_call,
            calldata_hash,
        };

        self.public_call_requests.push(Counted::new(call_request, counter));
    }

    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn set_public_teardown_function_with_calldata_hash(
        &mut self,
        contract_address: AztecAddress,
        calldata_hash: Field,
        is_static_call: bool,
    ) {
        let counter = self.next_counter();

        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;

        notify_set_public_teardown_function_call(
            contract_address,
            calldata_hash,
            counter,
            is_static_call,
        );

        self.public_teardown_call_request = PublicCallRequest {
            msg_sender: self.this_address(),
            contract_address,
            is_static_call,
            calldata_hash,
        };
    }

    fn next_counter(&mut self) -> u32 {
        let counter = self.side_effect_counter;
        self.side_effect_counter += 1;
        counter
    }
}

impl Empty for PrivateContext {
    fn empty() -> Self {
        PrivateContext {
            inputs: PrivateContextInputs::empty(),
            side_effect_counter: 0 as u32,
            min_revertible_side_effect_counter: 0 as u32,
            is_fee_payer: false,
            args_hash: 0,
            return_hash: 0,
            max_block_number: MaxBlockNumber::empty(),
            note_hash_read_requests: BoundedVec::new(),
            nullifier_read_requests: BoundedVec::new(),
            key_validation_requests_and_generators: BoundedVec::new(),
            note_hashes: BoundedVec::new(),
            nullifiers: BoundedVec::new(),
            private_call_requests: BoundedVec::new(),
            public_call_requests: BoundedVec::new(),
            public_teardown_call_request: PublicCallRequest::empty(),
            l2_to_l1_msgs: BoundedVec::new(),
            historical_header: BlockHeader::empty(),
            private_logs: BoundedVec::new(),
            contract_class_logs_hashes: BoundedVec::new(),
            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],
        }
    }
}
`},69:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",source:`use crate::context::gas::GasOpts;
use crate::hash::{
    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,
};
use dep::protocol_types::abis::function_selector::FunctionSelector;
use dep::protocol_types::address::{AztecAddress, EthAddress};
use dep::protocol_types::constants::MAX_FIELD_VALUE;
use dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};

pub struct PublicContext {
    pub args_hash: Option<Field>,
    pub compute_args_hash: fn() -> Field,
}

impl PublicContext {
    pub fn new(compute_args_hash: fn() -> Field) -> Self {
        PublicContext { args_hash: Option::none(), compute_args_hash }
    }

    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)
    where
        T: Serialize<N>,
    {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };
    }

    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe { note_hash_exists(note_hash, leaf_index) } == 1
    }

    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1
    }

    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1
    }

    pub fn consume_l1_to_l2_message(
        &mut self,
        content: Field,
        secret: Field,
        sender: EthAddress,
        leaf_index: Field,
    ) {
        let secret_hash = compute_secret_hash(secret);
        let message_hash = compute_l1_to_l2_message_hash(
            sender,
            self.chain_id(),
            /*recipient=*/
            self.this_address(),
            self.version(),
            content,
            secret_hash,
            leaf_index,
        );
        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);

        assert(
            !self.nullifier_exists(nullifier, self.this_address()),
            "L1-to-L2 message is already nullified",
        );
        assert(
            self.l1_to_l2_msg_exists(message_hash, leaf_index),
            "Tried to consume nonexistent L1-to-L2 message",
        );

        self.push_nullifier(nullifier);
    }

    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe { send_l2_to_l1_msg(recipient, content) };
    }

    pub unconstrained fn call_public_function(
        _self: &mut Self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field],
        gas_opts: GasOpts,
    ) -> [Field] {
        let calldata = args.push_front(function_selector.to_field());

        call(
            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),
            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),
            contract_address,
            calldata,
        );
        // Use success_copy to determine whether the call succeeded
        let success = success_copy();

        let result_data = returndata_copy(0, returndata_size());
        if !success {
            // Rethrow the revert data.
            avm_revert(result_data);
        }
        result_data
    }

    pub unconstrained fn static_call_public_function(
        _self: &mut Self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field],
        gas_opts: GasOpts,
    ) -> [Field] {
        let calldata = args.push_front(function_selector.to_field());

        call_static(
            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),
            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),
            contract_address,
            calldata,
        );
        // Use success_copy to determine whether the call succeeded
        let success = success_copy();

        let result_data = returndata_copy(0, returndata_size());
        if !success {
            // Rethrow the revert data.
            avm_revert(result_data);
        }
        result_data
    }

    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe { emit_note_hash(note_hash) };
    }
    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe { emit_nullifier(nullifier) };
    }

    pub fn this_address(_self: Self) -> AztecAddress {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            address()
        }
    }
    pub fn msg_sender(_self: Self) -> AztecAddress {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            sender()
        }
    }
    pub fn selector(_self: Self) -> FunctionSelector {
        // The selector is the first element of the calldata when calling a public function through dispatch.
        // Safety: AVM opcodes are constrained by the AVM itself
        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };
        FunctionSelector::from_field(raw_selector[0])
    }
    pub fn get_args_hash(mut self) -> Field {
        if !self.args_hash.is_some() {
            self.args_hash = Option::some((self.compute_args_hash)());
        }

        self.args_hash.unwrap_unchecked()
    }
    pub fn transaction_fee(_self: Self) -> Field {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            transaction_fee()
        }
    }

    pub fn chain_id(_self: Self) -> Field {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            chain_id()
        }
    }
    pub fn version(_self: Self) -> Field {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            version()
        }
    }
    pub fn block_number(_self: Self) -> Field {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            block_number()
        }
    }
    pub fn timestamp(_self: Self) -> u64 {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            timestamp()
        }
    }
    pub fn fee_per_l2_gas(_self: Self) -> Field {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            fee_per_l2_gas()
        }
    }
    pub fn fee_per_da_gas(_self: Self) -> Field {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            fee_per_da_gas()
        }
    }

    pub fn l2_gas_left(_self: Self) -> Field {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            l2_gas_left()
        }
    }
    pub fn da_gas_left(_self: Self) -> Field {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe {
            da_gas_left()
        }
    }
    pub fn is_static_call(_self: Self) -> bool {
        // Safety: AVM opcodes are constrained by the AVM itself
        unsafe { is_static_call() } == 1
    }

    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {
        let mut out = [0; N];
        for i in 0..N {
            // Safety: AVM opcodes are constrained by the AVM itself
            out[i] = unsafe { storage_read(storage_slot + i as Field) };
        }
        out
    }

    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T
    where
        T: Packable<N>,
    {
        T::unpack(self.raw_storage_read(storage_slot))
    }

    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {
        for i in 0..N {
            // Safety: AVM opcodes are constrained by the AVM itself
            unsafe { storage_write(storage_slot + i as Field, values[i]) };
        }
    }

    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)
    where
        T: Packable<N>,
    {
        self.raw_storage_write(storage_slot, value.pack());
    }
}

// Unconstrained opcode wrappers (do not use directly).
unconstrained fn address() -> AztecAddress {
    address_opcode()
}
unconstrained fn sender() -> AztecAddress {
    sender_opcode()
}
unconstrained fn transaction_fee() -> Field {
    transaction_fee_opcode()
}
unconstrained fn chain_id() -> Field {
    chain_id_opcode()
}
unconstrained fn version() -> Field {
    version_opcode()
}
unconstrained fn block_number() -> Field {
    block_number_opcode()
}
unconstrained fn timestamp() -> u64 {
    timestamp_opcode()
}
unconstrained fn fee_per_l2_gas() -> Field {
    fee_per_l2_gas_opcode()
}
unconstrained fn fee_per_da_gas() -> Field {
    fee_per_da_gas_opcode()
}
unconstrained fn l2_gas_left() -> Field {
    l2_gas_left_opcode()
}
unconstrained fn da_gas_left() -> Field {
    da_gas_left_opcode()
}
unconstrained fn is_static_call() -> Field {
    is_static_call_opcode()
}
unconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {
    note_hash_exists_opcode(note_hash, leaf_index)
}
unconstrained fn emit_note_hash(note_hash: Field) {
    emit_note_hash_opcode(note_hash)
}
unconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {
    nullifier_exists_opcode(nullifier, address)
}
unconstrained fn emit_nullifier(nullifier: Field) {
    emit_nullifier_opcode(nullifier)
}
unconstrained fn emit_public_log(message: [Field]) {
    emit_public_log_opcode(message)
}
unconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {
    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)
}
unconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {
    send_l2_to_l1_msg_opcode(recipient, content)
}
unconstrained fn call(
    l2_gas_allocation: Field,
    da_gas_allocation: Field,
    address: AztecAddress,
    args: [Field],
) {
    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)
}

unconstrained fn call_static(
    l2_gas_allocation: Field,
    da_gas_allocation: Field,
    address: AztecAddress,
    args: [Field],
) {
    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)
}

pub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {
    calldata_copy_opcode(cdoffset, copy_size)
}

// \`success_copy\` is placed immediately after the CALL opcode to get the success value
unconstrained fn success_copy() -> bool {
    success_copy_opcode()
}

unconstrained fn returndata_size() -> u32 {
    returndata_size_opcode()
}

unconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {
    returndata_copy_opcode(rdoffset, copy_size)
}

pub unconstrained fn avm_return(returndata: [Field]) {
    return_opcode(returndata)
}

// This opcode reverts using the exact data given. In general it should only be used
// to do rethrows, where the revert data is the same as the original revert data.
// For normal reverts, use Noir's \`assert\` which, on top of reverting, will also add
// an error selector to the revert data.
unconstrained fn avm_revert(revertdata: [Field]) {
    revert_opcode(revertdata)
}

unconstrained fn storage_read(storage_slot: Field) -> Field {
    storage_read_opcode(storage_slot)
}

unconstrained fn storage_write(storage_slot: Field, value: Field) {
    storage_write_opcode(storage_slot, value);
}

impl Empty for PublicContext {
    fn empty() -> Self {
        PublicContext::new(|| 0)
    }
}

// AVM oracles (opcodes) follow, do not use directly.
#[oracle(avmOpcodeAddress)]
unconstrained fn address_opcode() -> AztecAddress {}

#[oracle(avmOpcodeSender)]
unconstrained fn sender_opcode() -> AztecAddress {}

#[oracle(avmOpcodeTransactionFee)]
unconstrained fn transaction_fee_opcode() -> Field {}

#[oracle(avmOpcodeChainId)]
unconstrained fn chain_id_opcode() -> Field {}

#[oracle(avmOpcodeVersion)]
unconstrained fn version_opcode() -> Field {}

#[oracle(avmOpcodeBlockNumber)]
unconstrained fn block_number_opcode() -> Field {}

#[oracle(avmOpcodeTimestamp)]
unconstrained fn timestamp_opcode() -> u64 {}

#[oracle(avmOpcodeFeePerL2Gas)]
unconstrained fn fee_per_l2_gas_opcode() -> Field {}

#[oracle(avmOpcodeFeePerDaGas)]
unconstrained fn fee_per_da_gas_opcode() -> Field {}

#[oracle(avmOpcodeL2GasLeft)]
unconstrained fn l2_gas_left_opcode() -> Field {}

#[oracle(avmOpcodeDaGasLeft)]
unconstrained fn da_gas_left_opcode() -> Field {}

#[oracle(avmOpcodeIsStaticCall)]
unconstrained fn is_static_call_opcode() -> Field {}

#[oracle(avmOpcodeNoteHashExists)]
unconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}

#[oracle(avmOpcodeEmitNoteHash)]
unconstrained fn emit_note_hash_opcode(note_hash: Field) {}

#[oracle(avmOpcodeNullifierExists)]
unconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}

#[oracle(avmOpcodeEmitNullifier)]
unconstrained fn emit_nullifier_opcode(nullifier: Field) {}

// TODO(#11124): rename unencrypted to public in avm
#[oracle(avmOpcodeEmitUnencryptedLog)]
unconstrained fn emit_public_log_opcode(message: [Field]) {}

#[oracle(avmOpcodeL1ToL2MsgExists)]
unconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}

#[oracle(avmOpcodeSendL2ToL1Msg)]
unconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}

#[oracle(avmOpcodeCalldataCopy)]
unconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}

#[oracle(avmOpcodeReturndataSize)]
unconstrained fn returndata_size_opcode() -> u32 {}

#[oracle(avmOpcodeReturndataCopy)]
unconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}

#[oracle(avmOpcodeReturn)]
unconstrained fn return_opcode(returndata: [Field]) {}

// This opcode reverts using the exact data given. In general it should only be used
// to do rethrows, where the revert data is the same as the original revert data.
// For normal reverts, use Noir's \`assert\` which, on top of reverting, will also add
// an error selector to the revert data.
#[oracle(avmOpcodeRevert)]
unconstrained fn revert_opcode(revertdata: [Field]) {}

#[oracle(avmOpcodeCall)]
unconstrained fn call_opcode(
    l2_gas_allocation: Field,
    da_gas_allocation: Field,
    address: AztecAddress,
    args: [Field],
) {}

#[oracle(avmOpcodeStaticCall)]
unconstrained fn call_static_opcode(
    l2_gas_allocation: Field,
    da_gas_allocation: Field,
    address: AztecAddress,
    args: [Field],
) {}

#[oracle(avmOpcodeSuccessCopy)]
unconstrained fn success_copy_opcode() -> bool {}

#[oracle(avmOpcodeStorageRead)]
unconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}

#[oracle(avmOpcodeStorageWrite)]
unconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}
`},70:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",source:`use crate::{hash::hash_args_array, oracle::execution_cache};
use dep::protocol_types::traits::Deserialize;

pub struct ReturnsHash {
    hash: Field,
}

impl ReturnsHash {
    pub fn new(hash: Field) -> Self {
        ReturnsHash { hash }
    }

    pub fn assert_empty(self) {
        assert_eq(self.hash, 0);
    }

    pub fn raw(self) -> Field {
        self.hash
    }

    /// This is only used during private execution, since in public it is the VM itself that keeps track of return
    /// values.
    pub fn get_preimage<T, let N: u32>(self) -> T
    where
        T: Deserialize<N>,
    {
        // Safety: We verify that the value returned by \`load\` is the preimage of \`hash\`, fully constraining it.
        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };
        assert_eq(self.hash, hash_args_array(preimage));

        Deserialize::deserialize(preimage)
    }
}
`},71:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",source:`use crate::oracle::{
    execution::{get_block_number, get_chain_id, get_contract_address, get_version},
    storage::storage_read,
};
use dep::protocol_types::{address::AztecAddress, traits::Packable};

pub struct UtilityContext {
    block_number: u32,
    contract_address: AztecAddress,
    version: Field,
    chain_id: Field,
}

impl UtilityContext {
    pub unconstrained fn new() -> Self {
        // We could call these oracles on the getters instead of at creation, which makes sense given that they might
        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user
        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not
        // available.
        let block_number = get_block_number();
        let contract_address = get_contract_address();
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub unconstrained fn at(contract_address: AztecAddress) -> Self {
        let block_number = get_block_number();
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub fn block_number(self) -> u32 {
        self.block_number
    }

    pub fn this_address(self) -> AztecAddress {
        self.contract_address
    }

    pub fn version(self) -> Field {
        self.version
    }

    pub fn chain_id(self) -> Field {
        self.chain_id
    }

    pub unconstrained fn raw_storage_read<let N: u32>(
        self: Self,
        storage_slot: Field,
    ) -> [Field; N] {
        storage_read(self.this_address(), storage_slot, self.block_number())
    }

    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T
    where
        T: Packable<N>,
    {
        T::unpack(self.raw_storage_read(storage_slot))
    }
}
`},75:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",source:`use dep::protocol_types::{
    address::{AztecAddress, EthAddress},
    constants::{
        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,
        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,
    },
    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},
    point::Point,
    traits::{Hash, ToField},
};

pub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};

pub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {
    std::hash::pedersen_commitment_with_separator(inputs, hash_index)
}

pub fn compute_secret_hash(secret: Field) -> Field {
    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)
}

pub fn compute_l1_to_l2_message_hash(
    sender: EthAddress,
    chain_id: Field,
    recipient: AztecAddress,
    version: Field,
    content: Field,
    secret_hash: Field,
    leaf_index: Field,
) -> Field {
    let mut hash_bytes = [0 as u8; 224];
    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();
    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();
    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();
    let version_bytes: [u8; 32] = version.to_be_bytes();
    let content_bytes: [u8; 32] = content.to_be_bytes();
    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();
    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();

    for i in 0..32 {
        hash_bytes[i] = sender_bytes[i];
        hash_bytes[i + 32] = chain_id_bytes[i];
        hash_bytes[i + 64] = recipient_bytes[i];
        hash_bytes[i + 96] = version_bytes[i];
        hash_bytes[i + 128] = content_bytes[i];
        hash_bytes[i + 160] = secret_hash_bytes[i];
        hash_bytes[i + 192] = leaf_index_bytes[i];
    }

    sha256_to_field(hash_bytes)
}

// The nullifier of a l1 to l2 message is the hash of the message salted with the secret
pub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {
    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)
}

pub struct ArgsHasher {
    pub fields: [Field],
}

impl Hash for ArgsHasher {
    fn hash(self) -> Field {
        hash_args(self.fields)
    }
}

impl ArgsHasher {
    pub fn new() -> Self {
        Self { fields: [] }
    }

    pub fn add(&mut self, field: Field) {
        self.fields = self.fields.push_back(field);
    }

    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {
        for i in 0..N {
            self.fields = self.fields.push_back(fields[i]);
        }
    }
}

// Computes the hash of input arguments or return values for private functions, or for authwit creation.
pub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {
    if args.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)
    }
}

// Same as \`hash_args_array\`, but takes a slice instead of an array.
pub fn hash_args(args: [Field]) -> Field {
    if args.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)
    }
}

// Computes the hash of calldata for public functions.
pub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {
    if calldata.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)
    }
}

// Same as \`hash_calldata_array\`, but takes a slice instead of an array.
pub fn hash_calldata(calldata: [Field]) -> Field {
    if calldata.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)
    }
}

#[test]
unconstrained fn compute_var_args_hash() {
    let mut input = ArgsHasher::new();
    for i in 0..100 {
        input.add(i as Field);
    }
    let hash = input.hash();
    dep::std::println(hash);
    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);
}
`},97:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",source:`use super::utils::compute_fn_selector;
use std::panic;

/// Returns an \`fn public_dispatch(...)\` function for the given module that's assumed to be an Aztec contract.
pub comptime fn generate_public_dispatch(m: Module) -> Quoted {
    let functions = m.functions();
    let functions =
        functions.filter(|function: FunctionDefinition| function.has_named_attribute("public"));

    let unit = get_type::<()>();

    let ifs = functions.map(|function: FunctionDefinition| {
        let parameters = function.parameters();
        let return_type = function.return_type();

        let selector: Field = compute_fn_selector(function);

        let mut parameters_size = 0;
        for param in parameters {
            parameters_size += size_in_fields(param.1);
        }

        let initial_read = if parameters.len() == 0 {
            quote {}
        } else {
            // The initial calldata_copy offset is 1 to skip the Field selector
            // The expected calldata is the serialization of
            // - FunctionSelector: the selector of the function intended to dispatch
            // - Parameters: the parameters of the function intended to dispatch
            // That is, exactly what is expected for a call to the target function,
            // but with a selector added at the beginning.
            quote {
                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);
                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);
            }
        };

        let parameter_index = &mut 0;
        let reads = parameters.map(|param: (Quoted, Type)| {
            let parameter_index_value = *parameter_index;
            let param_name = f"arg{parameter_index_value}".quoted_contents();
            let param_type = param.1;
            let read = quote {
                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);
            };
            *parameter_index += 1;
            quote { $read }
        });
        let read = reads.join(quote { });

        let mut args = &[];
        for parameter_index in 0..parameters.len() {
            let param_name = f"arg{parameter_index}".quoted_contents();
            args = args.push_back(quote { $param_name });
        }

        let args = args.join(quote { , });
        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.
        let name = function.name();
        let call = quote { $name($args) };

        let return_code = if return_type == unit {
            quote {
                $call;
                // Force early return.
                dep::aztec::context::public_context::avm_return([]);
            }
        } else {
            quote {
                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);
                dep::aztec::context::public_context::avm_return(return_value.as_slice());
            }
        };

        let if_ = quote {
            if selector == $selector {
                $initial_read
                $read
                $return_code
            }
        };
        if_
    });

    if ifs.len() == 0 {
        // No dispatch function if there are no public functions
        quote {}
    } else {
        let ifs = ifs.push_back(quote { panic(f"Unknown selector {selector}") });
        let dispatch = ifs.join(quote {  });

        let body = quote {
            // We mark this as public because our whole system depends on public
            // functions having this attribute. However, the public MACRO will
            // handle the public_dispatch function specially and do nothing.
            #[public]
            pub unconstrained fn public_dispatch(selector: Field) {
                $dispatch
            }
        };

        body
    }
}

comptime fn size_in_fields(typ: Type) -> u32 {
    let size = array_size_in_fields(typ);
    let size = size.or_else(|| bool_size_in_fields(typ));
    let size = size.or_else(|| constant_size_in_fields(typ));
    let size = size.or_else(|| field_size_in_fields(typ));
    let size = size.or_else(|| int_size_in_fields(typ));
    let size = size.or_else(|| str_size_in_fields(typ));
    let size = size.or_else(|| struct_size_in_fields(typ));
    let size = size.or_else(|| tuple_size_in_fields(typ));
    if size.is_some() {
        size.unwrap()
    } else {
        panic(f"Can't determine size in fields of {typ}")
    }
}

comptime fn array_size_in_fields(typ: Type) -> Option<u32> {
    typ.as_array().and_then(|typ: (Type, Type)| {
        let (typ, element_size) = typ;
        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))
    })
}

comptime fn bool_size_in_fields(typ: Type) -> Option<u32> {
    if typ.is_bool() {
        Option::some(1)
    } else {
        Option::none()
    }
}

comptime fn field_size_in_fields(typ: Type) -> Option<u32> {
    if typ.is_field() {
        Option::some(1)
    } else {
        Option::none()
    }
}

comptime fn int_size_in_fields(typ: Type) -> Option<u32> {
    if typ.as_integer().is_some() {
        Option::some(1)
    } else {
        Option::none()
    }
}

comptime fn constant_size_in_fields(typ: Type) -> Option<u32> {
    typ.as_constant()
}

comptime fn str_size_in_fields(typ: Type) -> Option<u32> {
    typ.as_str().map(|typ| size_in_fields(typ))
}

comptime fn struct_size_in_fields(typ: Type) -> Option<u32> {
    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {
        let struct_type = typ.0;
        let generics = typ.1;
        let mut size = 0;
        for field in struct_type.fields(generics) {
            size += size_in_fields(field.1);
        }
        size
    })
}

comptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {
    typ.as_tuple().map(|types: [Type]| {
        let mut size = 0;
        for typ in types {
            size += size_in_fields(typ);
        }
        size
    })
}

comptime fn get_type<T>() -> Type {
    let t: T = std::mem::zeroed();
    std::meta::type_of(t)
}
`},104:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",source:`use crate::macros::{
    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},
    notes::NOTES,
    utils::{
        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,
        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,
        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,
    },
};
use protocol_types::meta::generate_serialize_to_fields;
use std::meta::type_of;

pub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // If a function is further modified as unconstrained, we throw an error
    if f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword",
        );
    }

    let module_has_initializer = module_has_initializer(f.module());
    let module_has_storage = module_has_storage(f.module());

    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the
    // Private Kernel Circuit.
    // First we change the function signature so that it also receives \`PrivateContextInputs\`, which contain information
    // about the execution context (e.g. the caller).
    let original_params = f.parameters();
    f.set_parameters(&[(
        quote { inputs },
        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),
    )]
        .append(original_params));

    let mut body = f.body().as_block().unwrap();

    // The original params are hashed and passed to the \`context\` object, so that the kernel can verify we've received
    // the correct values.
    // TODO: Optimize args_hasher for small number of arguments
    let args_hasher_name = quote { args_hasher };
    let args_hasher = original_params.fold(
        quote {
            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();
        },
        |args_hasher, param: (Quoted, Type)| {
            let (name, typ) = param;
            let appended_arg = add_to_hasher(args_hasher_name, name, typ);
            quote {
                $args_hasher
                $appended_arg
            }
        },
    );

    let context_creation = quote {
        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));
    };

    // Modifications introduced by the different marker attributes.
    let internal_check = if is_fn_internal(f) {
        create_internal_check(f)
    } else {
        quote {}
    };

    let view_check = if is_fn_view(f) {
        create_view_check(f)
    } else {
        quote {}
    };

    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {
        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))
    } else {
        (quote {}, quote {})
    };

    let storage_init = if module_has_storage {
        quote {
            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
            // referenced. We instead ignore 'unused variable' warnings for it.
            #[allow(unused_variables)]
            let storage = Storage::init(&mut context);
        }
    } else {
        quote {}
    };

    // Initialization checks are not included in contracts that don't have initializers.
    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {
        create_init_check(f)
    } else {
        quote {}
    };

    // All private functions perform message discovery, since they may need to access notes. This is slightly
    // inefficient and could be improved by only doing it once we actually attempt to read any.
    let message_discovery_call = if NOTES.len() > 0 {
        create_message_discovery_call()
    } else {
        quote {}
    };

    // Finally, we need to change the return type to be \`PrivateCircuitPublicInputs\`, which is what the Private Kernel
    // circuit expects.
    let return_value_var_name = quote { macro__returned__values };

    let return_value_type = f.return_type();
    let return_value = if body.len() == 0 {
        quote {}
    } else if return_value_type != type_of(()) {
        // The original return value is passed to a second args hasher which the context receives.
        let (body_without_return, last_body_expr) = body.pop_back();
        let return_value = last_body_expr.quoted();
        let return_value_assignment =
            quote { let $return_value_var_name: $return_value_type = $return_value; };
        let return_hasher_name = quote { return_hasher };
        let return_value_into_hasher =
            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);

        body = body_without_return;

        quote {
            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();
            $return_value_assignment
            $return_value_into_hasher
            context.set_return_hash($return_hasher_name);
        }
    } else {
        let (body_without_return, last_body_expr) = body.pop_back();
        if !last_body_expr.has_semicolon()
            & last_body_expr.as_for().is_none()
            & last_body_expr.as_assert().is_none()
            & last_body_expr.as_for_range().is_none()
            & last_body_expr.as_assert_eq().is_none()
            & last_body_expr.as_let().is_none() {
            let unused_return_value_name = f"_{return_value_var_name}".quoted_contents();
            body = body_without_return.push_back(
                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),
            );
        }
        quote {}
    };

    let context_finish = quote { context.finish() };

    let to_prepend = quote {
        $args_hasher
        $context_creation
        $assert_initializer
        $init_check
        $internal_check
        $view_check
        $storage_init
        $message_discovery_call
    };

    let to_append = quote {
        $return_value
        $mark_as_initialized
        $context_finish
    };
    let modified_body = modify_fn_body(body, to_prepend, to_append);
    f.set_body(modified_body);
    f.set_return_type(
        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }
            .as_type(),
    );
    f.set_return_data();

    fn_abi
}

pub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // If a function is further modified as unconstrained, we throw an error
    if f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword",
        );
    }

    let module_has_initializer = module_has_initializer(f.module());
    let module_has_storage = module_has_storage(f.module());

    // Public functions undergo a lot of transformations from their Aztec.nr form.
    let original_params = f.parameters();
    let args_len = original_params
        .map(|(name, typ): (Quoted, Type)| {
            generate_serialize_to_fields(name, typ, false).0.len()
        })
        .fold(0, |acc: u32, val: u32| acc + val);

    // Unlike in the private case, in public the \`context\` does not need to receive the hash of the original params.
    let context_creation = quote {
        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {
        // We start from 1 because we skip the selector for the dispatch function.
        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);
        dep::aztec::hash::hash_args_array(serialized_args)
        });
    };

    // Modifications introduced by the different marker attributes.
    let internal_check = if is_fn_internal(f) {
        create_internal_check(f)
    } else {
        quote {}
    };

    let view_check = if is_fn_view(f) {
        create_view_check(f)
    } else {
        quote {}
    };

    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {
        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))
    } else {
        (quote {}, quote {})
    };

    let storage_init = if module_has_storage {
        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
        // referenced. We instead ignore 'unused variable' warnings for it.
        quote {
            #[allow(unused_variables)]
            let storage = Storage::init(&mut context);
        }
    } else {
        quote {}
    };

    // Initialization checks are not included in contracts that don't have initializers.
    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {
        create_init_check(f)
    } else {
        quote {}
    };

    let to_prepend = quote {
        $context_creation
        $assert_initializer
        $init_check
        $internal_check
        $view_check
        $storage_init
    };

    let to_append = quote {
        $mark_as_initialized
    };

    let body = f.body().as_block().unwrap();
    let modified_body = modify_fn_body(body, to_prepend, to_append);
    f.set_body(modified_body);

    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because
    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM
    // bytecode.
    f.set_unconstrained(true);
    f.set_return_public(true);

    fn_abi
}

pub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // Check if function is marked as unconstrained
    if !f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword",
        );
    }

    // Create utility context
    let context_creation =
        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };
    let module_has_storage = module_has_storage(f.module());

    // Initialize Storage if module has storage
    let storage_init = if module_has_storage {
        quote {
            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
            // referenced. We instead ignore 'unused variable' warnings for it.
            #[allow(unused_variables)]
            let storage = Storage::init(context);
        }
    } else {
        quote {}
    };

    // All utility functions perform message discovery, since they may need to access private notes that would be
    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually
    // attempt to read any.
    let message_discovery_call = if NOTES.len() > 0 {
        create_message_discovery_call()
    } else {
        quote {}
    };

    // Inject context creation, storage initialization, and message discovery call at the beginning of the function
    // body.
    let to_prepend = quote {
        $context_creation
        $storage_init
        $message_discovery_call
    };
    let body = f.body().as_block().unwrap();
    let modified_body = modify_fn_body(body, to_prepend, quote {});
    f.set_body(modified_body);

    f.set_return_public(true);

    fn_abi
}

comptime fn create_internal_check(f: FunctionDefinition) -> Quoted {
    let name = f.name();
    let assertion_message = f"Function {name} can only be called internally";
    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }
}

comptime fn create_view_check(f: FunctionDefinition) -> Quoted {
    let name = f.name();
    let assertion_message = f"Function {name} can only be called statically";
    if is_fn_private(f) {
        // Here \`context\` is of type context::PrivateContext
        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }
    } else {
        // Here \`context\` is of type context::PublicContext
        quote { assert(context.is_static_call(), $assertion_message); }
    }
}

comptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);"
        .quoted_contents()
}

comptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);"
        .quoted_contents()
}

comptime fn create_init_check(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);"
        .quoted_contents()
}

/// Injects a call to \`aztec::messages::discovery::discover_new_messages\`, causing for new notes to be added to PXE and made
/// available for the current execution.
pub(crate) comptime fn create_message_discovery_call() -> Quoted {
    quote {
        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore
        /// always safe to call.
        unsafe {
            dep::aztec::messages::discovery::discover_new_messages(
                context.this_address(),
                _compute_note_hash_and_nullifier,
            );
        };
    }
}

/// Checks if each function in the module is marked with either #[private], #[public], #[utility],
/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.
pub(crate) comptime fn check_each_fn_macroified(m: Module) {
    for f in m.functions() {
        let name = f.name();
        if !is_fn_private(f)
            & !is_fn_public(f)
            & !is_fn_utility(f)
            & !is_fn_contract_library_method(f)
            & !is_fn_test(f) {
            panic(
                f"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]",
            );
        }
    }
}
`},107:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage.nr",source:`use poseidon::poseidon2::Poseidon2Hasher;
use std::{collections::umap::UHashMap, hash::BuildHasherDefault};

use super::utils::AsStrQuote;
use super::utils::get_storage_size;

/// Stores a map from a module to the name of the struct that describes its storage layout.
/// This is then used when generating a \`storage_layout()\` getter on the contract struct.
pub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =
    UHashMap::default();

/// Marks a struct as the one describing the storage layout of a contract.
///
/// The contract's storage is accessed via the \`storage\` variable, which will will automatically be made available in
/// all functions as an instance of the struct this macro was applied to.
///
/// Only a single struct in the entire contract should have this macro (or \`storage_no_init\`) applied to it, and the
/// struct has to be called 'Storage'.
pub comptime fn storage(s: TypeDefinition) -> Quoted {
    let struct_name = s.name();
    if struct_name != quote { Storage } {
        panic(
            f"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.",
        )
    }

    assert(
        !s.has_named_attribute("storage_no_init"),
        f"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.",
    );

    // This macro performs three things:
    //  - it marks the contract as having storage, so that \`macros::utils::module_has_storage\` will return true and
    //    functions will have the storage variable injected and initialized via the \`init\` function.
    //  - it implements said \`init\` function by allocating appropriate storage slots to each state variable.
    //  - it exposes the storage layout by creating a \`StorageLayout\` struct that is exposed via the \`abi(storage)\`
    //    macro.
    let mut slot: u32 = 1;
    let mut storage_vars_constructors = &[];
    let mut storage_layout_fields = &[];
    let mut storage_layout_constructors = &[];

    // TODO(#8658): uncomment the code below to inject the Context type parameter.
    //let mut new_storage_fields = &[];
    //let context_generic = s.add_generic("Context");
    for field in s.fields_as_written() {
        // FIXME: This doesn't handle field types with generics
        let (name, typ) = field;
        let (storage_field_constructor, storage_size) =
            generate_storage_field_constructor(typ, quote { $slot });
        storage_vars_constructors =
            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });
        // We have \`Storable\` in a separate \`.nr\` file instead of defining it in the last quote of this function
        // because that way a dev gets a more reasonable error if he defines a struct with the same name in
        // a contract.
        storage_layout_fields =
            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });
        storage_layout_constructors = storage_layout_constructors.push_back(
            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },
        );
        //let with_context_generic = add_context_generic(typ, context_generic);
        //println(with_context_generic);
        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));
        slot += storage_size;
    }

    //s.set_fields(new_storage_fields);
    let storage_vars_constructors = storage_vars_constructors.join(quote {,});
    let storage_impl = quote {
        impl<Context> Storage<Context> {
            fn init(context: Context) -> Self {
                Self {
                    $storage_vars_constructors
                }
            }
        }
    };

    let storage_layout_fields = storage_layout_fields.join(quote {,});
    let storage_layout_constructors = storage_layout_constructors.join(quote {,});

    let module = s.module();
    let module_name = module.name();
    let storage_layout_name = f"STORAGE_LAYOUT_{module_name}".quoted_contents();
    let (module_name_str, module_name_len) = module_name.as_str_quote();
    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);

    quote {
        $storage_impl

        pub struct StorageLayoutFields {
            $storage_layout_fields
        }

        pub struct StorageLayout<let N: u32> {
            pub contract_name: str<N>,
            pub fields: StorageLayoutFields
        }

        #[abi(storage)]
        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {
            contract_name: $module_name_str,
            fields: StorageLayoutFields { $storage_layout_constructors }
        };
    }
}

/// Same as \`storage\`, except the user is in charge of providing an implementation of the \`init\` constructor function
/// with signature \`fn init<Context>(context: Context) -> Self\`, which allows for manual control of storage slot
/// allocation. Similarly, no \`StorageLayout\` struct will be created.
///
/// The contract's storage is accessed via the \`storage\` variable, which will will automatically be made available in
/// all functions as an instance of the struct this macro was applied to.
///
/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct
/// has to be called 'Storage'.
pub comptime fn storage_no_init(s: TypeDefinition) {
    // All \`storage\` does is provide the \`init\` implementation, so we don't need to do anything here. Applying this
    // macro however will cause for \`macros::utils::module_has_storage\` to return true, resulting in the injection of
    // the \`storage\` variable.

    // We do need to make sure that the type is called Storage, since we'll do \`Storage::init\` later on.

    if s.name() != quote { Storage } {
        let name = s.name();
        panic(
            f"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.",
        )
    }

    assert(
        !s.has_named_attribute("storage"),
        f"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.",
    );
}

/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,
/// i.e. how many contiguous storage slots the variable requires.
comptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {
    assert(
        typ.as_data_type().is_some(),
        "Storage containers must be generic structs of the form \`Container<_, Context>\`, or Map<Key, _, Context>",
    );
    let (container_struct, generics) = typ.as_data_type().unwrap();
    let struct_name = container_struct.name();

    let constructor = if is_storage_map(typ) {
        // Map state variables recursively initialize their contents - this includes nested maps.
        let (value_constructor, _) =
            generate_storage_field_constructor(generics[1], quote { slot });

        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }
    } else {
        // We assume below that all state variables implement \`fn new<Context>(context: Context, slot: Field) -> Self\`.
        quote { $struct_name::new(context, $slot)}
    };

    (constructor, get_storage_size(typ))
}

/// Returns true if \`typ\` is \`state_vars::map::Map\`.
comptime fn is_storage_map(typ: Type) -> bool {
    if typ.as_data_type().is_some() {
        let (def, generics) = typ.as_data_type().unwrap();
        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {
            let maybe_key = generics[0];
            let maybe_value = generics[1];
            let maybe_context = generics[2];
            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()
        } else {
            quote {()}.as_type()
        };
        typ == maybe_map
    } else {
        false
    }
}

comptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {
    let (def, mut generics) = typ.as_data_type().expect(
        f"Storage containers must be generic structs of the form \`Container<..., Context>\`",
    );
    let name = def.name();

    if is_storage_map(typ) {
        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);
        generics[generics.len() - 1] = context_generic;
    } else {
        generics[generics.len() - 1] = context_generic;
    }

    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});
    quote { $name<$generics> }.as_type()
}
`},143:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",source:`use dep::protocol_types::{
    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,
};

#[oracle(callPrivateFunction)]
unconstrained fn call_private_function_oracle(
    _contract_address: AztecAddress,
    _function_selector: FunctionSelector,
    _args_hash: Field,
    _start_side_effect_counter: u32,
    _is_static_call: bool,
) -> [Field; 2] {}

pub unconstrained fn call_private_function_internal(
    contract_address: AztecAddress,
    function_selector: FunctionSelector,
    args_hash: Field,
    start_side_effect_counter: u32,
    is_static_call: bool,
) -> (u32, Field) {
    let fields = call_private_function_oracle(
        contract_address,
        function_selector,
        args_hash,
        start_side_effect_counter,
        is_static_call,
    );

    let mut reader = Reader::new(fields);
    let end_side_effect_counter = reader.read_u32();
    let returns_hash = reader.read();

    (end_side_effect_counter, returns_hash)
}
`},145:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",source:`use dep::protocol_types::address::AztecAddress;

#[oracle(notifyEnqueuedPublicFunctionCall)]
unconstrained fn notify_enqueued_public_function_call_oracle(
    _contract_address: AztecAddress,
    _calldata_hash: Field,
    _side_effect_counter: u32,
    _is_static_call: bool,
) {}

unconstrained fn notify_enqueued_public_function_call_wrapper(
    contract_address: AztecAddress,
    calldata_hash: Field,
    side_effect_counter: u32,
    is_static_call: bool,
) {
    notify_enqueued_public_function_call_oracle(
        contract_address,
        calldata_hash,
        side_effect_counter,
        is_static_call,
    )
}

pub fn notify_enqueued_public_function_call(
    contract_address: AztecAddress,
    calldata_hash: Field,
    side_effect_counter: u32,
    is_static_call: bool,
) {
    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.
    unsafe {
        notify_enqueued_public_function_call_wrapper(
            contract_address,
            calldata_hash,
            side_effect_counter,
            is_static_call,
        )
    }
}

#[oracle(notifySetPublicTeardownFunctionCall)]
unconstrained fn notify_set_public_teardown_function_call_oracle(
    _contract_address: AztecAddress,
    _calldata_hash: Field,
    _side_effect_counter: u32,
    _is_static_call: bool,
) {}

unconstrained fn notify_set_public_teardown_function_call_wrapper(
    contract_address: AztecAddress,
    calldata_hash: Field,
    side_effect_counter: u32,
    is_static_call: bool,
) {
    notify_set_public_teardown_function_call_oracle(
        contract_address,
        calldata_hash,
        side_effect_counter,
        is_static_call,
    )
}

pub fn notify_set_public_teardown_function_call(
    contract_address: AztecAddress,
    calldata_hash: Field,
    side_effect_counter: u32,
    is_static_call: bool,
) {
    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.
    unsafe {
        notify_set_public_teardown_function_call_wrapper(
            contract_address,
            calldata_hash,
            side_effect_counter,
            is_static_call,
        )
    }
}

pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call.
    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };
}

pub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {
    notify_set_min_revertible_side_effect_counter_oracle(counter);
}

#[oracle(notifySetMinRevertibleSideEffectCounter)]
unconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}
`},146:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",source:`use dep::protocol_types::address::AztecAddress;

#[oracle(getContractAddress)]
unconstrained fn get_contract_address_oracle() -> AztecAddress {}

#[oracle(getBlockNumber)]
unconstrained fn get_block_number_oracle() -> u32 {}

#[oracle(getChainId)]
unconstrained fn get_chain_id_oracle() -> Field {}

#[oracle(getVersion)]
unconstrained fn get_version_oracle() -> Field {}

pub unconstrained fn get_contract_address() -> AztecAddress {
    get_contract_address_oracle()
}

pub unconstrained fn get_block_number() -> u32 {
    get_block_number_oracle()
}

pub unconstrained fn get_chain_id() -> Field {
    get_chain_id_oracle()
}

pub unconstrained fn get_version() -> Field {
    get_version_oracle()
}
`},147:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",source:`/// Stores values represented as slice in execution cache to be later obtained by its hash.
pub fn store(values: [Field], hash: Field) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.
    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };
}

unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {
    store_in_execution_cache_oracle(values, hash);
}

pub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {
    load_from_execution_cache_oracle(hash)
}

#[oracle(storeInExecutionCache)]
unconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}

#[oracle(loadFromExecutionCache)]
unconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}
`},158:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",source:`use crate::note::{
    note_interface::NoteType,
    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},
};

use dep::protocol_types::{
    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,
};

/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same
/// transaction. This note should only be added to the non-volatile database if found in an actual block.
pub fn notify_created_note<let N: u32>(
    storage_slot: Field,
    note_type_id: Field,
    packed_note: [Field; N],
    note_hash: Field,
    counter: u32,
) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call.
    unsafe {
        notify_created_note_oracle_wrapper(
            storage_slot,
            note_type_id,
            packed_note,
            note_hash,
            counter,
        )
    };
}

/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in
/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an
/// actual block.
pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to
    // call.
    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };
}

/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.
pub fn notify_created_nullifier(nullifier: Field) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to
    // call.
    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };
}

unconstrained fn notify_created_note_oracle_wrapper<let N: u32>(
    storage_slot: Field,
    note_type_id: Field,
    packed_note: [Field; N],
    note_hash: Field,
    counter: u32,
) {
    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);
}

#[oracle(notifyCreatedNote)]
unconstrained fn notify_created_note_oracle<let N: u32>(
    _storage_slot: Field,
    _note_type_id: Field,
    _packed_note: [Field; N],
    _note_hash: Field,
    _counter: u32,
) {}

unconstrained fn notify_nullified_note_oracle_wrapper(
    nullifier: Field,
    note_hash: Field,
    counter: u32,
) {
    notify_nullified_note_oracle(nullifier, note_hash, counter);
}

#[oracle(notifyNullifiedNote)]
unconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}

unconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {
    notify_created_nullifier_oracle(nullifier);
}

#[oracle(notifyCreatedNullifier)]
unconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}

#[oracle(getNotes)]
unconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(
    _storage_slot: Field,
    _num_selects: u8,
    _select_by_indexes: [u8; M],
    _select_by_offsets: [u8; M],
    _select_by_lengths: [u8; M],
    _select_values: [Field; M],
    _select_comparators: [u8; M],
    _sort_by_indexes: [u8; M],
    _sort_by_offsets: [u8; M],
    _sort_by_lengths: [u8; M],
    _sort_order: [u8; M],
    _limit: u32,
    _offset: u32,
    _status: u8,
    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec
    _max_notes: u32,
    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to
    // correctly construct the BoundedVec there.
    _packed_retrieved_note_length: u32,
) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}

pub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(
    storage_slot: Field,
    num_selects: u8,
    select_by_indexes: [u8; M],
    select_by_offsets: [u8; M],
    select_by_lengths: [u8; M],
    select_values: [Field; M],
    select_comparators: [u8; M],
    sort_by_indexes: [u8; M],
    sort_by_offsets: [u8; M],
    sort_by_lengths: [u8; M],
    sort_order: [u8; M],
    limit: u32,
    offset: u32,
    status: u8,
) -> [Option<RetrievedNote<Note>>; MAX_NOTES]
where
    Note: NoteType + Packable<NOTE_PCKD_LEN>,
{
    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.
    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(
        storage_slot,
        num_selects,
        select_by_indexes,
        select_by_offsets,
        select_by_lengths,
        select_values,
        select_comparators,
        sort_by_indexes,
        sort_by_offsets,
        sort_by_lengths,
        sort_order,
        limit,
        offset,
        status,
        MAX_NOTES,
        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,
    );

    let mut notes = BoundedVec::<_, MAX_NOTES>::new();
    for i in 0..packed_retrieved_notes.len() {
        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));
        notes.push(retrieved_note);
    }

    // At last we convert the bounded vector to an array of options. We do this because that is what the filter
    // function needs to have on the output and we've decided to have the same type on the input and output of
    // the filter and preprocessor functions.
    //
    // We have decided to have the same type on the input and output of the filter and preprocessor functions because
    // it allows us to chain multiple filters and preprocessors together.
    //
    // So why do we want the array of options on the output of the filter function?
    //
    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options
    // allows setting values at known indices in the output array which is much more efficient than pushing to a
    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted
    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic
    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor
    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in
    // an unconstrained context. We, however, use the same return value type to be able to use the same function as
    // both a preprocessor and a filter.
    let mut notes_array = [Option::none(); MAX_NOTES];
    for i in 0..notes.len() {
        if i < notes.len() {
            notes_array[i] = Option::some(notes.get_unchecked(i));
        }
    }

    notes_array
}

/// Returns true if the nullifier exists. Note that a \`true\` value can be constrained by proving existence of the
/// nullifier, but a \`false\` value should not be relied upon since other transactions may emit this nullifier before the
/// current transaction is included in a block. While this might seem of little use at first, certain design patterns
/// benefit from this abstraction (see e.g. \`PrivateMutable\`).
pub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {
    check_nullifier_exists_oracle(inner_nullifier)
}

#[oracle(checkNullifierExists)]
unconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}

/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,
/// siloed for the current contract address.
pub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {
    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)
}

#[oracle(getIndexedTaggingSecretAsSender)]
unconstrained fn get_indexed_tagging_secret_as_sender_oracle(
    _sender: AztecAddress,
    _recipient: AztecAddress,
) -> IndexedTaggingSecret {}

/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that
/// future notes get a different tag and can be discovered by the recipient.
/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -
/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes
/// that are not found by the recipient.
pub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call.
    unsafe {
        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);
    }
}

unconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(
    sender: AztecAddress,
    recipient: AztecAddress,
) {
    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);
}

#[oracle(incrementAppTaggingSecretIndexAsSender)]
unconstrained fn increment_app_tagging_secret_index_as_sender_oracle(
    _sender: AztecAddress,
    _recipient: AztecAddress,
) {}
`},162:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",source:`use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};

#[oracle(storageRead)]
unconstrained fn storage_read_oracle<let N: u32>(
    address: Field,
    storage_slot: Field,
    block_number: Field,
    length: Field,
) -> [Field; N] {}

pub unconstrained fn raw_storage_read<let N: u32>(
    address: AztecAddress,
    storage_slot: Field,
    block_number: u32,
) -> [Field; N] {
    storage_read_oracle(
        address.to_field(),
        storage_slot,
        block_number as Field,
        N as Field,
    )
}

pub unconstrained fn storage_read<T, let N: u32>(
    address: AztecAddress,
    storage_slot: Field,
    block_number: u32,
) -> T
where
    T: Packable<N>,
{
    T::unpack(raw_storage_read(address, storage_slot, block_number))
}

mod tests {
    use crate::oracle::storage::{raw_storage_read, storage_read};
    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};

    use crate::test::mocks::mock_struct::MockStruct;
    use std::test::OracleMock;

    global address: AztecAddress = AztecAddress::from_field(29);
    global slot: Field = 7;
    global block_number: u32 = 17;

    #[test]
    unconstrained fn test_raw_storage_read() {
        let written = MockStruct { a: 13, b: 42 };

        let _ = OracleMock::mock("storageRead").returns(written.pack());

        let read: [Field; 2] = raw_storage_read(address, slot, block_number);
        assert_eq(read[0], 13);
        assert_eq(read[1], 42);
    }

    #[test]
    unconstrained fn test_storage_read() {
        let written = MockStruct { a: 13, b: 42 };

        let _ = OracleMock::mock("storageRead").returns(written.pack());

        let read: MockStruct = storage_read(address, slot, block_number);
        assert_eq(read.a, 13);
        assert_eq(read.b, 42);
    }
}
`},164:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",source:`use crate::state_vars::storage::Storage;
use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};

// docs:start:map
pub struct Map<K, V, Context> {
    context: Context,
    storage_slot: Field,
    state_var_constructor: fn(Context, Field) -> V,
}
// docs:end:map

// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only
// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots
// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.
impl<K, T, Context> Storage<1> for Map<K, T, Context> {
    fn get_storage_slot(self) -> Field {
        self.storage_slot
    }
}

impl<K, V, Context> Map<K, V, Context> {
    // docs:start:new
    pub fn new(
        context: Context,
        storage_slot: Field,
        state_var_constructor: fn(Context, Field) -> V,
    ) -> Self {
        assert(storage_slot != 0, "Storage slot 0 not allowed. Storage slots must start from 1.");
        Map { context, storage_slot, state_var_constructor }
    }
    // docs:end:new

    // docs:start:at
    pub fn at(self, key: K) -> V
    where
        K: ToField,
    {
        // TODO(#1204): use a generator index for the storage slot
        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);

        let state_var_constructor = self.state_var_constructor;
        state_var_constructor(self.context, derived_storage_slot)
    }
    // docs:end:at
}
`},173:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",source:`use crate::context::{PublicContext, UtilityContext};
use crate::state_vars::storage::Storage;
use dep::protocol_types::traits::Packable;

// docs:start:public_mutable_struct
pub struct PublicMutable<T, Context> {
    context: Context,
    storage_slot: Field,
}
// docs:end:public_mutable_struct

impl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>
where
    T: Packable<N>,
{
    fn get_storage_slot(self) -> Field {
        self.storage_slot
    }
}

impl<T, Context> PublicMutable<T, Context> {
    // docs:start:public_mutable_struct_new
    pub fn new(
        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.
        context: Context,
        storage_slot: Field,
    ) -> Self {
        assert(storage_slot != 0, "Storage slot 0 not allowed. Storage slots must start from 1.");
        PublicMutable { context, storage_slot }
    }
    // docs:end:public_mutable_struct_new
}

impl<T> PublicMutable<T, &mut PublicContext> {
    // docs:start:public_mutable_struct_read
    pub fn read<let T_PACKED_LEN: u32>(self) -> T
    where
        T: Packable<T_PACKED_LEN>,
    {
        self.context.storage_read(self.storage_slot)
    }
    // docs:end:public_mutable_struct_read

    // docs:start:public_mutable_struct_write
    pub fn write<let T_PACKED_LEN: u32>(self, value: T)
    where
        T: Packable<T_PACKED_LEN>,
    {
        self.context.storage_write(self.storage_slot, value);
    }
    // docs:end:public_mutable_struct_write
}

impl<T> PublicMutable<T, UtilityContext> {
    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T
    where
        T: Packable<T_PACKED_LEN>,
    {
        self.context.storage_read(self.storage_slot)
    }
}
`},209:{path:"/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",source:`use std::default::Default;
use std::hash::Hasher;

comptime global RATE: u32 = 3;

pub struct Poseidon2 {
    cache: [Field; 3],
    state: [Field; 4],
    cache_size: u32,
    squeeze_mode: bool, // 0 => absorb, 1 => squeeze
}

impl Poseidon2 {
    #[no_predicates]
    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {
        Poseidon2::hash_internal(input, message_size, message_size != N)
    }

    pub(crate) fn new(iv: Field) -> Poseidon2 {
        let mut result =
            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };
        result.state[RATE] = iv;
        result
    }

    fn perform_duplex(&mut self) {
        // add the cache into sponge state
        for i in 0..RATE {
            // We effectively zero-pad the cache by only adding to the state
            // cache that is less than the specified \`cache_size\`
            if i < self.cache_size {
                self.state[i] += self.cache[i];
            }
        }
        self.state = crate::poseidon2_permutation(self.state, 4);
    }

    fn absorb(&mut self, input: Field) {
        assert(!self.squeeze_mode);
        if self.cache_size == RATE {
            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache
            self.perform_duplex();
            self.cache[0] = input;
            self.cache_size = 1;
        } else {
            // If we're absorbing, and the cache is not full, add the input into the cache
            self.cache[self.cache_size] = input;
            self.cache_size += 1;
        }
    }

    fn squeeze(&mut self) -> Field {
        assert(!self.squeeze_mode);
        // If we're in absorb mode, apply sponge permutation to compress the cache.
        self.perform_duplex();
        self.squeeze_mode = true;

        // Pop one item off the top of the permutation and return it.
        self.state[0]
    }

    fn hash_internal<let N: u32>(
        input: [Field; N],
        in_len: u32,
        is_variable_length: bool,
    ) -> Field {
        let two_pow_64 = 18446744073709551616;
        let iv: Field = (in_len as Field) * two_pow_64;
        let mut sponge = Poseidon2::new(iv);
        for i in 0..input.len() {
            if i < in_len {
                sponge.absorb(input[i]);
            }
        }

        // In the case where the hash preimage is variable-length, we append \`1\` to the end of the input, to distinguish
        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures
        // fixed-length and variable-length hashes do not collide)
        if is_variable_length {
            sponge.absorb(1);
        }
        sponge.squeeze()
    }
}

pub struct Poseidon2Hasher {
    _state: [Field],
}

impl Hasher for Poseidon2Hasher {
    fn finish(self) -> Field {
        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)
        let mut sponge = Poseidon2::new(iv);
        for i in 0..self._state.len() {
            sponge.absorb(self._state[i]);
        }
        sponge.squeeze()
    }

    fn write(&mut self, input: Field) {
        self._state = self._state.push_back(input);
    }
}

impl Default for Poseidon2Hasher {
    fn default() -> Self {
        Poseidon2Hasher { _state: &[] }
    }
}
`},271:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",source:`use crate::{
    address::{
        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,
    },
    constants::{
        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,
        MAX_PROTOCOL_CONTRACTS,
    },
    contract_class_id::ContractClassId,
    hash::poseidon2_hash_with_separator,
    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},
    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},
    utils::field::{pow, sqrt},
};

// We do below because \`use crate::point::Point;\` does not work
use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;

use crate::public_keys::AddressPoint;
use std::{
    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},
    ops::Add,
};

// Aztec address
pub struct AztecAddress {
    pub inner: Field,
}

impl Eq for AztecAddress {
    fn eq(self, other: Self) -> bool {
        self.to_field() == other.to_field()
    }
}

impl Empty for AztecAddress {
    fn empty() -> Self {
        Self { inner: 0 }
    }
}

impl ToField for AztecAddress {
    fn to_field(self) -> Field {
        self.inner
    }
}

impl FromField for AztecAddress {
    fn from_field(value: Field) -> AztecAddress {
        AztecAddress { inner: value }
    }
}

impl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {
    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {
        [self.to_field()]
    }
}

impl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {
    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {
        FromField::from_field(fields[0])
    }
}

/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there
/// the implementation of Packable is required).
impl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {
    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {
        self.serialize()
    }

    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {
        Self::deserialize(fields)
    }
}

impl AztecAddress {
    pub fn zero() -> Self {
        Self { inner: 0 }
    }

    pub fn to_address_point(self) -> AddressPoint {
        // We compute the address point by taking our address, setting it to x, and then solving for y in the
        // equation which defines our bn curve:
        // y^2 = x^3 - 17; x = address
        let x = self.inner;
        let y_squared = pow(x, 3) - 17;

        // TODO (#8970): Handle cases where we cannot recover a point from an address
        let mut y = sqrt(y_squared);

        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the
        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus
        // note: The field modulus is MAX_FIELD_VALUE + 1
        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {
            y = (MAX_FIELD_VALUE + 1) - y;
        }

        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }
    }

    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {
        let public_keys_hash = public_keys.hash();

        let pre_address = poseidon2_hash_with_separator(
            [public_keys_hash.to_field(), partial_address.to_field()],
            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,
        );

        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(
            public_keys.ivpk_m.to_point(),
        );

        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us
        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.
        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or
        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one
        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.
        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,
        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.
        AztecAddress::from_field(address_point.x)
    }

    pub fn compute_from_class_id(
        contract_class_id: ContractClassId,
        salted_initialization_hash: SaltedInitializationHash,
        public_keys: PublicKeys,
    ) -> Self {
        let partial_address = PartialAddress::compute_from_salted_initialization_hash(
            contract_class_id,
            salted_initialization_hash,
        );

        AztecAddress::compute(public_keys, partial_address)
    }

    pub fn is_protocol_contract(self) -> bool {
        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)
    }

    pub fn is_zero(self) -> bool {
        self.inner == 0
    }

    pub fn assert_is_zero(self) {
        assert(self.to_field() == 0);
    }
}

#[test]
fn compute_address_from_partial_and_pub_keys() {
    let public_keys = PublicKeys {
        npk_m: NpkM {
            inner: Point {
                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,
                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,
                is_infinite: false,
            },
        },
        ivpk_m: IvpkM {
            inner: Point {
                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,
                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,
                is_infinite: false,
            },
        },
        ovpk_m: OvpkM {
            inner: Point {
                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,
                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,
                is_infinite: false,
            },
        },
        tpk_m: TpkM {
            inner: Point {
                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,
                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,
                is_infinite: false,
            },
        },
    };

    let partial_address = PartialAddress::from_field(
        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,
    );

    let address = AztecAddress::compute(public_keys, partial_address);

    // The following value was generated by \`derivation.test.ts\`.
    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.
    let expected_computed_address_from_partial_and_pubkeys =
        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;
    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);
}

#[test]
fn compute_preaddress_from_partial_and_pub_keys() {
    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);
    let expected_computed_preaddress_from_partial_and_pubkey =
        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;
    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);
}

#[test]
fn from_field_to_field() {
    let address = AztecAddress { inner: 37 };
    assert_eq(FromField::from_field(address.to_field()), address);
}

#[test]
fn serde() {
    let address = AztecAddress { inner: 37 };
    assert_eq(Deserialize::deserialize(address.serialize()), address);
}
`},289:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",source:`use crate::{
    abis::{
        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,
        contract_class_log::ContractClassLog,
        function_selector::FunctionSelector,
        note_hash::ScopedNoteHash,
        nullifier::ScopedNullifier,
        private_log::{PrivateLog, PrivateLogData},
        side_effect::{OrderedValue, scoped::Scoped},
    },
    address::{AztecAddress, EthAddress},
    constants::{
        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,
        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,
        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,
    },
    merkle_tree::root::root_from_sibling_path,
    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},
    poseidon2::Poseidon2Sponge,
    traits::{FromField, Hash, ToField},
    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},
};

pub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {
    let sha256_hashed = sha256::digest(bytes_to_hash);
    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);

    hash_in_a_field
}

pub fn private_functions_root_from_siblings(
    selector: FunctionSelector,
    vk_hash: Field,
    function_leaf_index: Field,
    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],
) -> Field {
    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };
    let function_leaf = function_leaf_preimage.hash();
    root_from_sibling_path(
        function_leaf,
        function_leaf_index,
        function_leaf_sibling_path,
    )
}

pub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {
    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also
    // unique).
    poseidon2_hash_with_separator(
        [first_nullifier_in_tx, note_index_in_tx as Field],
        GENERATOR_INDEX__NOTE_HASH_NONCE,
    )
}

pub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {
    let inputs = [nonce, siloed_note_hash];
    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)
}

pub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {
    poseidon2_hash_with_separator(
        [app.to_field(), note_hash],
        GENERATOR_INDEX__SILOED_NOTE_HASH,
    )
}

/// Computes unique note hashes from siloed note hashes
pub fn compute_unique_siloed_note_hash(
    siloed_note_hash: Field,
    first_nullifier: Field,
    note_index_in_tx: u32,
) -> Field {
    if siloed_note_hash == 0 {
        0
    } else {
        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);
        compute_unique_note_hash(nonce, siloed_note_hash)
    }
}

/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way
/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.
pub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {
    if note_hash.contract_address.is_zero() {
        0
    } else {
        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())
    }
}

pub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {
    poseidon2_hash_with_separator(
        [app.to_field(), nullifier],
        GENERATOR_INDEX__OUTER_NULLIFIER,
    )
}

pub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {
    if nullifier.contract_address.is_zero() {
        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.
    } else {
        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())
    }
}

pub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {
    poseidon2_hash([contract_address.to_field(), field])
}

pub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {
    if private_log.contract_address.is_zero() {
        private_log.inner.log
    } else {
        let mut fields = private_log.inner.log.fields;
        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);
        PrivateLog::new(fields, private_log.inner.log.length)
    }
}

pub fn compute_siloed_contract_class_log_field(
    contract_address: AztecAddress,
    first_field: Field,
) -> Field {
    poseidon2_hash([contract_address.to_field(), first_field])
}

pub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {
    if contract_class_log.contract_address.is_zero() {
        contract_class_log
    } else {
        let mut log = contract_class_log;
        log.log.fields[0] = compute_siloed_contract_class_log_field(
            contract_class_log.contract_address,
            log.log.fields[0],
        );
        log
    }
}

pub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {
    poseidon2_hash(log)
}

pub fn merkle_hash(left: Field, right: Field) -> Field {
    poseidon2_hash([left, right])
}

pub fn compute_l2_to_l1_hash(
    contract_address: AztecAddress,
    recipient: EthAddress,
    content: Field,
    rollup_version_id: Field,
    chain_id: Field,
) -> Field {
    let mut bytes: [u8; 160] = std::mem::zeroed();

    let inputs =
        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];
    for i in 0..5 {
        // TODO are bytes be in fr.to_buffer() ?
        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();
        for j in 0..32 {
            bytes[32 * i + j] = item_bytes[j];
        }
    }

    sha256_to_field(bytes)
}

pub fn silo_l2_to_l1_message(
    msg: ScopedL2ToL1Message,
    rollup_version_id: Field,
    chain_id: Field,
) -> Field {
    if msg.contract_address.is_zero() {
        0
    } else {
        compute_l2_to_l1_hash(
            msg.contract_address,
            msg.message.recipient,
            msg.message.content,
            rollup_version_id,
            chain_id,
        )
    }
}

// Computes sha256 hash of 2 input hashes.
//
// NB: This method now takes in two 31 byte fields - it assumes that any input
// is the result of a sha_to_field hash and => is truncated
//
// TODO(Jan and David): This is used for the encrypted_log hashes.
// Can we check to see if we can just use hash_to_field or pedersen_compress here?
//
pub fn accumulate_sha256(input: [Field; 2]) -> Field {
    // This is a note about the cpp code, since it takes an array of Fields
    // instead of a u128.
    // 4 Field elements when converted to bytes will usually
    // occupy 4 * 32 = 128 bytes.
    // However, this function is making the assumption that each Field
    // only occupies 128 bits.
    //
    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?
    // Concatentate two fields into 32x2 = 64 bytes
    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers
    let mut hash_input_flattened = [0; 64];
    for offset in 0..input.len() {
        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();
        for byte_index in 0..32 {
            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];
        }
    }

    sha256_to_field(hash_input_flattened)
}

pub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {
    crate::hash::poseidon2_hash(key)
}

#[inline_always]
pub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {
    std::hash::pedersen_hash_with_separator(inputs, hash_index)
}

pub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {
    poseidon::poseidon2::Poseidon2::hash(inputs, N)
}

#[no_predicates]
pub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field
where
    T: ToField,
{
    let inputs_with_separator = array_concat([separator.to_field()], inputs);
    poseidon2_hash(inputs_with_separator)
}

// Performs a fixed length hash with a subarray of the given input.
// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.
// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()
// or any ts implementation. Also checks that any remaining elts not hashed are empty.
#[no_predicates]
pub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {
    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);
    sponge.squeeze()
}

// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,
// and absorbing in chunks of 3 below.
#[no_predicates]
pub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {
    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);
    // In the case where the hash preimage is variable-length, we append \`1\` to the end of the input, to distinguish
    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures
    // fixed-length and variable-length hashes do not collide)
    if in_len != N {
        sponge.absorb(1);
    }
    sponge.squeeze()
}

// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)
// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know
// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.
// The below code forces the compiler to:
//  - absorb normally up to 2 times to set cache_size to 1
//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb
//  - absorb normally up to 2 times to add any remaining values to the hash
// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.
// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.

#[no_predicates]
fn poseidon2_absorb_chunks<let N: u32>(
    input: [Field; N],
    in_len: u32,
    variable: bool,
) -> Poseidon2Sponge {
    let iv: Field = (in_len as Field) * TWO_POW_64;
    let mut sponge = Poseidon2Sponge::new(iv);
    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow
    // since we cannot isolate computation branches. The below is just to avoid that.
    let shift = if in_len == 0 { 0 } else { 1 };
    if in_len != 0 {
        // cache_size = 0, init absorb
        sponge.cache[0] = input[0];
        sponge.cache_size = 1;
        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge
        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)
        // max_remainder = (N - 1) % 3;
        // max_chunks = (N - 1 - max_remainder) / 3;
        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(
            sponge,
            input,
            in_len,
            variable,
            shift,
        );
    }
    sponge
}

// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true
#[no_predicates]
pub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(
    in_sponge: Poseidon2Sponge,
    input: [Field; N],
    in_len: u32,
    skip_0_check: bool,
) -> Poseidon2Sponge {
    let mut sponge = in_sponge;
    // 'shift' is to account for already added inputs
    let mut shift = 0;
    // 'stop' is to avoid an underflow when inputting in_len = 0
    let mut stop = false;
    for i in 0..3 {
        if shift == in_len {
            stop = true;
        }
        if (sponge.cache_size != 1) & (!stop) {
            sponge.absorb(input[i]);
            shift += 1;
        }
    }
    sponge = if stop {
        sponge
    } else {
        // max_chunks = (N - (N % 3)) / 3;
        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(
            sponge,
            input,
            in_len,
            skip_0_check,
            shift,
        )
    };
    sponge
}

// The below is the loop to absorb elts into a poseidon sponge in chunks of 3
// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1
// M - the max number of chunks required to absorb N things (must be comptime to compile)
// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check
// for 0s costs 3N gates. Current approach is approx 2N gates.
#[no_predicates]
fn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(
    in_sponge: Poseidon2Sponge,
    input: [Field; N],
    in_len: u32,
    variable: bool,
    shift: u32,
) -> Poseidon2Sponge {
    assert(in_len <= N, "Given in_len to absorb is larger than the input array len");
    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N
    // The below avoids an overflow
    let skip_last = 3 * M == N;
    // Writing in_sponge: &mut does not compile
    let mut sponge = in_sponge;
    let mut should_add = true;
    // The num of things left over after absorbing in 3s
    let remainder = (in_len - shift) % 3;
    // The num of chunks of 3 to absorb (maximum M)
    let chunks = (in_len - shift - remainder) / 3;
    for i in 0..M {
        // Now we loop through cache size = 1 -> 3
        should_add &= i != chunks;
        // This is the index at the start of the chunk (for readability)
        let k = 3 * i + shift;
        if should_add {
            // cache_size = 1, 2 => just assign
            sponge.cache[1] = input[k];
            sponge.cache[2] = input[k + 1];
            // cache_size = 3 => duplex + perm
            for j in 0..3 {
                sponge.state[j] += sponge.cache[j];
            }
            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);
            sponge.cache[0] = input[k + 2];
            // cache_size is now 1 again, repeat loop
        } else if (!variable) & (i != chunks) {
            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0
            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below
            let last_0 = if (i == M - 1) & (skip_last) {
                0
            } else {
                input[k + 2]
            };
            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);
            assert(all_0, "Found non-zero field after breakpoint");
        }
    }
    // we have 'remainder' num of items left to absorb
    should_add = true;
    // below is to avoid overflows (i.e. if inlen is close to N)
    let mut should_check = !variable;
    for i in 0..3 {
        should_add &= i != remainder;
        should_check &= in_len - remainder + i != N;
        if should_add {
            // we want to absorb the final 'remainder' items
            sponge.absorb(input[in_len - remainder + i]);
        } else if should_check {
            assert(input[in_len - remainder + i] == 0, "Found non-zero field after breakpoint");
        }
    }
    sponge
}

pub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field
where
    T: ToField,
{
    let in_len = inputs.len() + 1;
    let iv: Field = (in_len as Field) * TWO_POW_64;
    let mut sponge = Poseidon2Sponge::new(iv);
    sponge.absorb(separator.to_field());

    for i in 0..inputs.len() {
        sponge.absorb(inputs[i]);
    }

    sponge.squeeze()
}

#[no_predicates]
pub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {
    let mut fields = [0; (N + 30) / 31];
    let mut field_index = 0;
    let mut current_field = [0; 31];
    for i in 0..inputs.len() {
        let index = i % 31;
        current_field[index] = inputs[i];
        if index == 30 {
            fields[field_index] = field_from_bytes(current_field, false);
            current_field = [0; 31];
            field_index += 1;
        }
    }
    if field_index != fields.len() {
        fields[field_index] = field_from_bytes(current_field, false);
    }
    poseidon2_hash(fields)
}

#[test]
fn poseidon_chunks_matches_fixed() {
    let in_len = 501;
    let mut input: [Field; 4096] = [0; 4096];
    let mut fixed_input = [3; 501];
    assert(in_len == fixed_input.len()); // sanity check
    for i in 0..in_len {
        input[i] = 3;
    }
    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);
    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());
    assert(sub_chunk_hash == fixed_len_hash);
}

#[test]
fn poseidon_chunks_matches_variable() {
    let in_len = 501;
    let mut input: [Field; 4096] = [0; 4096];
    for i in 0..in_len {
        input[i] = 3;
    }
    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);
    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);
    assert(variable_chunk_hash == variable_len_hash);
}

#[test]
fn existing_sponge_poseidon_chunks_matches_fixed() {
    let in_len = 501;
    let mut input: [Field; 4096] = [0; 4096];
    let mut fixed_input = [3; 501];
    assert(in_len == fixed_input.len()); // sanity check
    for i in 0..in_len {
        input[i] = 3;
    }
    // absorb 250 of the 501 things
    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);
    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);
    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)
    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);
    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());
    assert(final_sponge.squeeze() == fixed_len_hash);
}

#[test]
fn poseidon_chunks_empty_inputs() {
    let in_len = 0;
    let mut input: [Field; 4096] = [0; 4096];
    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);
    let mut first_sponge =
        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);
    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());
}

#[test]
fn smoke_sha256_to_field() {
    let full_buffer = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,
        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,
        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
    ];
    let result = sha256_to_field(full_buffer);

    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);

    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):
    let result_bytes = sha256::digest(full_buffer);
    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);
    assert(truncated_field == result);
    let mod_res = result + (result_bytes[31] as Field);
    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);
}

#[test]
fn compute_l2_l1_hash() {
    // All zeroes
    let hash_result =
        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);
    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);

    // Non-zero case
    let hash_result = compute_l2_to_l1_hash(
        AztecAddress::from_field(1),
        EthAddress::from_field(3),
        5,
        2,
        4,
    );
    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);
}

#[test]
fn silo_l2_to_l1_message_matches_typescript() {
    let version = 4;
    let chainId = 5;

    let hash = silo_l2_to_l1_message(
        ScopedL2ToL1Message {
            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },
            contract_address: AztecAddress::from_field(3),
        },
        version,
        chainId,
    );

    // The following value was generated by \`l2_to_l1_message.test.ts\`
    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;

    assert_eq(hash, hash_from_typescript);
}
`},306:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",source:`use crate::constants::TWO_POW_64;

// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr
// It exists as we sometimes need to perform custom absorption, but the stdlib version
// has a private absorb() method (it's also designed to just be a hasher)
// Can be removed when standalone noir poseidon lib exists: See noir#6679

comptime global RATE: u32 = 3;

pub struct Poseidon2Sponge {
    pub cache: [Field; 3],
    pub state: [Field; 4],
    pub cache_size: u32,
    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze
}

impl Poseidon2Sponge {
    #[no_predicates]
    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {
        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)
    }

    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {
        let mut result =
            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };
        result.state[RATE] = iv;
        result
    }

    fn perform_duplex(&mut self) {
        // add the cache into sponge state
        for i in 0..RATE {
            // We effectively zero-pad the cache by only adding to the state
            // cache that is less than the specified \`cache_size\`
            if i < self.cache_size {
                self.state[i] += self.cache[i];
            }
        }
        self.state = std::hash::poseidon2_permutation(self.state, 4);
    }

    pub fn absorb(&mut self, input: Field) {
        assert(!self.squeeze_mode);
        if self.cache_size == RATE {
            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache
            self.perform_duplex();
            self.cache[0] = input;
            self.cache_size = 1;
        } else {
            // If we're absorbing, and the cache is not full, add the input into the cache
            self.cache[self.cache_size] = input;
            self.cache_size += 1;
        }
    }

    pub fn squeeze(&mut self) -> Field {
        assert(!self.squeeze_mode);
        // If we're in absorb mode, apply sponge permutation to compress the cache.
        self.perform_duplex();
        self.squeeze_mode = true;

        // Pop one item off the top of the permutation and return it.
        self.state[0]
    }

    fn hash_internal<let N: u32>(
        input: [Field; N],
        in_len: u32,
        is_variable_length: bool,
    ) -> Field {
        let iv: Field = (in_len as Field) * TWO_POW_64;
        let mut sponge = Poseidon2Sponge::new(iv);
        for i in 0..input.len() {
            if i < in_len {
                sponge.absorb(input[i]);
            }
        }

        // In the case where the hash preimage is variable-length, we append \`1\` to the end of the input, to distinguish
        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures
        // fixed-length and variable-length hashes do not collide)
        if is_variable_length {
            sponge.absorb(1);
        }
        sponge.squeeze()
    }
}
`},327:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",source:`use crate::{hash::poseidon2_hash, traits::ToField};

pub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field
where
    K: ToField,
{
    poseidon2_hash([storage_slot, key.to_field()])
}

mod test {
    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};

    #[test]
    fn test_derive_storage_slot_in_map_matches_typescript() {
        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;
        let key = AztecAddress::from_field(
            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,
        );

        let slot = derive_storage_slot_in_map(map_slot, key);

        // The following value was generated by \`map_slot.test.ts\`
        let slot_from_typescript =
            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;

        assert_eq(slot, slot_from_typescript);
    }
}
`},345:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",source:`use crate::traits::Packable;

global BOOL_PACKED_LEN: u32 = 1;
global U8_PACKED_LEN: u32 = 1;
global U16_PACKED_LEN: u32 = 1;
global U32_PACKED_LEN: u32 = 1;
global U64_PACKED_LEN: u32 = 1;
global U128_PACKED_LEN: u32 = 1;
global FIELD_PACKED_LEN: u32 = 1;
global I8_PACKED_LEN: u32 = 1;
global I16_PACKED_LEN: u32 = 1;
global I32_PACKED_LEN: u32 = 1;
global I64_PACKED_LEN: u32 = 1;

impl Packable<BOOL_PACKED_LEN> for bool {
    fn pack(self) -> [Field; BOOL_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {
        fields[0] as bool
    }
}

impl Packable<U8_PACKED_LEN> for u8 {
    fn pack(self) -> [Field; U8_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {
        fields[0] as u8
    }
}

impl Packable<U16_PACKED_LEN> for u16 {
    fn pack(self) -> [Field; U16_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {
        fields[0] as u16
    }
}

impl Packable<U32_PACKED_LEN> for u32 {
    fn pack(self) -> [Field; U32_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {
        fields[0] as u32
    }
}

impl Packable<U64_PACKED_LEN> for u64 {
    fn pack(self) -> [Field; U64_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {
        fields[0] as u64
    }
}

impl Packable<U128_PACKED_LEN> for u128 {
    fn pack(self) -> [Field; U128_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {
        fields[0] as u128
    }
}

impl Packable<FIELD_PACKED_LEN> for Field {
    fn pack(self) -> [Field; FIELD_PACKED_LEN] {
        [self]
    }

    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {
        fields[0]
    }
}

impl Packable<I8_PACKED_LEN> for i8 {
    fn pack(self) -> [Field; I8_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {
        fields[0] as i8
    }
}

impl Packable<I16_PACKED_LEN> for i16 {
    fn pack(self) -> [Field; I16_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {
        fields[0] as i16
    }
}

impl Packable<I32_PACKED_LEN> for i32 {
    fn pack(self) -> [Field; I32_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {
        fields[0] as i32
    }
}

impl Packable<I64_PACKED_LEN> for i64 {
    fn pack(self) -> [Field; I64_PACKED_LEN] {
        [self as Field]
    }

    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {
        fields[0] as i64
    }
}

impl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]
where
    T: Packable<M>,
{
    fn pack(self) -> [Field; N * M] {
        let mut result: [Field; N * M] = std::mem::zeroed();
        let mut serialized: [Field; M] = std::mem::zeroed();
        for i in 0..N {
            serialized = self[i].pack();
            for j in 0..M {
                result[i * M + j] = serialized[j];
            }
        }
        result
    }

    fn unpack(fields: [Field; N * M]) -> Self {
        let mut reader = crate::utils::reader::Reader::new(fields);
        let mut result: [T; N] = std::mem::zeroed();
        reader.read_struct_array::<T, M, N>(Packable::unpack, result)
    }
}

#[test]
fn test_u16_packing() {
    let a: u16 = 10;
    assert_eq(a, u16::unpack(a.pack()));
}

#[test]
fn test_i8_packing() {
    let a: i8 = -10;
    assert_eq(a, i8::unpack(a.pack()));
}

#[test]
fn test_i16_packing() {
    let a: i16 = -10;
    assert_eq(a, i16::unpack(a.pack()));
}

#[test]
fn test_i32_packing() {
    let a: i32 = -10;
    assert_eq(a, i32::unpack(a.pack()));
}

#[test]
fn test_i64_packing() {
    let a: i64 = -10;
    assert_eq(a, i64::unpack(a.pack()));
}
`},346:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",source:`use crate::traits::{Deserialize, Serialize};

global BOOL_SERIALIZED_LEN: u32 = 1;
global U8_SERIALIZED_LEN: u32 = 1;
global U16_SERIALIZED_LEN: u32 = 1;
global U32_SERIALIZED_LEN: u32 = 1;
global U64_SERIALIZED_LEN: u32 = 1;
global U128_SERIALIZED_LEN: u32 = 1;
global FIELD_SERIALIZED_LEN: u32 = 1;
global I8_SERIALIZED_LEN: u32 = 1;
global I16_SERIALIZED_LEN: u32 = 1;
global I32_SERIALIZED_LEN: u32 = 1;
global I64_SERIALIZED_LEN: u32 = 1;

impl Serialize<BOOL_SERIALIZED_LEN> for bool {
    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<BOOL_SERIALIZED_LEN> for bool {
    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {
        fields[0] as bool
    }
}

impl Serialize<U8_SERIALIZED_LEN> for u8 {
    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U8_SERIALIZED_LEN> for u8 {
    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {
        fields[0] as u8
    }
}

impl Serialize<U16_SERIALIZED_LEN> for u16 {
    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U16_SERIALIZED_LEN> for u16 {
    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {
        fields[0] as u16
    }
}

impl Serialize<U32_SERIALIZED_LEN> for u32 {
    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U32_SERIALIZED_LEN> for u32 {
    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {
        fields[0] as u32
    }
}

impl Serialize<U64_SERIALIZED_LEN> for u64 {
    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U64_SERIALIZED_LEN> for u64 {
    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {
        fields[0] as u64
    }
}

impl Serialize<U128_SERIALIZED_LEN> for u128 {
    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U128_SERIALIZED_LEN> for u128 {
    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {
        fields[0] as u128
    }
}

impl Serialize<FIELD_SERIALIZED_LEN> for Field {
    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {
        [self]
    }
}

impl Deserialize<FIELD_SERIALIZED_LEN> for Field {
    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {
        fields[0]
    }
}

impl Serialize<I8_SERIALIZED_LEN> for i8 {
    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<I8_SERIALIZED_LEN> for i8 {
    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {
        fields[0] as i8
    }
}

impl Serialize<I16_SERIALIZED_LEN> for i16 {
    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<I16_SERIALIZED_LEN> for i16 {
    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {
        fields[0] as i16
    }
}

impl Serialize<I32_SERIALIZED_LEN> for i32 {
    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<I32_SERIALIZED_LEN> for i32 {
    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {
        fields[0] as i32
    }
}

impl Serialize<I64_SERIALIZED_LEN> for i64 {
    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<I64_SERIALIZED_LEN> for i64 {
    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {
        fields[0] as i64
    }
}

impl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]
where
    T: Serialize<M>,
{
    fn serialize(self) -> [Field; N * M] {
        let mut result: [Field; N * M] = std::mem::zeroed();
        let mut serialized: [Field; M] = std::mem::zeroed();
        for i in 0..N {
            serialized = self[i].serialize();
            for j in 0..M {
                result[i * M + j] = serialized[j];
            }
        }
        result
    }
}

impl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]
where
    T: Deserialize<M>,
{
    fn deserialize(fields: [Field; N * M]) -> Self {
        let mut reader = crate::utils::reader::Reader::new(fields);
        let mut result: [T; N] = std::mem::zeroed();
        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)
    }
}

#[test]
fn test_u16_serialization() {
    let a: u16 = 10;
    assert_eq(a, u16::deserialize(a.serialize()));
}

#[test]
fn test_i8_serialization() {
    let a: i8 = -10;
    assert_eq(a, i8::deserialize(a.serialize()));
}

#[test]
fn test_i16_serialization() {
    let a: i16 = -10;
    assert_eq(a, i16::deserialize(a.serialize()));
}

#[test]
fn test_i32_serialization() {
    let a: i32 = -10;
    assert_eq(a, i32::deserialize(a.serialize()));
}

#[test]
fn test_i64_serialization() {
    let a: i64 = -10;
    assert_eq(a, i64::deserialize(a.serialize()));
}
`},362:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",source:`pub mod assert_array_appended;
pub mod assert_array_prepended;
pub mod assert_combined_array;
pub mod assert_combined_transformed_array;
pub mod assert_exposed_sorted_transformed_value_array;
pub mod assert_sorted_array;
pub mod assert_sorted_transformed_value_array;
pub mod assert_split_sorted_transformed_value_arrays;
pub mod assert_split_transformed_value_arrays;
pub mod get_sorted_result;
pub mod get_sorted_tuple;
pub mod sort_by;
pub mod sort_by_counter;

// Re-exports.
pub use assert_array_appended::{
    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,
    assert_array_appended_scoped,
};
pub use assert_array_prepended::assert_array_prepended;
pub use assert_combined_array::{assert_combined_array, combine_arrays};
pub use assert_combined_transformed_array::{
    assert_combined_transformed_array, combine_and_transform_arrays,
};
pub use assert_exposed_sorted_transformed_value_array::{
    assert_exposed_sorted_transformed_value_array,
    get_order_hints::{get_order_hints_asc, OrderHint},
};
pub use assert_sorted_array::assert_sorted_array;
pub use assert_sorted_transformed_value_array::{
    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,
};
pub use assert_split_sorted_transformed_value_arrays::{
    assert_split_sorted_transformed_value_arrays_asc,
    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},
};
pub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;
pub use get_sorted_result::{get_sorted_result, SortedResult};
pub use sort_by_counter::sort_by_counter_asc;

use crate::traits::{Empty, is_empty};

pub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(
    src: [Field; SRC_LEN],
    offset: u32,
) -> [Field; DST_LEN] {
    assert(offset + DST_LEN <= SRC_LEN, "offset too large");

    let mut dst: [Field; DST_LEN] = std::mem::zeroed();
    for i in 0..DST_LEN {
        dst[i] = src[i + offset];
    }

    dst
}

// Helper function to convert a validated array to BoundedVec.
// Important: Only use it for validated arrays: validate_array(array) should be true.
pub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>
where
    T: Empty + Eq,
{
    let len = array_length(array);
    BoundedVec::from_parts_unchecked(array, len)
}

// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element
// is not found, the function returns N as the index.
pub unconstrained fn find_index_hint<T, let N: u32, Env>(
    array: [T; N],
    find: fn[Env](T) -> bool,
) -> u32 {
    let mut index = N;
    for i in 0..N {
        // We check \`index == N\` to ensure that we only update the index if we haven't found a match yet.
        if (index == N) & find(array[i]) {
            index = i;
        }
    }
    index
}

// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,
// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is
// valid.
pub fn validate_array<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    let mut seen_empty = false;
    let mut length = 0;
    for i in 0..N {
        if is_empty(array[i]) {
            seen_empty = true;
        } else {
            assert(seen_empty == false, "invalid array");
            length += 1;
        }
    }
    length
}

// Helper function to count the number of non-empty elements in a validated array.
// Important: Only use it for validated arrays where validate_array(array) returns true,
// which ensures that:
// 1. All elements before the first empty element are non-empty
// 2. All elements after and including the first empty element are empty
// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements
pub fn array_length<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    // We get the length by checking the index of the first empty element.

    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness
    // of the element and non-emptiness of the previous element is checked below.
    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };
    if length != 0 {
        assert(!is_empty(array[length - 1]));
    }
    if length != N {
        assert(is_empty(array[length]));
    }
    length
}

// Returns the number of consecutive elements at the start of the array for which the predicate returns false.
// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.
pub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {
    let mut length = 0;
    let mut stop = false;
    for i in 0..N {
        if predicate(array[i]) {
            stop = true;
        } else {
            assert(
                stop == false,
                "matching element found after already encountering a non-matching element",
            );
            length += 1;
        }
    }
    length
}

pub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {
    let mut result = [array1[0]; N + M];
    for i in 1..N {
        result[i] = array1[i];
    }
    for i in 0..M {
        result[i + N] = array2[i];
    }
    result
}

/// This function assumes that \`array1\` and \`array2\` contain no more than N non-empty elements between them,
/// if this is not the case then elements from the end of \`array2\` will be dropped.
pub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]
where
    T: Empty + Eq,
{
    // Safety: we constrain this array below
    let result = unsafe { array_merge_helper(array1, array2) };
    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.
    let array1_len = array_length(array1);
    let mut add_from_left = true;
    for i in 0..N {
        add_from_left &= i != array1_len;
        if add_from_left {
            assert_eq(result[i], array1[i]);
        } else {
            assert_eq(result[i], array2[i - array1_len]);
        }
    }
    result
}

unconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]
where
    T: Empty + Eq,
{
    let mut result: [T; N] = [T::empty(); N];
    let mut i = 0;
    for elem in array1 {
        if !is_empty(elem) {
            result[i] = elem;
            i += 1;
        }
    }
    for elem in array2 {
        if !is_empty(elem) {
            result[i] = elem;
            i += 1;
        }
    }
    result
}

// Helper fn to create a subarray from a given array
pub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]
where
    T: Empty,
{
    assert(M + offset <= N, "Subarray length larger than array length");
    let mut result: [T; M] = [T::empty(); M];
    for i in 0..M {
        result[i] = array[offset + i];
    }
    result
}

pub fn check_permutation<T, let N: u32>(
    original_array: [T; N],
    permuted_array: [T; N],
    original_indexes: [u32; N],
)
where
    T: Eq + Empty,
{
    let mut seen_value = [false; N];
    for i in 0..N {
        let index = original_indexes[i];
        let original_value = original_array[index];
        assert(permuted_array[i].eq(original_value), "Invalid index");
        assert(!seen_value[index], "Duplicated index");
        seen_value[index] = true;
    }
}

// Helper function to find the index of the last element in an array, allowing empty elements.
// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]
// Nothing to do with validated arrays. Correctness constrained by padded_array_length.
pub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    let mut index = N;
    for i in 0..N {
        let j = N - i - 1;
        // We check \`index == N\` to ensure that we only update the index if we haven't found a match yet.
        if (index == N) & !is_empty(array[j]) {
            index = j;
        }
    }
    index
}

// Routine which returns the length of an array right padded by empty elements
// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).
// See smoke_validate_array_trailing for examples.
// Nothing to do with validated arrays. Correctness constrained by padded_array_length.
pub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    let index = find_last_value_index(array);
    if index == N {
        0
    } else {
        index + 1
    }
}

// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,
// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).
pub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    // Safety: this value is constrained in the below loop.
    let length = unsafe { unsafe_padded_array_length(array) };
    // Check the elt just before length is non-zero:
    if length != 0 {
        assert(!is_empty(array[length - 1]), "invalid right padded array");
    }
    // Check all beyond length are zero:
    let mut check_zero = false;
    for i in 0..N {
        check_zero |= i == length;
        if check_zero {
            assert(is_empty(array[i]), "invalid right padded array");
        }
    }
    length
}

// Helper function to check if an array is padded with a given value from a given index.
// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.
pub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool
where
    T: Eq,
{
    let mut is_valid = true;
    let mut should_check = false;
    for i in 0..N {
        should_check |= i == from_index;
        is_valid &= !should_check | (array[i] == padded_with);
    }
    is_valid
}

#[test]
fn smoke_validate_array() {
    let valid_array: [Field; 0] = [];
    assert(validate_array(valid_array) == 0);

    let valid_array = [0];
    assert(validate_array(valid_array) == 0);

    let valid_array = [3];
    assert(validate_array(valid_array) == 1);

    let valid_array = [1, 2, 3];
    assert(validate_array(valid_array) == 3);

    let valid_array = [1, 2, 3, 0];
    assert(validate_array(valid_array) == 3);

    let valid_array = [1, 2, 3, 0, 0];
    assert(validate_array(valid_array) == 3);
}

#[test]
fn smoke_validate_array_trailing() {
    let valid_array: [Field; 0] = [];
    assert(padded_array_length(valid_array) == 0);

    let valid_array = [0];
    assert(padded_array_length(valid_array) == 0);

    let valid_array = [3];
    assert(padded_array_length(valid_array) == 1);

    let valid_array = [1, 0, 3];
    assert(padded_array_length(valid_array) == 3);

    let valid_array = [1, 0, 3, 0];
    assert(padded_array_length(valid_array) == 3);

    let valid_array = [1, 2, 3, 0, 0];
    assert(padded_array_length(valid_array) == 3);

    let valid_array = [0, 0, 3, 0, 0];
    assert(padded_array_length(valid_array) == 3);
}

#[test(should_fail_with = "invalid array")]
fn smoke_validate_array_invalid_case0() {
    let invalid_array = [0, 1];
    let _ = validate_array(invalid_array);
}

#[test(should_fail_with = "invalid array")]
fn smoke_validate_array_invalid_case1() {
    let invalid_array = [1, 0, 0, 1, 0];
    let _ = validate_array(invalid_array);
}

#[test(should_fail_with = "invalid array")]
fn smoke_validate_array_invalid_case2() {
    let invalid_array = [0, 0, 0, 0, 1];
    let _ = validate_array(invalid_array);
}

#[test]
fn test_empty_array_length() {
    assert_eq(array_length([0]), 0);
    assert_eq(array_length([0, 0, 0]), 0);
}

#[test]
fn test_array_length() {
    assert_eq(array_length([123]), 1);
    assert_eq(array_length([123, 0, 0]), 1);
    assert_eq(array_length([123, 456]), 2);
    assert_eq(array_length([123, 456, 0]), 2);
}

#[test]
fn test_array_length_invalid_arrays() {
    // Result can be misleading (but correct) for invalid arrays.
    assert_eq(array_length([0, 0, 123]), 0);
    assert_eq(array_length([0, 123, 0]), 0);
    assert_eq(array_length([0, 123, 456]), 0);
    assert_eq(array_length([123, 0, 456]), 1);
}

#[test]
fn test_array_length_until() {
    let array = [11, 22, 33, 44, 55];
    assert_eq(array_length_until(array, |x| x == 55), 4);
    assert_eq(array_length_until(array, |x| x == 56), 5);
    assert_eq(array_length_until(array, |x| x > 40), 3);
    assert_eq(array_length_until(array, |x| x > 10), 0);
}

#[test(should_fail_with = "matching element found after already encountering a non-matching element")]
fn test_array_length_until_non_consecutive_fails() {
    let array = [1, 1, 0, 1, 0];
    let _ = array_length_until(array, |x| x == 0);
}

#[test(should_fail_with = "matching element found after already encountering a non-matching element")]
fn test_array_length_until_first_non_matching_fails() {
    let array = [1, 0, 0, 0, 0];
    let _ = array_length_until(array, |x| x == 1);
}

#[test]
unconstrained fn find_index_greater_than_min() {
    let values = [10, 20, 30, 40];
    let min = 22;
    let index = find_index_hint(values, |v: Field| min.lt(v));
    assert_eq(index, 2);
}

#[test]
unconstrained fn find_index_not_found() {
    let values = [10, 20, 30, 40];
    let min = 100;
    let index = find_index_hint(values, |v: Field| min.lt(v));
    assert_eq(index, 4);
}

#[test]
fn test_array_concat() {
    let array0 = [1, 2, 3];
    let array1 = [4, 5];
    let concatenated = array_concat(array0, array1);
    assert_eq(concatenated, [1, 2, 3, 4, 5]);
}

#[test]
fn check_permutation_basic_test() {
    let original_array = [1, 2, 3];
    let permuted_array = [3, 1, 2];
    let indexes = [2, 0, 1];
    check_permutation(original_array, permuted_array, indexes);
}

#[test(should_fail_with = "Duplicated index")]
fn check_permutation_duplicated_index() {
    let original_array = [0, 1, 0];
    let permuted_array = [1, 0, 0];
    let indexes = [1, 0, 0];
    check_permutation(original_array, permuted_array, indexes);
}

#[test(should_fail_with = "Invalid index")]
fn check_permutation_invalid_index() {
    let original_array = [0, 1, 2];
    let permuted_array = [1, 0, 0];
    let indexes = [1, 0, 2];
    check_permutation(original_array, permuted_array, indexes);
}

#[test]
fn test_array_padded_with() {
    let array = [11, 22, 33, 44, 44];
    assert_eq(array_padded_with(array, 0, 44), false);
    assert_eq(array_padded_with(array, 1, 44), false);
    assert_eq(array_padded_with(array, 2, 44), false);
    assert_eq(array_padded_with(array, 3, 44), true);
    assert_eq(array_padded_with(array, 4, 44), true);
    assert_eq(array_padded_with(array, 4, 33), false);
    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.
    assert_eq(array_padded_with(array, 0, 11), false);
}
`},365:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",source:`pub struct Reader<let N: u32> {
    data: [Field; N],
    offset: u32,
}

impl<let N: u32> Reader<N> {
    pub fn new(data: [Field; N]) -> Self {
        Self { data, offset: 0 }
    }

    pub fn read(&mut self) -> Field {
        let result = self.data[self.offset];
        self.offset += 1;
        result
    }

    pub fn read_u32(&mut self) -> u32 {
        self.read() as u32
    }

    pub fn read_bool(&mut self) -> bool {
        self.read() as bool
    }

    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {
        let mut result = [0; K];
        for i in 0..K {
            result[i] = self.data[self.offset + i];
        }
        self.offset += K;
        result
    }

    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {
        let result = deserialise(self.read_array());
        result
    }

    pub fn read_struct_array<T, let K: u32, let C: u32>(
        &mut self,
        deserialise: fn([Field; K]) -> T,
        mut result: [T; C],
    ) -> [T; C] {
        for i in 0..C {
            result[i] = self.read_struct(deserialise);
        }
        result
    }

    pub fn finish(self) {
        assert(self.offset == self.data.len(), "Reader did not read all data");
    }
}
`}},r={transpiled:!0,noir_version:e,name:n,functions:t,outputs:a,file_map:s};export{r as default,s as file_map,t as functions,n as name,e as noir_version,a as outputs,i as transpiled};
