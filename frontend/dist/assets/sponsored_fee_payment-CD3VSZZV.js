var oe=Object.defineProperty;var R=r=>{throw TypeError(r)};var ce=(r,e,t)=>e in r?oe(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var i=(r,e,t)=>ce(r,typeof e!="symbol"?e+"":e,t),K=(r,e,t)=>e.has(r)||R("Cannot "+t);var T=(r,e,t)=>(K(r,e,"read from private field"),t?t.call(r):e.get(r)),D=(r,e,t)=>e.has(r)?R("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),L=(r,e,t,s)=>(K(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t);import{aV as b,Z as ue,a_ as V,dk as le,be as de,F as h,a as I,H as C,E as F,f as c,b0 as H,b1 as k,dl as Z,s as he,bp as fe,dm as pe,a1 as ge,a4 as $,aQ as j,cd as Q,o as z,ce as v,ae as E,P as _,au as Y,aa as X,bj as J,dn as ye,K as ee,B as y,dp as q,aR as te,dq as se,d7 as me,a5 as we,aK as Ae,aJ as ne,aF as xe,D as O,r as U,G as Ce}from"./wait_for_proven-lOMtifCd.js";import"./index-oV6Kx-_Y.js";function G(r){const e=r.reduce((n,a)=>n+a.length,0),t=new Uint8Array(e);let s=0;for(const n of r)t.set(n,s),s+=n.length;return t}var S={};class Ke{async computePublicKey(e){const t=await b.initSingleton(S.BB_WASM_PATH),[s]=t.getWasm().callWasmExport("schnorr_compute_public_key",[e.toBuffer()],[64]);return ue.fromBuffer(Buffer.from(s))}async constructSignature(e,t){const s=await b.initSingleton(S.BB_WASM_PATH),n=G([V(e.length),e]),[a,o]=s.getWasm().callWasmExport("schnorr_construct_signature",[n,t.toBuffer()],[32,32]);return new le(Buffer.from([...a,...o]))}async verifySignature(e,t,s){const n=await b.initSingleton(S.BB_WASM_PATH),a=G([V(e.length),e]),[o]=n.getWasm().callWasmExport("schnorr_verify_signature",[a,t.toBuffer(),s.s,s.e],[1]);return o[0]===1}}function De(r,e){return de([r,e.toField()])}class w{constructor(e,t,s,n,a,o,u){i(this,"name");i(this,"to");i(this,"selector");i(this,"type");i(this,"isStatic");i(this,"args");i(this,"returnTypes");this.name=e,this.to=t,this.selector=s,this.type=n,this.isStatic=a,this.args=o,this.returnTypes=u}static getFields(e){return[e.name,e.to,e.selector,e.type,e.isStatic,e.args,e.returnTypes]}static from(e){return new w(...w.getFields(e))}static empty(){return{name:"",to:C.ZERO,selector:I.empty(),type:h.PUBLIC,isStatic:!1,args:[],returnTypes:[]}}}class f{constructor(e,t){i(this,"sender");i(this,"chainId");this.sender=e,this.chainId=t}static empty(){return new f(F.ZERO,0)}toFields(){return[this.sender.toField(),new c(BigInt(this.chainId))]}toBuffer(){return H(this.sender,this.chainId)}static fromBuffer(e){const t=k.asReader(e),s=t.readObject(F),n=t.readNumber();return new f(s,n)}static random(){return new f(F.random(),Z(1e3))}}class p{constructor(e,t){i(this,"recipient");i(this,"version");this.recipient=e,this.version=t}static empty(){return new p(C.ZERO,0)}toFields(){return[this.recipient.toField(),new c(BigInt(this.version))]}toBuffer(){return H(this.recipient,this.version)}static fromBuffer(e){const t=k.asReader(e),s=C.fromBuffer(t),n=t.readNumber();return new p(s,n)}static async random(){return new p(await C.random(),Z(1e3))}}class x{constructor(e,t,s,n,a){i(this,"sender");i(this,"recipient");i(this,"content");i(this,"secretHash");i(this,"index");this.sender=e,this.recipient=t,this.content=s,this.secretHash=n,this.index=a}toFields(){return[...this.sender.toFields(),...this.recipient.toFields(),this.content,this.secretHash,this.index]}toBuffer(){return H(this.sender,this.recipient,this.content,this.secretHash,this.index)}hash(){return he(this.toFields())}static fromBuffer(e){const t=k.asReader(e),s=t.readObject(f),n=t.readObject(p),a=c.fromBuffer(t),o=c.fromBuffer(t),u=c.fromBuffer(t);return new x(s,n,a,o,u)}toString(){return fe(this.toBuffer())}static fromString(e){const t=Buffer.from(e,"hex");return x.fromBuffer(t)}static empty(){return new x(f.empty(),p.empty(),c.ZERO,c.ZERO,c.ZERO)}static async random(){return new x(f.random(),await p.random(),c.random(),c.random(),c.random())}}async function Le(r,e,t,s){const n=await r.getL1ToL2MessageMembershipWitness("latest",t);if(!n)throw new Error(`No L1 to L2 message found for message hash ${t.toString()}`);const[a,o]=n,u=await pe(e,t,s),[l]=await r.findLeavesIndexes("latest",ge.NULLIFIER_TREE,[u]);if(l!==void 0)throw new Error(`No non-nullified L1 to L2 message found for message hash ${t.toString()}`);return[a,o]}var Ve=function(r){return r[r.EQ=1]="EQ",r[r.NEQ=2]="NEQ",r[r.LT=3]="LT",r[r.LTE=4]="LTE",r[r.GT=5]="GT",r[r.GTE=6]="GTE",r}({});async function ze(r,e,t){const{publicKeys:s}=await $(e),{constructorName:n,constructorArgs:a}=await r.getDeploymentFunctionAndArgs()??{constructorName:void 0,constructorArgs:void 0},o=await r.getContractArtifact();return(await j(o,{constructorArtifact:n,constructorArgs:a,salt:t,publicKeys:s})).address}const W=4,Ee=2;class P{constructor(e,t,s,n){i(this,"encodedFunctionCalls");i(this,"hashedArguments");i(this,"generatorIndex");i(this,"nonce");this.encodedFunctionCalls=e,this.hashedArguments=t,this.generatorIndex=s,this.nonce=n}get function_calls(){return this.encodedFunctionCalls}hash(){return Q(this.toFields(),this.generatorIndex)}functionCallsToFields(){return this.encodedFunctionCalls.flatMap(e=>[e.args_hash,e.function_selector,e.target_address,new c(e.is_public),new c(e.is_static)])}static async fromFunctionCalls(e){const t=await B(e);return new M(t.encodedFunctionCalls,t.hashedArguments,0,c.random())}static async fromAppExecution(e,t=c.random()){if(e.length>W)throw new Error(`Expected at most ${W} function calls, got ${e.length}`);const s=z(e,w.empty(),W),n=await B(s);return new M(n.encodedFunctionCalls,n.hashedArguments,v.SIGNATURE_PAYLOAD,t)}static async fromFeeCalls(e,t){const s=z(e,w.empty(),Ee),n=await B(s);return new Ie(n.encodedFunctionCalls,n.hashedArguments,v.FEE_PAYLOAD,c.random(),t)}}class M extends P{constructor(e,t,s,n){super(e,t,s,n)}toFields(){return[...this.functionCallsToFields(),this.nonce]}}var m;class Ie extends P{constructor(t,s,n,a,o){super(t,s,n,a);D(this,m);L(this,m,o)}toFields(){return[...this.functionCallsToFields(),this.nonce,new c(T(this,m))]}get is_fee_payer(){return T(this,m)}}m=new WeakMap;async function Pe(r,e){return Q([await r.hash(),await e.hash()],v.COMBINED_PAYLOAD)}async function B(r){const e=[];for(const s of r){const n=s.type===h.PUBLIC?await E.fromCalldata([s.selector.toField(),...s.args]):await E.fromArgs(s.args);e.push(n)}return{encodedFunctionCalls:r.map((s,n)=>({args_hash:e[n].hash,function_selector:s.selector.toField(),target_address:s.to.toField(),is_public:s.type==h.PUBLIC,is_static:s.isStatic})),hashedArguments:e}}class Te{constructor(e,t,s=_.MultiCallEntrypoint){i(this,"chainId");i(this,"version");i(this,"address");this.chainId=e,this.version=t,this.address=s}async createTxExecutionRequest(e,t){const{calls:s,authWitnesses:n,capsules:a,extraHashedArgs:o}=e,{calls:u,authWitnesses:l,extraHashedArgs:d}=await t.paymentMethod.getExecutionPayload(t.gasSettings),g=await P.fromAppExecution(s.concat(u)),A=this.getEntrypointAbi(),N=await E.fromArgs(Y(A,[g])),ie=X.from({firstCallArgsHash:N.hash,origin:this.address,functionSelector:await I.fromNameAndParameters(A.name,A.parameters),txContext:new J(this.chainId,this.version,t.gasSettings),argsOfCalls:[...g.hashedArguments,N,...o,...d],authWitnesses:[...l,...n],capsules:a,salt:c.random()});return Promise.resolve(ie)}getEntrypointAbi(){return{name:"entrypoint",isInitializer:!1,functionType:"private",isInternal:!1,isStatic:!1,parameters:[{name:"app_payload",type:{kind:"struct",path:"authwit::entrypoint::app::AppPayload",fields:[{name:"function_calls",type:{kind:"array",length:4,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}}]},visibility:"public"}],returnTypes:[],errorTypes:{}}}}class be{constructor(e,t,s,n,a){i(this,"artifact");i(this,"authWitnessProvider");i(this,"feePaymentNameOrArtifact");i(this,"accountAddress");i(this,"paymentMethod");this.artifact=e,this.authWitnessProvider=t,this.feePaymentNameOrArtifact=s,this.accountAddress=n,this.paymentMethod=a}getAsset(){return this.paymentMethod.getAsset()}async getExecutionPayload(e){const t=await M.fromAppExecution([]),{calls:s,authWitnesses:n}=await this.paymentMethod.getExecutionPayload(e),o=(await this.paymentMethod.getFeePayer(e)).equals(this.accountAddress),u=await P.fromFeeCalls(s,o),l=[t,u,!1],d=typeof this.feePaymentNameOrArtifact=="string"?ye(this.artifact,this.feePaymentNameOrArtifact):this.feePaymentNameOrArtifact,g=new w(d.name,this.accountAddress,await I.fromNameAndParameters(d.name,d.parameters),d.functionType,d.isStatic,Y(d,l),d.returnTypes),A=await this.authWitnessProvider.createAuthWit(await Pe(t,u));return new ee([g],[A,...n],[],[...t.hashedArguments,...u.hashedArguments])}getFeePayer(e){return this.paymentMethod.getFeePayer(e)}}const Fe=async(r,e)=>{const t=e.chainId,s=e.version;if("caller"in r){const n=r.action instanceof y?(await r.action.request()).calls[0]:r.action;return q(n.to,t,s,await Se(r.caller,n))}else{const n=Buffer.isBuffer(r.innerHash)?c.fromBuffer(r.innerHash):r.innerHash;return q(r.consumer,t,s,n)}},Se=async(r,e)=>te([r.toField(),e.selector.toField(),await se(e.args)]),We=async(r,e)=>(e=e instanceof y?(await e.request()).calls[0]:e,te([r.toField(),e.selector.toField(),await se(e.args)]));class re{constructor(e){i(this,"pxe");this.pxe=e}getAddress(){return this.getCompleteAddress().address}registerSender(e){return this.pxe.registerSender(e)}getSenders(){return this.pxe.getSenders()}async removeSender(e){await this.pxe.removeSender(e)}registerContract(e){return this.pxe.registerContract(e)}registerContractClass(e){return this.pxe.registerContractClass(e)}updateContract(e,t){return this.pxe.updateContract(e,t)}proveTx(e,t){return this.pxe.proveTx(e,t)}profileTx(e,t,s,n){return this.pxe.profileTx(e,t,s,n)}simulateTx(e,t,s,n,a){return this.pxe.simulateTx(e,t,s,n,a)}sendTx(e){return this.pxe.sendTx(e)}getCurrentBaseFees(){return this.pxe.getCurrentBaseFees()}simulateUtility(e,t,s,n,a){return this.pxe.simulateUtility(e,t,s,n,a)}getNodeInfo(){return this.pxe.getNodeInfo()}getPXEInfo(){return this.pxe.getPXEInfo()}getContractClassMetadata(e,t=!1){return this.pxe.getContractClassMetadata(e,t)}getContractMetadata(e){return this.pxe.getContractMetadata(e)}getTxReceipt(e){return this.pxe.getTxReceipt(e)}getPrivateEvents(e,t,s,n,a=[this.getCompleteAddress().address]){return this.pxe.getPrivateEvents(e,t,s,n,a)}getPublicEvents(e,t,s){return this.pxe.getPublicEvents(e,t,s)}}class Be extends re{constructor(t,s){super(t);i(this,"account");this.account=s}createTxExecutionRequest(t,s,n){return this.account.createTxExecutionRequest(t,s,n)}getChainId(){return this.account.getChainId()}getVersion(){return this.account.getVersion()}async createAuthWit(t){let s;return Buffer.isBuffer(t)?s=c.fromBuffer(t):t instanceof c?s=t:s=await this.getMessageHash(t),this.account.createAuthWit(s)}async setPublicAuthWit(t,s){let n;return Buffer.isBuffer(t)?n=c.fromBuffer(t):t instanceof c?n=t:n=await this.getMessageHash(t),new y(this,_.AuthRegistry,this.getSetAuthorizedAbi(),[n,s])}async getInnerHashAndConsumer(t){if("caller"in t&&"action"in t){const s=t.action instanceof y?(await t.action.request()).calls[0]:t.action;return{innerHash:await We(t.caller,s),consumer:s.to}}else if(Buffer.isBuffer(t.innerHash))return{innerHash:c.fromBuffer(t.innerHash),consumer:t.consumer};return{innerHash:t.innerHash,consumer:t.consumer}}getMessageHash(t){const s=this.getChainId(),n=this.getVersion();return Fe(t,{chainId:s,version:n})}async lookupValidity(t,s,n){const{innerHash:a,consumer:o}=await this.getInnerHashAndConsumer(s),u=await this.getMessageHash(s),l={isValidInPrivate:!1,isValidInPublic:!1};try{l.isValidInPrivate=await new y(this,t,this.getLookupValidityAbi(),[o,a]).simulate({authWitnesses:[n]})}catch{}return l.isValidInPublic=await new y(this,_.AuthRegistry,this.getIsConsumableAbi(),[t,u]).simulate(),l}getCompleteAddress(){return this.account.getCompleteAddress()}getAddress(){return this.getCompleteAddress().address}getSetAuthorizedAbi(){return{name:"set_authorized",isInitializer:!1,functionType:h.PUBLIC,isInternal:!0,isStatic:!1,parameters:[{name:"message_hash",type:{kind:"field"},visibility:"private"},{name:"authorize",type:{kind:"boolean"},visibility:"private"}],returnTypes:[],errorTypes:{}}}getLookupValidityAbi(){return{name:"lookup_validity",isInitializer:!1,functionType:h.UTILITY,isInternal:!1,isStatic:!1,parameters:[{name:"message_hash",type:{kind:"field"},visibility:"private"}],returnTypes:[{kind:"boolean"}],errorTypes:{}}}getIsConsumableAbi(){return{name:"utility_is_consumable",isInitializer:!1,functionType:h.UTILITY,isInternal:!1,isStatic:!1,parameters:[{name:"address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},visibility:"private"},{name:"message_hash",type:{kind:"field"},visibility:"private"}],returnTypes:[{kind:"boolean"}],errorTypes:{}}}}class ve extends Be{constructor(t,s,n,a){super(t,s);i(this,"secretKey");i(this,"salt");this.secretKey=n,this.salt=a}getSecretKey(){return this.secretKey}async getEncryptionSecret(){return me(await this.getCompleteAddress().getPreaddress(),we(this.getSecretKey()))}}class _e{constructor(e,t){i(this,"chainId");i(this,"rollupVersion");this.chainId=e,this.rollupVersion=t}async createTxExecutionRequest(e,t,s){if(s.nonce||s.cancellable!==void 0)throw new Error("TxExecutionOptions are not supported in DefaultEntrypoint");const{calls:n,authWitnesses:a,capsules:o,extraHashedArgs:u}=e;if(n.length>1)throw new Error(`Expected a single call, got ${n.length}`);const l=n[0],d=[await E.fromArgs(l.args)];if(l.type!==h.PRIVATE)throw new Error("Public entrypoints are not allowed");return new X(l.to,l.selector,d[0].hash,new J(this.chainId,this.rollupVersion,t.gasSettings),[...d,...u],a,o)}}class Me extends re{constructor(t,s){super(t);i(this,"entrypoint");this.entrypoint=s}async createTxExecutionRequest(t,s,n){let a=this.entrypoint;if(!a){const{l1ChainId:o,rollupVersion:u}=await this.pxe.getNodeInfo();a=new _e(o,u)}return a.createTxExecutionRequest(t,s,n)}getChainId(){throw new Error("SignerlessWallet: Method getChainId not implemented.")}getVersion(){throw new Error("SignerlessWallet: Method getVersion not implemented.")}getPublicKeysHash(){throw new Error("SignerlessWallet: Method getPublicKeysHash not implemented.")}getCompleteAddress(){throw new Error("SignerlessWallet: Method getCompleteAddress not implemented.")}createAuthWit(t){throw new Error("SignerlessWallet: Method createAuthWit not implemented.")}}class He extends Ae{constructor(t,s,n){super(t,s);i(this,"getWalletPromise");this.getWalletPromise=n}async getWallet(t){return(await this.wait(t)).wallet}async wait(t=ne){const s=await super.wait(t),n=await this.getWalletPromise;return{...s,wallet:n}}}class ae{constructor(e,t,s,n,a){i(this,"pxe");i(this,"secretKey");i(this,"accountContract");i(this,"instance");i(this,"salt");this.pxe=e,this.secretKey=t,this.accountContract=s,this.instance=n,this.salt=a}static async create(e,t,s,n){const{publicKeys:a}=await $(t);n=n!==void 0?new c(n):c.random();const{constructorName:o,constructorArgs:u}=await s.getDeploymentFunctionAndArgs()??{constructorName:void 0,constructorArgs:void 0},l=await s.getContractArtifact(),d=await j(l,{constructorArtifact:o,constructorArgs:u,salt:n,publicKeys:a});return new ae(e,t,s,d,n)}getPublicKeys(){return this.instance.publicKeys}getPublicKeysHash(){return this.getPublicKeys().hash()}async getAccount(){const e=await this.pxe.getNodeInfo(),t=await this.getCompleteAddress();return this.accountContract.getInterface(t,e)}getCompleteAddress(){return xe.fromSecretKeyAndInstance(this.secretKey,this.instance)}getAddress(){return this.instance.address}getInstance(){return this.instance}async getWallet(){const e=await this.getAccount();return new ve(this.pxe,e,this.secretKey,this.salt)}async register(){return await this.pxe.registerContract({artifact:await this.accountContract.getContractArtifact(),instance:this.getInstance()}),await this.pxe.registerAccount(this.secretKey,(await this.getCompleteAddress()).partialAddress),this.getWallet()}async getDeployMethod(e){const t=await this.accountContract.getContractArtifact();if(!await this.isDeployable())throw new Error(`Account contract ${t.name} does not require deployment.`);const s=await this.getCompleteAddress();await this.pxe.registerAccount(this.secretKey,s.partialAddress);const{constructorName:n,constructorArgs:a}=await this.accountContract.getDeploymentFunctionAndArgs()??{constructorName:void 0,constructorArgs:void 0};if(e){const d=await this.getWallet();return new O(this.getPublicKeys(),e,t,g=>U.at(g,t,d),a,n)}const{l1ChainId:o,rollupVersion:u}=await this.pxe.getNodeInfo(),l=new Me(this.pxe,new Te(o,u));return new O(this.getPublicKeys(),l,t,d=>U.at(d,t,l),a,n)}async getSelfPaymentMethod(e){const t=await this.accountContract.getContractArtifact(),s=await this.getWallet(),n=s.getAddress();return new be(t,s,"entrypoint",n,e??new Ce(n))}deploy(e){let t;const s=this.getDeployMethod(e==null?void 0:e.deployWallet).then(n=>{var a;if(t=n,!(e!=null&&e.deployWallet)&&(e!=null&&e.fee))return this.getSelfPaymentMethod((a=e==null?void 0:e.fee)==null?void 0:a.paymentMethod)}).then(n=>{let a=e==null?void 0:e.fee;return n&&(a={...e==null?void 0:e.fee,paymentMethod:n}),t.send({contractAddressSalt:new c(this.salt),skipClassRegistration:(e==null?void 0:e.skipClassRegistration)??!0,skipPublicDeployment:(e==null?void 0:e.skipPublicDeployment)??!0,skipInitialization:(e==null?void 0:e.skipInitialization)??!1,universalDeploy:!0,fee:a})}).then(n=>n.getTxHash());return new He(this.pxe,s,this.getWallet())}async waitSetup(e=ne){return await(await this.isDeployable()?this.deploy(e).wait(e):this.register()),this.getWallet()}async isDeployable(){return await this.accountContract.getDeploymentFunctionAndArgs()!==void 0}}class qe{constructor(e){i(this,"paymentContract");this.paymentContract=e}getAsset(){throw new Error("Asset is not required for sponsored fpc.")}getFeePayer(){return Promise.resolve(this.paymentContract)}async getExecutionPayload(){return new ee([{name:"sponsor_unconditionally",to:this.paymentContract,selector:await I.fromSignature("sponsor_unconditionally()"),type:h.PRIVATE,isStatic:!1,args:[],returnTypes:[]}],[],[])}}export{Be as A,Ve as C,_e as D,P as E,w as F,x as L,Ke as S,p as a,f as b,ae as c,De as d,qe as e,Fe as f,ze as g,We as h,ve as i,Me as j,G as k,Pe as l,Le as m};
