var Fl=Object.defineProperty;var Lr=n=>{throw TypeError(n)};var ql=(n,e,t)=>e in n?Fl(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var l=(n,e,t)=>ql(n,typeof e!="symbol"?e+"":e,t),Fs=(n,e,t)=>e.has(n)||Lr("Cannot "+t);var u=(n,e,t)=>(Fs(n,e,"read from private field"),t?t.call(n):e.get(n)),w=(n,e,t)=>e.has(n)?Lr("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),z=(n,e,t,s)=>(Fs(n,e,"write to private field"),s?s.call(n,t):e.set(n,t),t),v=(n,e,t)=>(Fs(n,e,"access private method"),t);import{aT as Wl,aU as Ml,aV as ln,aW as en,aX as qt,aY as ys,aZ as R,f,a_ as qs,a$ as Rl,b0 as I,b1 as B,an as Wt,b2 as Fi,b3 as _e,b4 as Vl,b5 as Ja,b6 as ot,b7 as qi,c as V,b8 as Yl,b9 as Gl,ba as Zl,bb as Sr,ab as fn,bc as Kl,bd as se,be as wn,bf as Wi,Q as Jl,P as Ce,bg as Mi,bh as Ri,bi as Ul,aA as Be,ae as Vi,au as Yi,aa as Ql,bj as Ua,a as De,a7 as Gi,bk as Zi,bl as Ki,E as Ji,bm as $l,bn as Hr,bo as Xr,bp as Qa,bq as vs,br as le,bs as ws,bt as Te,bu as At,bv as xn,bw as _a,bx as Rn,by as pa,bz as xs,bA as ha,bB as ma,bC as ga,bD as Qn,bE as G,bF as Qt,bG as As,bH as Ui,bI as $a,bJ as ec,bK as Cr,bL as Dr,Y as as,bM as Qi,bN as tc,bO as $i,q as nc,bP as ba,bQ as cs,H as E,bR as jr,bS as er,bT as _n,bU as ds,bV as ce,bW as Ke,bX as de,bY as Mt,W as re,bZ as ya,b_ as va,b$ as Yt,c0 as sc,c1 as ne,c2 as Ir,c3 as eo,c4 as An,c5 as tr,c6 as to,c7 as Pn,o as no,_ as cn,c8 as Ds,c9 as Ps,a4 as ac,aF as us,Z as Je,ca as Br,cb as rc,cc as so,cd as ic,ce as oc,cf as Sn,V as lc,a1 as Pe,at as cc,cg as dc,ch as uc,as as ao,ci as fc,cj as nr,ck as sr,cl as _c,T as U,cm as pc,cn as ro,co as io,cp as hc,al as ks,cq as mc,cr as gc,cs as Fr,F as lt,ct as zs,cu as bc,J as wa,cv as yc,cw as vc,cx as wc,cy as xc,cz as Ac,cA as Pc,cB as kc,cC as zc,af as Nc,I as Oc,cD as Tc,cE as Ec,cF as Lc,cG as Sc,cH as Hc,cI as Xc,cJ as Cc,cK as Dc,cL as jc,cM as oo,cN as Ic,cO as Bc,cP as Fc,cQ as lo,cR as qc,cS as Wc,cT as Mc,cU as Rc,cV as Vc,cW as Yc,cX as Gc,cY as Zc,x as Kc,cZ as co,c_ as Jc,c$ as Uc,d0 as uo,d1 as Qc,d2 as $c,d3 as ed,d4 as td,d5 as qr,d6 as nd,d7 as sd,g as ad,d as rd,e as id,aD as od,d8 as Wr,aE as ld,k as dn,d9 as Mr,da as Rr,db as cd,dc as Vr,aj as dd,dd as ud,aI as fd,de as _d,df as pd,aQ as xa,dg as hd,dh as md,a5 as gd,aS as bd,di as yd,dj as vd}from"./wait_for_proven-lOMtifCd.js";import{b as rs,_ as p,u as Ws}from"./index-oV6Kx-_Y.js";import{k as Ms,E as Yr,l as wd,c as fo,S as _o,d as xd,C as tn,m as po,g as Ad,e as Gr}from"./sponsored_fee_payment-CD3VSZZV.js";class Rs extends Error{constructor(e){super(e)}}function Pd(n){const e=new DataView(n.buffer,n.byteOffset,n.byteLength);let t=0;const s=n.byteLength>>>2,a=new Array(s);for(let r=0;r<s;r++)a[r]=e.getUint32(t,!1),t+=4;return a}function Zr(n,e,t){const s=[];for(let a=0;a<n.length;a++){const r=n[a],i=e[a]||Buffer.from([]),o=t[a]||Buffer.from([]),c=`unknown_wasm_${a}`;s.push({bytecode:r,witness:i,vk:o,functionName:c})}return new Ml({useRecords:!1}).pack(s)}class Kr{constructor(e,t={threads:1}){this.acirBuf=e,this.options=t}async instantiate(){if(!this.api){const e=await Wl.new(this.options);await e.initSRSClientIVC(),this.api=e}}async prove(e,t=[]){if(t.length!==0&&this.acirBuf.length!==e.length)throw new Rs("Witness and bytecodes must have the same stack depth!");if(t.length!==0&&t.length!==e.length)throw new Rs("Witness and VKs must have the same stack depth!");await this.instantiate();const s=Zr(this.acirBuf,e,t),a=await this.api.acirProveAztecClient(s),[r,i]=a;if(!await this.verify(r,i))throw new Rs("Failed to verify the private (ClientIVC) transaction proof!");return a}async verify(e,t){return await this.instantiate(),this.api.acirVerifyAztecClient(e,t)}async gates(){await this.instantiate();const e=Zr(this.acirBuf,[],[]),t=await this.api.acirGatesAztecClient(e);return Pd(t)}async destroy(){this.api&&await this.api.destroy()}}var Jr={};class kd{async encryptBufferCBC(e,t,s){const r=16-e.length%16,i=rs.Buffer.alloc(r);i.fill(r);const o=rs.Buffer.concat([e,i]),c=await ln.initSingleton(Jr.BB_WASM_PATH);return rs.Buffer.from(c.aesEncryptBufferCbc(new en(o),new en(t),new en(s),o.length))}async decryptBufferCBCKeepPadding(e,t,s){const a=await ln.initSingleton(Jr.BB_WASM_PATH);return rs.Buffer.from(a.aesDecryptBufferCbc(new en(e),new en(t),new en(s),e.length))}async decryptBufferCBC(e,t,s){const a=await this.decryptBufferCBCKeepPadding(e,t,s),r=a[a.length-1];return a.subarray(0,a.length-r)}}class In{constructor(e,t,s){l(this,"r");l(this,"s");l(this,"v");if(this.r=e,this.s=t,this.v=s,e.length!=32)throw new Error(`Invalid length of 'r' in ECDSA signature. Expected 32, got ${t.length}`);if(t.length!=32)throw new Error(`Invalid length of 's' in ECDSA signature. Expected 32, got ${e.length}`);if(s.length!=1)throw new Error(`Invalid length of 'v' in ECDSA signature. Expected 1, got ${s.length}`)}toBuffer(){return Buffer.concat([this.r,this.s,this.v])}static fromBuffer(e){return new In(e.subarray(0,32),e.subarray(32,64),e.subarray(64,65))}static fromBigInts(e,t,s){return new In(qt(e,32),qt(t,32),Buffer.from([s]))}static random(){return new In(ys(32),ys(32),Buffer.from([27]))}toString(){return`0x${this.toBuffer().toString("hex")}`}toFields(e=!1){const t=this.toBuffer(),s=Buffer.alloc(32),a=Buffer.alloc(32),r=Buffer.alloc(32);return t.copy(s,1,0,31),t.copy(a,1,31,62),t.copy(r,1,62,e?65:64),R([s,a,r],f.fromBuffer)}}var is={};class ho{constructor(e="secp256k1"){l(this,"curve");this.curve=e}async computePublicKey(e){const t=await ln.initSingleton(is.BB_WASM_PATH),[s]=t.getWasm().callWasmExport(`ecdsa_${this.curve==="secp256r1"?"r":""}_compute_public_key`,[e],[64]);return Buffer.from(s)}async constructSignature(e,t){const s=await ln.initSingleton(is.BB_WASM_PATH),a=Ms([qs(e.length),e]),[r,i,o]=s.getWasm().callWasmExport(`ecdsa_${this.curve==="secp256r1"?"r":""}_construct_signature_`,[a,t],[32,32,1]);return new In(Buffer.from(r),Buffer.from(i),Buffer.from(o))}async recoverPublicKey(e,t){const s=await ln.initSingleton(is.BB_WASM_PATH),a=Ms([qs(e.length),e]),[r]=s.getWasm().callWasmExport(`ecdsa_${this.curve==="secp256r1"?"r":""}_recover_public_key_from_signature_`,[a,t.r,t.s,t.v],[64]);return Buffer.from(r)}async verifySignature(e,t,s){const a=await ln.initSingleton(is.BB_WASM_PATH),r=Ms([qs(e.length),e]),[i]=a.getWasm().callWasmExport(`ecdsa_${this.curve==="secp256r1"?"r":""}_verify_signature_`,[r,t,s.r,s.s,s.v],[1]);return i[0]===1}}class ee{constructor(e,t,s){l(this,"leafIndex");l(this,"siblingPath");this.leafIndex=t,this.siblingPath=s,Rl(this,"siblingPath",e)}toBuffer(){return I(qt(this.leafIndex,32),...this.siblingPath)}static random(e){return new ee(e,0n,Array(e).fill(0).map(()=>f.random()))}static empty(e,t=0n){const s=Array(e).fill(0).map(()=>f.ZERO);return new ee(e,t,s)}static fromBufferArray(e,t){return new ee(t.length,e,t.map(s=>f.fromBuffer(s)))}static fromBuffer(e,t){const s=B.asReader(e),a=Wt(s.readBytes(32)),r=s.readArray(t,f);return new ee(t,a,r)}static deserializer(e){return{fromBuffer:t=>{const s=B.asReader(t),a=Wt(s.readBytes(32)),r=s.readArray(e,f);return new ee(e,a,r)}}}static fromSiblingPath(e,t){return new ee(t.pathSize,e,t.toFields())}}class zd extends Fi{constructor(t,s,a){super(t,s);l(this,"leafPreimages");this.leafPreimages=a}getLowLeaf(t){let s;if(this.leafPreimages.forEach(a=>{a.getKey()<t&&(a.getNextKey()>t||a.getNextKey()==BigInt(0))&&(s=a)}),!s)throw new Error(`Couldn't find low leaf for ${t}`);return s}getMembershipWitness(t){const s=Buffer.isBuffer(t)?this.getIndex(t):t,a=this.getSiblingPath(s);return new ee(this.height,BigInt(s),_e(a.map(f.fromBuffer),this.height))}}class ar{constructor(e,t,s,a){l(this,"height");l(this,"zeroHashes");l(this,"hasher");l(this,"factory");this.height=e,this.zeroHashes=t,this.hasher=s,this.factory=a}static async create(e,t,s,a=Buffer.alloc(32)){const r=[a];for(let i=0;i<e;i++)r.push(await t.hash(r[i],r[i]));return new ar(e,r,t,s)}async computeTree(e){e.find(o=>Wt(o)==BigInt(0))||(e=[Buffer.alloc(32),...e]);const t=e.map((o,c)=>({value:o,index:c})).sort((o,c)=>Number(Wt(c.value)-Wt(o.value))),a=t.map((o,c)=>({leaf:this.factory.fromBuffer(Buffer.concat([o.value,...c==0?[Buffer.alloc(32),Buffer.alloc(32)]:[t[c-1].value,Vl(t[c-1].index,32)]])),index:o.index})).sort((o,c)=>o.index-c.index).map(o=>o.leaf);let r=await Promise.all(a.map(o=>this.hasher.hashInputs(o.toHashInputs()))),i=r.slice();for(let o=0;o<this.height;++o){const c=2**(this.height-o),d=[];for(let _=0;_<r.length/2;++_){const m=r[_*2],h=r[_*2+1]||this.zeroHashes[o];d[_]=await this.hasher.hash(m,h)}i=i.concat(new Array(c-r.length).fill(this.zeroHashes[o]),d),r=d}return new zd(this.height,i,a)}async computeTreeRoot(e=[]){if(e.length===0)return this.zeroHashes[this.zeroHashes.length-1];e=e.slice();for(let t=0;t<this.height;++t){let s=0;for(;s<e.length/2;++s){const a=e[s*2],r=e[s*2+1]||this.zeroHashes[t];e[s]=await this.hasher.hash(a,r)}e=e.slice(0,s)}return e[0]}}class Pt{constructor(e,t,s){l(this,"address");l(this,"nextAddress");l(this,"nextIndex");this.address=e,this.nextAddress=t,this.nextIndex=s}static get schema(){return Ja({address:ot.Fr,nextAddress:ot.Fr,nextIndex:ot.BigInt}).transform(({address:e,nextAddress:t,nextIndex:s})=>new Pt(e,t,s))}getKey(){return this.address.toBigInt()}getNextKey(){return this.nextAddress.toBigInt()}getNextIndex(){return this.nextIndex}asLeaf(){return new Ns(this.address)}toBuffer(){return Buffer.concat(this.toHashInputs())}toHashInputs(){return[Buffer.from(this.address.toBuffer()),Buffer.from(this.nextAddress.toBuffer())]}toFields(){return[this.address,this.nextAddress,new f(this.nextIndex)]}static random(){return new Pt(f.random(),f.random(),BigInt(Math.floor(Math.random()*1e3)%qi))}static empty(){return new Pt(f.ZERO,f.ZERO,0n)}static fromBuffer(e){const t=B.asReader(e);return new Pt(t.readObject(f),t.readObject(f),Wt(t.readBytes(32)))}}class Ns{constructor(e){l(this,"address");this.address=e}getKey(){return this.address.toBigInt()}toBuffer(){return this.address.toBuffer()}isEmpty(){return this.address.isZero()}updateTo(e){throw new Error("Protocol contract tree is insert only")}static buildDummy(e){return new Ns(new f(e))}static fromBuffer(e){return new Ns(f.fromBuffer(e))}}function mo(n,e){return n.replace(/{(\d+)}/g,(t,s)=>typeof e[s]>"u"?t:e[s].toString()).replace(/{}/g,(t,s)=>e.toString())}const Nd=["n","iv","ov","t"];let Z;const go=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&go.decode();let Hn=null;function Bn(){return(Hn===null||Hn.byteLength===0)&&(Hn=new Uint8Array(Z.memory.buffer)),Hn}function os(n,e){return n=n>>>0,go.decode(Bn().subarray(n,n+e))}function bo(n){const e=Z.__externref_table_alloc();return Z.__wbindgen_export_3.set(e,n),e}function Ur(n,e){try{return n.apply(this,e)}catch(t){const s=bo(t);Z.__wbindgen_exn_store(s)}}let Os=0;const fs=typeof TextEncoder<"u"?new TextEncoder("utf-8"):{encode:()=>{throw Error("TextEncoder not available")}},Od=typeof fs.encodeInto=="function"?function(n,e){return fs.encodeInto(n,e)}:function(n,e){const t=fs.encode(n);return e.set(t),{read:n.length,written:t.length}};function Qr(n,e,t){if(t===void 0){const o=fs.encode(n),c=e(o.length,1)>>>0;return Bn().subarray(c,c+o.length).set(o),Os=o.length,c}let s=n.length,a=e(s,1)>>>0;const r=Bn();let i=0;for(;i<s;i++){const o=n.charCodeAt(i);if(o>127)break;r[a+i]=o}if(i!==s){i!==0&&(n=n.slice(i)),a=t(a,s,s=i+n.length*3,1)>>>0;const o=Bn().subarray(a+i,a+s),c=Od(n,o);i+=c.written,a=t(a,s,i,1)>>>0}return Os=i,a}let yt=null;function nn(){return(yt===null||yt.buffer.detached===!0||yt.buffer.detached===void 0&&yt.buffer!==Z.memory.buffer)&&(yt=new DataView(Z.memory.buffer)),yt}function _s(n){return n==null}function Gt(n){const e=Z.__wbindgen_export_3.get(n);return Z.__externref_table_dealloc(n),e}function $n(n,e,t){const s=Z.abiEncode(n,e,_s(t)?0:bo(t));if(s[2])throw Gt(s[1]);return Gt(s[0])}function es(n,e){const t=Z.abiDecode(n,e);if(t[2])throw Gt(t[1]);return Gt(t[0])}function Td(n,e){return n=n>>>0,Bn().subarray(n/1,n/1+e)}function Ed(n){const e=Z.serializeWitness(n);if(e[3])throw Gt(e[2]);var t=Td(e[0],e[1]).slice();return Z.__wbindgen_free(e[0],e[1]*1,1),t}function yo(n,e){const t=Z.abiDecodeError(n,e);if(t[2])throw Gt(t[1]);return Gt(t[0])}function Ld(n,e,t,s){Z.closure163_externref_shim(n,e,t,s)}async function Sd(n,e){if(typeof Response=="function"&&n instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(n,e)}catch(s){if(n.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",s);else throw s}const t=await n.arrayBuffer();return await WebAssembly.instantiate(t,e)}else{const t=await WebAssembly.instantiate(n,e);return t instanceof WebAssembly.Instance?{instance:t,module:n}:t}}function Hd(){const n={};return n.wbg={},n.wbg.__wbg_constructor_d3c2239665744798=function(e){return new Error(e)},n.wbg.__wbg_error_7534b8e9a36f1ab4=function(e,t){let s,a;try{s=e,a=t,console.error(os(e,t))}finally{Z.__wbindgen_free(s,a,1)}},n.wbg.__wbg_forEach_e1cf6f7c8ecb7dae=function(e,t,s){try{var a={a:t,b:s},r=(i,o)=>{const c=a.a;a.a=0;try{return Ld(c,a.b,i,o)}finally{a.a=c}};e.forEach(r)}finally{a.a=a.b=0}},n.wbg.__wbg_new_8a6f238a6ece86ea=function(){return new Error},n.wbg.__wbg_new_98f028e6882ecba5=function(){return new Map},n.wbg.__wbg_parse_def2e24ef1252aff=function(){return Ur(function(e,t){return JSON.parse(os(e,t))},arguments)},n.wbg.__wbg_set_8fc6bf8a5b1071d1=function(e,t,s){return e.set(t,s)},n.wbg.__wbg_stack_0ed75d68575b0f3c=function(e,t){const s=t.stack,a=Qr(s,Z.__wbindgen_malloc,Z.__wbindgen_realloc),r=Os;nn().setInt32(e+4*1,r,!0),nn().setInt32(e+4*0,a,!0)},n.wbg.__wbg_stringify_f7ed6987935b4a24=function(){return Ur(function(e){return JSON.stringify(e)},arguments)},n.wbg.__wbindgen_init_externref_table=function(){const e=Z.__wbindgen_export_3,t=e.grow(4);e.set(0,void 0),e.set(t+0,void 0),e.set(t+1,null),e.set(t+2,!0),e.set(t+3,!1)},n.wbg.__wbindgen_is_undefined=function(e){return e===void 0},n.wbg.__wbindgen_number_get=function(e,t){const s=t,a=typeof s=="number"?s:void 0;nn().setFloat64(e+8*1,_s(a)?0:a,!0),nn().setInt32(e+4*0,!_s(a),!0)},n.wbg.__wbindgen_number_new=function(e){return e},n.wbg.__wbindgen_string_get=function(e,t){const s=t,a=typeof s=="string"?s:void 0;var r=_s(a)?0:Qr(a,Z.__wbindgen_malloc,Z.__wbindgen_realloc),i=Os;nn().setInt32(e+4*1,i,!0),nn().setInt32(e+4*0,r,!0)},n.wbg.__wbindgen_string_new=function(e,t){return os(e,t)},n.wbg.__wbindgen_throw=function(e,t){throw new Error(os(e,t))},n}function Xd(n,e){return Z=n.exports,Aa.__wbindgen_wasm_module=e,yt=null,Hn=null,Z.__wbindgen_start(),Z}async function Aa(n){if(Z!==void 0)return Z;typeof n<"u"&&(Object.getPrototypeOf(n)===Object.prototype?{module_or_path:n}=n:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof n>"u"&&(n=new URL("/assets/noirc_abi_wasm_bg-f7XerIGE.wasm",import.meta.url));const e=Hd();(typeof n=="string"||typeof Request=="function"&&n instanceof Request||typeof URL=="function"&&n instanceof URL)&&(n=fetch(n));const{instance:t,module:s}=await Sd(await n,e);return Xd(t,s)}const Cd=Symbol.for("RunningPromise.EXIT");function Dd(n,...e){return t=>{t instanceof Error&&!e.some(s=>t instanceof s)&&n.error("Error in running promise",t)}}const Hs=class Hs{constructor(e,t=V("running-promise"),s=1e4,a=Dd(t)){l(this,"fn");l(this,"logger");l(this,"pollingIntervalMS");l(this,"handleError");l(this,"running");l(this,"runningPromise");l(this,"interruptibleSleep");l(this,"requested");this.fn=e,this.logger=t,this.pollingIntervalMS=s,this.handleError=a,this.running=!1,this.runningPromise=Promise.resolve(),this.interruptibleSleep=new Yl,this.requested=void 0}start(){if(this.running)return this.logger.warn("Attempted to start running promise that was already started"),this;this.running=!0;const e=async()=>{for(;this.running;){const t=this.requested!==void 0;try{await this.fn()}catch(s){await this.handleError(s)===Hs.EXIT&&(this.logger.warn("Error handler has requested to exit",{err:s}),this.running=!1)}t&&(this.requested.resolve(),this.requested=void 0),this.requested===void 0&&this.running&&await this.interruptibleSleep.sleep(this.pollingIntervalMS)}};return this.runningPromise=e(),this}async stop(){if(!this.running){this.logger.warn("Running promise was not started");return}this.running=!1,this.interruptibleSleep.interrupt(),await this.runningPromise}isRunning(){return this.running}async trigger(){if(!this.running)return this.fn();let e=this.requested;e||(e=Gl(),this.requested=e,this.interruptibleSleep.interrupt()),await e.promise}setPollingIntervalMS(e){this.pollingIntervalMS=e}};l(Hs,"EXIT",Cd);let Pa=Hs;class jd{constructor(e,t,s,a=V("types:block_stream"),r={}){l(this,"l2BlockSource");l(this,"localData");l(this,"handler");l(this,"log");l(this,"opts");l(this,"runningPromise");l(this,"isSyncing");l(this,"hasStarted");this.l2BlockSource=e,this.localData=t,this.handler=s,this.log=a,this.opts=r,this.isSyncing=!1,this.hasStarted=!1,this.runningPromise=new Pa(()=>this.work(),a,this.opts.pollIntervalMS??1e3)}start(){this.log.verbose("Starting L2 block stream",this.opts),this.runningPromise.start()}async stop(){await this.runningPromise.stop()}isRunning(){return this.runningPromise.isRunning()}async sync(){this.isSyncing=!0,await this.runningPromise.trigger(),this.isSyncing=!1}async work(){try{const e=await this.l2BlockSource.getL2Tips(),t=await this.localData.getL2Tips();this.log.trace("Running L2 block stream",{sourceLatest:e.latest.number,localLatest:t.latest.number,sourceFinalized:e.finalized.number,localFinalized:t.finalized.number,sourceProven:e.proven.number,localProven:t.proven.number,sourceLatestHash:e.latest.hash,localLatestHash:t.latest.hash,sourceProvenHash:e.proven.hash,localProvenHash:t.proven.hash,sourceFinalizedHash:e.finalized.hash,localFinalizedHash:t.finalized.hash});let s=t.latest.number;const a=new Id([e.latest]);for(;!await this.areBlockHashesEqualAt(s,{sourceCache:a});)s--;if(s<t.latest.number){s=Math.min(s,e.latest.number);const i=a.get(s)??await this.getBlockHashFromSource(s);if(s!==0&&!i)throw new Error(`Block hash not found in block source for block number ${s}`);this.log.verbose(`Reorg detected. Pruning blocks from ${s+1} to ${t.latest.number}.`),await this.emitEvent({type:"chain-pruned",block:Zl(s,i)})}s===0&&this.opts.startingBlock!==void 0&&(s=Math.max(this.opts.startingBlock-1,0)),this.hasStarted||(this.log.verbose(`Starting sync from block number ${s}`),this.hasStarted=!0);let r=s+1;for(this.opts.skipFinalized&&(r=Math.max(e.finalized.number,r));r<=e.latest.number;){const i=Math.min(this.opts.batchSize??20,e.latest.number-r+1);this.log.trace(`Requesting blocks from ${r} limit ${i} proven=${this.opts.proven}`);const o=await this.l2BlockSource.getPublishedBlocks(r,i,this.opts.proven);if(o.length===0)break;await this.emitEvent({type:"blocks-added",blocks:o}),r=o.at(-1).block.number+1}t.proven!==void 0&&e.proven.number!==t.proven.number&&await this.emitEvent({type:"chain-proven",block:e.proven}),t.finalized!==void 0&&e.finalized.number!==t.finalized.number&&await this.emitEvent({type:"chain-finalized",block:e.finalized})}catch(e){if(e.name==="AbortError")return;this.log.error("Error processing block stream",e)}}async areBlockHashesEqualAt(e,t){if(e===0)return!0;const s=await this.localData.getL2BlockHash(e);if(!s&&this.opts.skipFinalized)throw this.log.error(`No local block hash for block number ${e}`),new Sr;const a=t.sourceCache.get(e),r=t.sourceCache.get(e)??await this.getBlockHashFromSource(e);return!a&&r&&t.sourceCache.add({number:e,hash:r}),this.log.trace(`Comparing block hashes for block ${e}`,{localBlockHash:s,sourceBlockHash:r}),s===r}getBlockHashFromSource(e){return this.l2BlockSource.getBlockHeader(e).then(t=>t==null?void 0:t.hash()).then(t=>t==null?void 0:t.toString())}async emitEvent(e){if(this.log.debug(`Emitting ${e.type} (${e.type==="blocks-added"?e.blocks.length:e.block.number})`),await this.handler.handleBlockStreamEvent(e),!this.isRunning()&&!this.isSyncing)throw new Sr}}class Id{constructor(e=[]){l(this,"cache",new Map);for(const t of e)this.add(t)}add(e){e.hash&&this.cache.set(e.number,e.hash)}get(e){return this.cache.get(e)}}class js{constructor(e,t,s,a){l(this,"logContent");l(this,"txHash");l(this,"uniqueNoteHashesInTx");l(this,"firstNullifierInTx");this.logContent=e,this.txHash=t,this.uniqueNoteHashesInTx=s,this.firstNullifierInTx=a}toNoirSerialization(){return[...$r(this.logContent,Kl+1),this.txHash.hash,...$r(this.uniqueNoteHashesInTx,se),this.firstNullifierInTx]}static noirSerializationOfEmpty(){return new js([],fn.zero(),[],new f(0)).toNoirSerialization()}}function $r(n,e){if(n.length>e)throw new Error(`An array of length ${n.length} cannot be converted to a BoundedVec of max length ${e}`);return[n.concat(Array(e-n.length).fill(new f(0))),new f(n.length)]}class vt{constructor(e,t){l(this,"appTaggingSecret");l(this,"index");if(this.appTaggingSecret=e,this.index=t,t<0)throw new Error("IndexedTaggingSecret index out of bounds")}toFields(){return[this.appTaggingSecret,new f(this.index)]}static fromFields(e){return new this(e[0],e[1].toNumber())}computeTag(e){return wn([this.appTaggingSecret,e,this.index])}async computeSiloedTag(e,t){const s=await this.computeTag(e);return wn([t,s])}}class Bd{constructor(e,t,s,a,r,i,o){l(this,"log");l(this,"txHash");l(this,"uniqueNoteHashesInTx");l(this,"firstNullifierInTx");l(this,"recipient");l(this,"logIndexInTx");l(this,"txIndexInBlock");this.log=e,this.txHash=t,this.uniqueNoteHashesInTx=s,this.firstNullifierInTx=a,this.recipient=r,this.logIndexInTx=i,this.txIndexInBlock=o}toFields(){return[...ei(this.log,Wi),this.txHash.hash,...ei(this.uniqueNoteHashesInTx,se),this.firstNullifierInTx,this.recipient.toField(),new f(this.logIndexInTx),new f(this.txIndexInBlock)]}}function ei(n,e){const t=e-n.length,s=Array(t).fill(f.ZERO);return[...n.concat(s),new f(n.length)]}async function Fd(n,e){if(e.isZero())throw new Error("Attempting to derive a shared secret with a zero public key. You have probably passed a zero public key in your Noir code somewhere thinking that the note won't be broadcast... but it was.");return await new Jl().mul(e,n)}function qd(n){return Object.values(Ce).some(e=>e.equals(n))}async function Wd(n){const e={hash:async(a,r)=>(await wn([a,r])).toBuffer(),hashInputs:async a=>(await wn(a)).toBuffer()},t=await ar.create(Mi,e,Pt),s=new Array(qi).fill(Buffer.alloc(32));for(const a of n){const r=a.address.toField().toNumber();s[r]=a.leaf.toBuffer()}return t.computeTree(s)}let Vs;async function Md(){if(!Vs){const n=Ri.map(e=>({address:Ce[e],leaf:Ul[e]}));Vs=await Wd(n)}return Vs}async function Rd(n,e){const t=await Md();let s,a;if(qd(n)){const r=n.toField().toNumber();s=t.leafPreimages[r],a=t.getMembershipWitness(r)}else{s=t.getLowLeaf(e.toBigInt());const r=(await wn(s.toHashInputs())).toBuffer();a=t.getMembershipWitness(r)}return{lowLeaf:s,witness:a}}const Vd=!0,Yd="1.0.0-beta.5+0000000000000000000000000000000000000000",Gd="SponsoredFPC",Zd=[{name:"sponsor_unconditionally",is_unconstrained:!1,custom_attributes:["private"],abi:{parameters:[{name:"inputs",type:{kind:"struct",path:"aztec::context::inputs::private_context_inputs::PrivateContextInputs",fields:[{name:"call_context",type:{kind:"struct",path:"aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"historical_header",type:{kind:"struct",path:"aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]},visibility:"private"}],return_type:{abi_type:{kind:"struct",path:"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",fields:[{name:"call_context",type:{kind:"struct",path:"aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"min_revertible_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"is_fee_payer",type:{kind:"boolean"}},{name:"max_block_number",type:{kind:"struct",path:"aztec::protocol_types::abis::max_block_number::MaxBlockNumber",fields:[{name:"_opt",type:{kind:"struct",path:"std::option::Option",fields:[{name:"_is_some",type:{kind:"boolean"}},{name:"_value",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}},{name:"note_hash_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifier_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"key_validation_requests_and_generators",type:{kind:"array",length:16,type:{kind:"struct",path:"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",fields:[{name:"request",type:{kind:"struct",path:"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",fields:[{name:"pk_m",type:{kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint",fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}]}},{name:"sk_app",type:{kind:"field"}}]}},{name:"sk_app_generator",type:{kind:"field"}}]}}},{name:"note_hashes",type:{kind:"array",length:16,type:{kind:"struct",path:"aztec::protocol_types::abis::note_hash::NoteHash",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifiers",type:{kind:"array",length:16,type:{kind:"struct",path:"aztec::protocol_types::abis::nullifier::Nullifier",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"note_hash",type:{kind:"field"}}]}}},{name:"private_call_requests",type:{kind:"array",length:5,type:{kind:"struct",path:"aztec::protocol_types::abis::private_call_request::PrivateCallRequest",fields:[{name:"call_context",type:{kind:"struct",path:"aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_call_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_teardown_call_request",type:{kind:"struct",path:"aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"l2_to_l1_msgs",type:{kind:"array",length:2,type:{kind:"struct",path:"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",fields:[{name:"recipient",type:{kind:"struct",path:"aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"content",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"private_logs",type:{kind:"array",length:16,type:{kind:"struct",path:"aztec::protocol_types::abis::private_log::PrivateLogData",fields:[{name:"log",type:{kind:"struct",path:"aztec::protocol_types::abis::log::Log",fields:[{name:"fields",type:{kind:"array",length:18,type:{kind:"field"}}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"note_hash_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"contract_class_logs_hashes",type:{kind:"array",length:1,type:{kind:"struct",path:"aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"aztec::protocol_types::abis::log_hash::LogHash",fields:[{name:"value",type:{kind:"field"}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"historical_header",type:{kind:"struct",path:"aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}}]},visibility:"databus"},error_types:{"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"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",debug_symbols:"nZTBjoMgEED/hbMHELAz/ZWmaahlGxOihmqTTeO/79ARux5sml58CsyDGYSHuPjzeD017U93E/vDQ5xjE0JzPYWudkPTtdT6EDI9dqXYq0LsNMMwLKNi7BjAwCdAMhSDLcAWYAuwBdgCbAG2AFuQLCVBMUqGZhiGZZClnKZC5BROQ/Q+ZfAvJ8q0d9G3g9i3YwiFuLswPgfdetc+ObhIvbIQvr0QSfjTBJ/epuIVLbdDEao5GBGX8HKHHwsqMwuUlOU3htKAmhVlpfSiQLsy6G2DUQpng1HWLgb78RqMgiwwryTsuox2Ox4s5jpCpTdX8M6AKlcBUOM3BpCwGKzeMsAbg8x7Cfqrn8HiUoZKKrnayiN9ubqJ61Or6HTQpMow6HSkie8uNu4cfBqSJGNb5wj6HH773JNvgj52tb+M0Sf76zog+cFiUeGR3NRyQCiU1McpLecP",brillig_names:["debug_log_oracle_wrapper"],verification_key:"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"},{name:"sync_private_state",is_unconstrained:!0,custom_attributes:["utility"],abi:{parameters:[],return_type:null,error_types:{"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},bytecode:"H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=",debug_symbols:"nZPfioQgFIff5Vx34f+0VxmGwcoGQSycWliid18bdKYWXJa58WSe7+tX6Qq9aZf7zfphfEBzWaEN1jl7v7mx07Mdfby7AtoHTKGhFWAGDY+FQ1PHIqBR21ZB7r/NwZi9/SCI2kkH42do/OJcBV/aLc+mx6T9s846xFVUgfF9rFE4WGf2q61606iMYsSZSDhGAvGXQvGTA5cdtcwGidiLF+TEkzLPCU885+9XwLT+bwBJ6xyAq1IAVuYZVYlnQn4UQLIcQMlSAFHm43dPvCDikwCKkCRQlJcCyD8CyLyHavTrF1zjVHc2nLb2tquC1a0zaTosvjuszt9TXslHYwpjZ/olmN10OB9xvGBZEXrd9qf9AA==",brillig_names:["sync_private_state"]},{name:"public_dispatch",is_unconstrained:!0,custom_attributes:["public"],abi:{parameters:[{name:"selector",type:{kind:"field"},visibility:"private"}],return_type:null,error_types:{"1752556835457866331":{error_kind:"string",string:"No public functions"}}},bytecode:"JwAABAEqAAABBRhSVSgKJhpbPAAAAQ==",debug_symbols:"XY1bCoAgEEX3Mt+toK1EiI9RBkRl0iDEvWeRIH3ee+6jgkFVnKBg4wHrVkExeU9O+Khlphi6W9sCQ4rMiN2CiW97D0hN/C+dkkkqj5+0JeiJ5isNMk4TR42mMD5LL2t7uwE=",brillig_names:["public_dispatch"]}],Kd={globals:{},structs:{functions:[{fields:[{name:"parameters",type:{fields:[],kind:"struct",path:"SponsoredFPC::sponsor_unconditionally_parameters"}}],kind:"struct",path:"SponsoredFPC::sponsor_unconditionally_abi"},{fields:[{name:"parameters",type:{fields:[],kind:"struct",path:"SponsoredFPC::sync_private_state_parameters"}}],kind:"struct",path:"SponsoredFPC::sync_private_state_abi"}]}},Jd={50:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/fees/sponsored_fpc_contract/src/main.nr",source:`use dep::aztec::macros::aztec;

/// FOR TESTING ONLY
/// Sponsored Fee Payment Contract (Sponsored FPC)
/// This contract covers transaction fees for users unconditionally.
#[aztec]
pub contract SponsoredFPC {
    use dep::aztec::macros::functions::private;

    /// Sponsors the transaction unconditionally.
    #[private]
    fn sponsor_unconditionally() {
        // Set the FPC as the fee payer of the tx.
        context.set_as_fee_payer();
    }
}
`},59:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",source:`use crate::{
    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},
    hash::{ArgsHasher, hash_args_array, hash_calldata_array},
    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},
    messaging::process_l1_to_l2_message,
    oracle::{
        block_header::get_block_header_at,
        call_private_function::call_private_function_internal,
        enqueue_public_function_call::{
            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,
            notify_set_public_teardown_function_call,
        },
        execution_cache,
        key_validation_request::get_key_validation_request,
        notes::{notify_created_nullifier, notify_nullified_note},
    },
};
use dep::protocol_types::{
    abis::{
        call_context::CallContext,
        function_selector::FunctionSelector,
        gas_settings::GasSettings,
        log_hash::LogHash,
        max_block_number::MaxBlockNumber,
        note_hash::NoteHash,
        nullifier::Nullifier,
        private_call_request::PrivateCallRequest,
        private_circuit_public_inputs::PrivateCircuitPublicInputs,
        private_log::{PrivateLog, PrivateLogData},
        public_call_request::PublicCallRequest,
        read_request::ReadRequest,
        side_effect::Counted,
        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},
    },
    address::{AztecAddress, EthAddress},
    block_header::BlockHeader,
    constants::{
        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,
        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,
        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,
        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,
        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,
        PRIVATE_LOG_SIZE_IN_FIELDS,
    },
    messaging::l2_to_l1_message::L2ToL1Message,
    traits::{Empty, Hash, ToField},
    utils::arrays::array_concat,
};

// When finished, one can call .finish() to convert back to the abi
pub struct PrivateContext {
    // docs:start:private-context
    pub inputs: PrivateContextInputs,
    pub side_effect_counter: u32,

    pub min_revertible_side_effect_counter: u32,
    pub is_fee_payer: bool,

    pub args_hash: Field,
    pub return_hash: Field,

    pub max_block_number: MaxBlockNumber,

    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,
    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,
    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,

    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,
    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,

    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,
    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,
    pub public_teardown_call_request: PublicCallRequest,
    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,
    // docs:end:private-context

    // Header of a block whose state is used during private execution (not the block the transaction is included in).
    pub historical_header: BlockHeader,

    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,
    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,

    // Contains the last key validation request for each key type. This is used to cache the last request and avoid
    // fetching the same request multiple times.
    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).
    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],
}

impl PrivateContext {
    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {
        PrivateContext {
            inputs,
            side_effect_counter: inputs.start_side_effect_counter + 1,
            min_revertible_side_effect_counter: 0,
            is_fee_payer: false,
            args_hash,
            return_hash: 0,
            max_block_number: MaxBlockNumber::empty(),
            note_hash_read_requests: BoundedVec::new(),
            nullifier_read_requests: BoundedVec::new(),
            key_validation_requests_and_generators: BoundedVec::new(),
            note_hashes: BoundedVec::new(),
            nullifiers: BoundedVec::new(),
            historical_header: inputs.historical_header,
            private_call_requests: BoundedVec::new(),
            public_call_requests: BoundedVec::new(),
            public_teardown_call_request: PublicCallRequest::empty(),
            l2_to_l1_msgs: BoundedVec::new(),
            private_logs: BoundedVec::new(),
            contract_class_logs_hashes: BoundedVec::new(),
            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],
        }
    }

    pub fn msg_sender(self) -> AztecAddress {
        self.inputs.call_context.msg_sender
    }

    pub fn this_address(self) -> AztecAddress {
        self.inputs.call_context.contract_address
    }

    pub fn chain_id(self) -> Field {
        self.inputs.tx_context.chain_id
    }

    pub fn version(self) -> Field {
        self.inputs.tx_context.version
    }

    pub fn gas_settings(self) -> GasSettings {
        self.inputs.tx_context.gas_settings
    }

    pub fn selector(self) -> FunctionSelector {
        self.inputs.call_context.function_selector
    }

    pub fn get_args_hash(self) -> Field {
        self.args_hash
    }

    pub fn push_note_hash(&mut self, note_hash: Field) {
        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });
    }

    pub fn push_nullifier(&mut self, nullifier: Field) {
        notify_created_nullifier(nullifier);
        self.nullifiers.push(
            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },
        );
    }

    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {
        let nullifier_counter = self.next_counter();
        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);
        self.nullifiers.push(
            Nullifier {
                value: nullifier,
                note_hash: nullified_note_hash,
                counter: nullifier_counter,
            },
        );
    }

    // Returns the header of a block whose state is used during private execution (not the block the transaction is
    // included in).
    pub fn get_block_header(self) -> BlockHeader {
        self.historical_header
    }

    // Returns the header of an arbitrary block whose block number is less than or equal to the block number
    // of historical header.
    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {
        get_block_header_at(block_number, self)
    }

    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {
        self.return_hash = returns_hasher.hash();
        execution_cache::store(returns_hasher.fields, self.return_hash);
    }

    pub fn finish(self) -> PrivateCircuitPublicInputs {
        PrivateCircuitPublicInputs {
            call_context: self.inputs.call_context,
            args_hash: self.args_hash,
            returns_hash: self.return_hash,
            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,
            is_fee_payer: self.is_fee_payer,
            max_block_number: self.max_block_number,
            note_hash_read_requests: self.note_hash_read_requests.storage(),
            nullifier_read_requests: self.nullifier_read_requests.storage(),
            key_validation_requests_and_generators: self
                .key_validation_requests_and_generators
                .storage(),
            note_hashes: self.note_hashes.storage(),
            nullifiers: self.nullifiers.storage(),
            private_call_requests: self.private_call_requests.storage(),
            public_call_requests: self.public_call_requests.storage(),
            public_teardown_call_request: self.public_teardown_call_request,
            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),
            start_side_effect_counter: self.inputs.start_side_effect_counter,
            end_side_effect_counter: self.side_effect_counter,
            private_logs: self.private_logs.storage(),
            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),
            historical_header: self.historical_header,
            tx_context: self.inputs.tx_context,
        }
    }

    pub fn set_as_fee_payer(&mut self) {
        dep::protocol_types::debug_log::debug_log_format(
            "Setting {0} as fee payer",
            [self.this_address().to_field()],
        );
        self.is_fee_payer = true;
    }

    pub fn end_setup(&mut self) {
        // dep::protocol_types::debug_log::debug_log_format(
        //     "Ending setup at counter {0}",
        //     [self.side_effect_counter as Field]
        // );
        self.min_revertible_side_effect_counter = self.side_effect_counter;
        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);
    }

    // docs:start:max-block-number
    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {
        // docs:end:max-block-number
        self.max_block_number =
            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);
    }

    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {
        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };
        self.note_hash_read_requests.push(side_effect);
    }

    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {
        let request = ReadRequest { value: nullifier, counter: self.next_counter() };
        self.nullifier_read_requests.push(request);
    }

    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {
        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)
    }

    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {
        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)
    }

    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {
        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(
            KeyValidationRequest::empty(),
        );

        if cached_request.pk_m.hash() == pk_m_hash {
            // We get a match so the cached request is the latest one
            cached_request.sk_app
        } else {
            // We didn't get a match meaning the cached result is stale
            // Typically we'd validate keys by showing that they are the preimage of \`pk_m_hash\`, but that'd require
            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn
            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to
            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes
            // to \`pk_m_hash\`.

            // Safety: Kernels verify that the key validation request is valid and below we verify that a request
            // for the correct public key has been received.
            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };
            assert_eq(request.pk_m.hash(), pk_m_hash, "Obtained invalid key validation request");

            self.key_validation_requests_and_generators.push(
                KeyValidationRequestAndGenerator {
                    request,
                    sk_app_generator: sk_generators[key_index as u32],
                },
            );
            self.last_key_validation_requests[key_index as u32] = Option::some(request);
            request.sk_app
        }
    }

    // docs:start:context_message_portal
    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {
        // docs:end:context_message_portal
        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };
        self.l2_to_l1_msgs.push(message);
    }

    // docs:start:context_consume_l1_to_l2_message
    // docs:start:consume_l1_to_l2_message
    pub fn consume_l1_to_l2_message(
        &mut self,
        content: Field,
        secret: Field,
        sender: EthAddress,
        leaf_index: Field,
    ) {
        // docs:end:context_consume_l1_to_l2_message
        let nullifier = process_l1_to_l2_message(
            self.historical_header.state.l1_to_l2_message_tree.root,
            self.this_address(),
            sender,
            self.chain_id(),
            self.version(),
            content,
            secret,
            leaf_index,
        );

        // Push nullifier (and the "commitment" corresponding to this can be "empty")
        self.push_nullifier(nullifier)
    }
    // docs:end:consume_l1_to_l2_message

    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {
        let counter = self.next_counter();
        let private_log =
            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };
        self.private_logs.push(private_log);
    }

    pub fn emit_raw_note_log(
        &mut self,
        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],
        length: u32,
        note_hash_counter: u32,
    ) {
        let counter = self.next_counter();
        let private_log =
            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };
        self.private_logs.push(private_log);
    }

    pub fn call_private_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) -> ReturnsHash {
        let args_hash = hash_args_array(args);
        execution_cache::store(args, args_hash);
        self.call_private_function_with_args_hash(
            contract_address,
            function_selector,
            args_hash,
            false,
        )
    }

    pub fn static_call_private_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) -> ReturnsHash {
        let args_hash = hash_args_array(args);
        execution_cache::store(args, args_hash);
        self.call_private_function_with_args_hash(
            contract_address,
            function_selector,
            args_hash,
            true,
        )
    }

    pub fn call_private_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) -> ReturnsHash {
        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)
    }

    pub fn static_call_private_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) -> ReturnsHash {
        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)
    }

    pub fn call_private_function_with_args_hash(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args_hash: Field,
        is_static_call: bool,
    ) -> ReturnsHash {
        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;
        let start_side_effect_counter = self.side_effect_counter;

        // Safety: The oracle simulates the private call and returns the value of the side effects counter after
        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is
        // the number of side effects that took place), along with the hash of the return values. We validate these
        // by requesting a private kernel iteration in which the return values are constrained to hash
        // to \`returns_hash\` and the side effects counter to increment from start to end.
        let (end_side_effect_counter, returns_hash) = unsafe {
            call_private_function_internal(
                contract_address,
                function_selector,
                args_hash,
                start_side_effect_counter,
                is_static_call,
            )
        };

        self.private_call_requests.push(
            PrivateCallRequest {
                call_context: CallContext {
                    msg_sender: self.this_address(),
                    contract_address,
                    function_selector,
                    is_static_call,
                },
                args_hash,
                returns_hash,
                start_side_effect_counter,
                end_side_effect_counter,
            },
        );

        // TODO (fees) figure out why this crashes the prover and enable it
        // we need this in order to pay fees inside child call contexts
        // assert(
        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)
        //     | (item.public_inputs.min_revertible_side_effect_counter
        //         > self.min_revertible_side_effect_counter)
        // );
        // if item.public_inputs.min_revertible_side_effect_counter
        //     > self.min_revertible_side_effect_counter {
        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;
        // }
        self.side_effect_counter = end_side_effect_counter + 1;
        ReturnsHash::new(returns_hash)
    }

    pub fn call_public_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn static_call_public_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)
    }

    pub fn call_public_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) {
        let calldata_hash = hash_calldata_array([function_selector.to_field()]);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn static_call_public_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) {
        let calldata_hash = hash_calldata_array([function_selector.to_field()]);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)
    }

    pub fn call_public_function_with_calldata_hash(
        &mut self,
        contract_address: AztecAddress,
        calldata_hash: Field,
        is_static_call: bool,
    ) {
        let counter = self.next_counter();

        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;

        notify_enqueued_public_function_call(
            contract_address,
            calldata_hash,
            counter,
            is_static_call,
        );

        let call_request = PublicCallRequest {
            msg_sender: self.this_address(),
            contract_address,
            is_static_call,
            calldata_hash,
        };

        self.public_call_requests.push(Counted::new(call_request, counter));
    }

    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn set_public_teardown_function_with_calldata_hash(
        &mut self,
        contract_address: AztecAddress,
        calldata_hash: Field,
        is_static_call: bool,
    ) {
        let counter = self.next_counter();

        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;

        notify_set_public_teardown_function_call(
            contract_address,
            calldata_hash,
            counter,
            is_static_call,
        );

        self.public_teardown_call_request = PublicCallRequest {
            msg_sender: self.this_address(),
            contract_address,
            is_static_call,
            calldata_hash,
        };
    }

    fn next_counter(&mut self) -> u32 {
        let counter = self.side_effect_counter;
        self.side_effect_counter += 1;
        counter
    }
}

impl Empty for PrivateContext {
    fn empty() -> Self {
        PrivateContext {
            inputs: PrivateContextInputs::empty(),
            side_effect_counter: 0 as u32,
            min_revertible_side_effect_counter: 0 as u32,
            is_fee_payer: false,
            args_hash: 0,
            return_hash: 0,
            max_block_number: MaxBlockNumber::empty(),
            note_hash_read_requests: BoundedVec::new(),
            nullifier_read_requests: BoundedVec::new(),
            key_validation_requests_and_generators: BoundedVec::new(),
            note_hashes: BoundedVec::new(),
            nullifiers: BoundedVec::new(),
            private_call_requests: BoundedVec::new(),
            public_call_requests: BoundedVec::new(),
            public_teardown_call_request: PublicCallRequest::empty(),
            l2_to_l1_msgs: BoundedVec::new(),
            historical_header: BlockHeader::empty(),
            private_logs: BoundedVec::new(),
            contract_class_logs_hashes: BoundedVec::new(),
            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],
        }
    }
}
`},62:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",source:`use crate::oracle::{
    execution::{get_block_number, get_chain_id, get_contract_address, get_version},
    storage::storage_read,
};
use dep::protocol_types::{address::AztecAddress, traits::Packable};

pub struct UtilityContext {
    block_number: u32,
    contract_address: AztecAddress,
    version: Field,
    chain_id: Field,
}

impl UtilityContext {
    pub unconstrained fn new() -> Self {
        // We could call these oracles on the getters instead of at creation, which makes sense given that they might
        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user
        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not
        // available.
        let block_number = get_block_number();
        let contract_address = get_contract_address();
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub unconstrained fn at(contract_address: AztecAddress) -> Self {
        let block_number = get_block_number();
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub fn block_number(self) -> u32 {
        self.block_number
    }

    pub fn this_address(self) -> AztecAddress {
        self.contract_address
    }

    pub fn version(self) -> Field {
        self.version
    }

    pub fn chain_id(self) -> Field {
        self.chain_id
    }

    pub unconstrained fn raw_storage_read<let N: u32>(
        self: Self,
        storage_slot: Field,
    ) -> [Field; N] {
        storage_read(self.this_address(), storage_slot, self.block_number())
    }

    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T
    where
        T: Packable<N>,
    {
        T::unpack(self.raw_storage_read(storage_slot))
    }
}
`},95:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",source:`use crate::macros::{
    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},
    notes::NOTES,
    utils::{
        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,
        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,
        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,
    },
};
use protocol_types::meta::generate_serialize_to_fields;
use std::meta::type_of;

pub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // If a function is further modified as unconstrained, we throw an error
    if f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword",
        );
    }

    let module_has_initializer = module_has_initializer(f.module());
    let module_has_storage = module_has_storage(f.module());

    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the
    // Private Kernel Circuit.
    // First we change the function signature so that it also receives \`PrivateContextInputs\`, which contain information
    // about the execution context (e.g. the caller).
    let original_params = f.parameters();
    f.set_parameters(&[(
        quote { inputs },
        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),
    )]
        .append(original_params));

    let mut body = f.body().as_block().unwrap();

    // The original params are hashed and passed to the \`context\` object, so that the kernel can verify we've received
    // the correct values.
    // TODO: Optimize args_hasher for small number of arguments
    let args_hasher_name = quote { args_hasher };
    let args_hasher = original_params.fold(
        quote {
            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();
        },
        |args_hasher, param: (Quoted, Type)| {
            let (name, typ) = param;
            let appended_arg = add_to_hasher(args_hasher_name, name, typ);
            quote {
                $args_hasher
                $appended_arg
            }
        },
    );

    let context_creation = quote {
        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));
    };

    // Modifications introduced by the different marker attributes.
    let internal_check = if is_fn_internal(f) {
        create_internal_check(f)
    } else {
        quote {}
    };

    let view_check = if is_fn_view(f) {
        create_view_check(f)
    } else {
        quote {}
    };

    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {
        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))
    } else {
        (quote {}, quote {})
    };

    let storage_init = if module_has_storage {
        quote {
            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
            // referenced. We instead ignore 'unused variable' warnings for it.
            #[allow(unused_variables)]
            let storage = Storage::init(&mut context);
        }
    } else {
        quote {}
    };

    // Initialization checks are not included in contracts that don't have initializers.
    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {
        create_init_check(f)
    } else {
        quote {}
    };

    // All private functions perform message discovery, since they may need to access notes. This is slightly
    // inefficient and could be improved by only doing it once we actually attempt to read any.
    let message_discovery_call = if NOTES.len() > 0 {
        create_message_discovery_call()
    } else {
        quote {}
    };

    // Finally, we need to change the return type to be \`PrivateCircuitPublicInputs\`, which is what the Private Kernel
    // circuit expects.
    let return_value_var_name = quote { macro__returned__values };

    let return_value_type = f.return_type();
    let return_value = if body.len() == 0 {
        quote {}
    } else if return_value_type != type_of(()) {
        // The original return value is passed to a second args hasher which the context receives.
        let (body_without_return, last_body_expr) = body.pop_back();
        let return_value = last_body_expr.quoted();
        let return_value_assignment =
            quote { let $return_value_var_name: $return_value_type = $return_value; };
        let return_hasher_name = quote { return_hasher };
        let return_value_into_hasher =
            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);

        body = body_without_return;

        quote {
            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();
            $return_value_assignment
            $return_value_into_hasher
            context.set_return_hash($return_hasher_name);
        }
    } else {
        let (body_without_return, last_body_expr) = body.pop_back();
        if !last_body_expr.has_semicolon()
            & last_body_expr.as_for().is_none()
            & last_body_expr.as_assert().is_none()
            & last_body_expr.as_for_range().is_none()
            & last_body_expr.as_assert_eq().is_none()
            & last_body_expr.as_let().is_none() {
            let unused_return_value_name = f"_{return_value_var_name}".quoted_contents();
            body = body_without_return.push_back(
                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),
            );
        }
        quote {}
    };

    let context_finish = quote { context.finish() };

    let to_prepend = quote {
        $args_hasher
        $context_creation
        $assert_initializer
        $init_check
        $internal_check
        $view_check
        $storage_init
        $message_discovery_call
    };

    let to_append = quote {
        $return_value
        $mark_as_initialized
        $context_finish
    };
    let modified_body = modify_fn_body(body, to_prepend, to_append);
    f.set_body(modified_body);
    f.set_return_type(
        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }
            .as_type(),
    );
    f.set_return_data();

    fn_abi
}

pub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // If a function is further modified as unconstrained, we throw an error
    if f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword",
        );
    }

    let module_has_initializer = module_has_initializer(f.module());
    let module_has_storage = module_has_storage(f.module());

    // Public functions undergo a lot of transformations from their Aztec.nr form.
    let original_params = f.parameters();
    let args_len = original_params
        .map(|(name, typ): (Quoted, Type)| {
            generate_serialize_to_fields(name, typ, false).0.len()
        })
        .fold(0, |acc: u32, val: u32| acc + val);

    // Unlike in the private case, in public the \`context\` does not need to receive the hash of the original params.
    let context_creation = quote {
        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {
        // We start from 1 because we skip the selector for the dispatch function.
        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);
        dep::aztec::hash::hash_args_array(serialized_args)
        });
    };

    // Modifications introduced by the different marker attributes.
    let internal_check = if is_fn_internal(f) {
        create_internal_check(f)
    } else {
        quote {}
    };

    let view_check = if is_fn_view(f) {
        create_view_check(f)
    } else {
        quote {}
    };

    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {
        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))
    } else {
        (quote {}, quote {})
    };

    let storage_init = if module_has_storage {
        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
        // referenced. We instead ignore 'unused variable' warnings for it.
        quote {
            #[allow(unused_variables)]
            let storage = Storage::init(&mut context);
        }
    } else {
        quote {}
    };

    // Initialization checks are not included in contracts that don't have initializers.
    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {
        create_init_check(f)
    } else {
        quote {}
    };

    let to_prepend = quote {
        $context_creation
        $assert_initializer
        $init_check
        $internal_check
        $view_check
        $storage_init
    };

    let to_append = quote {
        $mark_as_initialized
    };

    let body = f.body().as_block().unwrap();
    let modified_body = modify_fn_body(body, to_prepend, to_append);
    f.set_body(modified_body);

    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because
    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM
    // bytecode.
    f.set_unconstrained(true);
    f.set_return_public(true);

    fn_abi
}

pub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // Check if function is marked as unconstrained
    if !f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword",
        );
    }

    // Create utility context
    let context_creation =
        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };
    let module_has_storage = module_has_storage(f.module());

    // Initialize Storage if module has storage
    let storage_init = if module_has_storage {
        quote {
            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
            // referenced. We instead ignore 'unused variable' warnings for it.
            #[allow(unused_variables)]
            let storage = Storage::init(context);
        }
    } else {
        quote {}
    };

    // All utility functions perform message discovery, since they may need to access private notes that would be
    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually
    // attempt to read any.
    let message_discovery_call = if NOTES.len() > 0 {
        create_message_discovery_call()
    } else {
        quote {}
    };

    // Inject context creation, storage initialization, and message discovery call at the beginning of the function
    // body.
    let to_prepend = quote {
        $context_creation
        $storage_init
        $message_discovery_call
    };
    let body = f.body().as_block().unwrap();
    let modified_body = modify_fn_body(body, to_prepend, quote {});
    f.set_body(modified_body);

    f.set_return_public(true);

    fn_abi
}

comptime fn create_internal_check(f: FunctionDefinition) -> Quoted {
    let name = f.name();
    let assertion_message = f"Function {name} can only be called internally";
    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }
}

comptime fn create_view_check(f: FunctionDefinition) -> Quoted {
    let name = f.name();
    let assertion_message = f"Function {name} can only be called statically";
    if is_fn_private(f) {
        // Here \`context\` is of type context::PrivateContext
        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }
    } else {
        // Here \`context\` is of type context::PublicContext
        quote { assert(context.is_static_call(), $assertion_message); }
    }
}

comptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);"
        .quoted_contents()
}

comptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);"
        .quoted_contents()
}

comptime fn create_init_check(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);"
        .quoted_contents()
}

/// Injects a call to \`aztec::messages::discovery::discover_new_messages\`, causing for new notes to be added to PXE and made
/// available for the current execution.
pub(crate) comptime fn create_message_discovery_call() -> Quoted {
    quote {
        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore
        /// always safe to call.
        unsafe {
            dep::aztec::messages::discovery::discover_new_messages(
                context.this_address(),
                _compute_note_hash_and_nullifier,
            );
        };
    }
}

/// Checks if each function in the module is marked with either #[private], #[public], #[utility],
/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.
pub(crate) comptime fn check_each_fn_macroified(m: Module) {
    for f in m.functions() {
        let name = f.name();
        if !is_fn_private(f)
            & !is_fn_public(f)
            & !is_fn_utility(f)
            & !is_fn_contract_library_method(f)
            & !is_fn_test(f) {
            panic(
                f"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]",
            );
        }
    }
}
`},137:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",source:`use dep::protocol_types::address::AztecAddress;

#[oracle(getContractAddress)]
unconstrained fn get_contract_address_oracle() -> AztecAddress {}

#[oracle(getBlockNumber)]
unconstrained fn get_block_number_oracle() -> u32 {}

#[oracle(getChainId)]
unconstrained fn get_chain_id_oracle() -> Field {}

#[oracle(getVersion)]
unconstrained fn get_version_oracle() -> Field {}

pub unconstrained fn get_contract_address() -> AztecAddress {
    get_contract_address_oracle()
}

pub unconstrained fn get_block_number() -> u32 {
    get_block_number_oracle()
}

pub unconstrained fn get_chain_id() -> Field {
    get_chain_id_oracle()
}

pub unconstrained fn get_version() -> Field {
    get_version_oracle()
}
`},279:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",source:`/// Utility function to console.log data in the acir simulator.
/// Example:
///   debug_log("blah blah this is a debug string");
pub fn debug_log<let N: u32>(msg: str<N>) {
    debug_log_format(msg, []);
}

/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the
/// \`\${k}\` tokens will be replaced with the k-eth value in the \`args\` array.
/// Examples:
///   debug_log_format("get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}", [storage_slot, note0_hash, note1_hash]);
///   debug_log_format("whole array: {}", [e1, e2, e3, e4]);
pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call.
    unsafe { debug_log_oracle_wrapper(msg, args) };
}

pub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(
    msg: str<M>,
    args: [Field; N],
) {
    debug_log_oracle(msg, args.as_slice());
}

// WARNING: sometimes when using debug logs the ACVM errors with: \`thrown: "solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155"\`
#[oracle(debugLog)]
unconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}
`}},Ud={transpiled:Vd,noir_version:Yd,name:Gd,functions:Zd,outputs:Kd,file_map:Jd},ti=Be(Ud),Qd=31337,$d=1;class eu{constructor(e,t,s=Qd,a=$d){l(this,"address");l(this,"auth");l(this,"chainId");l(this,"version");this.address=e,this.auth=t,this.chainId=s,this.version=a}async createTxExecutionRequest(e,t,s){const{calls:a,authWitnesses:r,capsules:i,extraHashedArgs:o}=e,{cancellable:c,nonce:d}=s,_=await Yr.fromAppExecution(a,d),{calls:m,authWitnesses:h}=await t.paymentMethod.getExecutionPayload(t.gasSettings),b=(await t.paymentMethod.getFeePayer(t.gasSettings)).equals(this.address),N=await Yr.fromFeeCalls(m,b),A=this.getEntrypointAbi(),x=await Vi.fromArgs(Yi(A,[_,N,!!c])),P=await this.auth.createAuthWit(await wd(_,N));return Ql.from({firstCallArgsHash:x.hash,origin:this.address,functionSelector:await De.fromNameAndParameters(A.name,A.parameters),txContext:new Ua(this.chainId,this.version,t.gasSettings),argsOfCalls:[..._.hashedArguments,...N.hashedArguments,x,...o],authWitnesses:[...r,...h,P],capsules:i,salt:f.random()})}getEntrypointAbi(){return{name:"entrypoint",isInitializer:!1,functionType:"private",isInternal:!1,isStatic:!1,parameters:[{name:"app_payload",type:{kind:"struct",path:"authwit::entrypoint::app::AppPayload",fields:[{name:"function_calls",type:{kind:"array",length:4,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}}]},visibility:"public"},{name:"fee_payload",type:{kind:"struct",path:"authwit::entrypoint::fee::FeePayload",fields:[{name:"function_calls",type:{kind:"array",length:2,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}},{name:"is_fee_payer",type:{kind:"boolean"}}]},visibility:"public"},{name:"cancellable",type:{kind:"boolean"}}],returnTypes:[],errorTypes:{}}}}class tu{constructor(e,t,s){l(this,"authWitnessProvider");l(this,"address");l(this,"entrypoint");l(this,"chainId");l(this,"version");this.authWitnessProvider=e,this.address=t,this.entrypoint=new eu(t.address,e,s.l1ChainId,s.rollupVersion),this.chainId=new f(s.l1ChainId),this.version=new f(s.rollupVersion)}createTxExecutionRequest(e,t,s){return this.entrypoint.createTxExecutionRequest(e,t,s)}createAuthWit(e){return this.authWitnessProvider.createAuthWit(e)}getCompleteAddress(){return this.address}getAddress(){return this.address.address}getChainId(){return this.chainId}getVersion(){return this.version}}class vo{constructor(){}getInterface(e,t){return new tu(this.getAuthWitnessProvider(e),e,t)}}class nu extends vo{constructor(t){super();l(this,"signingPrivateKey");this.signingPrivateKey=t}async getDeploymentFunctionAndArgs(){const t=await new ho("secp256r1").computePublicKey(this.signingPrivateKey);return{constructorName:"constructor",constructorArgs:[t.subarray(0,32),t.subarray(32,64)]}}getAuthWitnessProvider(t){return new su(this.signingPrivateKey)}}class su{constructor(e){l(this,"signingPrivateKey");this.signingPrivateKey=e}async createAuthWit(e){const s=await new ho("secp256r1").constructSignature(e.toBuffer(),this.signingPrivateKey);return Promise.resolve(new Gi(e,[...s.r,...s.s]))}}async function au(){const{default:n}=await p(async()=>{const{default:e}=await import("./EcdsaRAccount-Dt_aY3gh.js");return{default:e}},[]);return Be(n)}class ru extends nu{constructor(e){super(e)}getContractArtifact(){return au()}}function ni(n,e,t,s){return fo.create(n,e,new ru(t),s)}var si={},ai;function wo(){if(ai)return si;ai=1;var n=wo();for(k in n)globalThis[k]=n[k];return si}wo();class xo extends vo{constructor(t){super();l(this,"signingPrivateKey");this.signingPrivateKey=t}async getDeploymentFunctionAndArgs(){const t=await new _o().computePublicKey(this.signingPrivateKey);return{constructorName:"constructor",constructorArgs:[t.x,t.y]}}getAuthWitnessProvider(t){return new iu(this.signingPrivateKey)}}class iu{constructor(e){l(this,"signingPrivateKey");this.signingPrivateKey=e}async createAuthWit(e){const s=await new _o().constructSignature(e.toBuffer(),this.signingPrivateKey);return new Gi(e,[...s.toBuffer()])}}async function ou(){const{default:n}=await p(async()=>{const{default:e}=await Promise.resolve().then(()=>Mp);return{default:e}},void 0);return Be(n)}let lu=class extends xo{constructor(e){super(e)}getContractArtifact(){return ou()}};function cu(n,e,t,s){return fo.create(n,e,new lu(t),s)}const du={dataDirectory:{env:"DATA_DIRECTORY",description:"Optional dir to store data. If omitted will store in memory."},dataStoreMapSizeKB:{env:"DATA_STORE_MAP_SIZE_KB",description:"DB mapping size to be applied to all key/value stores",...Ki(128*1024*1024)},l1Contracts:{description:"The deployed L1 contract addresses",nested:{rollupAddress:Zi.rollupAddress}}};Ji.ZERO;const uu={l1ChainId:{env:"L1_CHAIN_ID",parseEnv:n=>+n,defaultValue:31337,description:"The chain ID of the ethereum host."},rollupVersion:{env:"ROLLUP_VERSION",description:"The version of the rollup.",parseEnv:n=>Number.isSafeInteger(parseInt(n,10))?parseInt(n,10):void 0},l1Contracts:{description:"The deployed L1 contract addresses",nested:Zi}};function fu(){return{version:"0.87.3",name:"@aztec/pxe"}}const Ao={...du,...uu,l2BlockBatchSize:{env:"PXE_L2_BLOCK_BATCH_SIZE",...Ki(200),description:"Maximum amount of blocks to pull from the stream in one request when synchronizing"},bbBinaryPath:{env:"BB_BINARY_PATH",description:"Path to the BB binary"},bbWorkingDirectory:{env:"BB_WORKING_DIRECTORY",description:"Working directory for the BB binary"},bbSkipCleanup:{env:"BB_SKIP_CLEANUP",description:"True to skip cleanup of temporary files for debugging purposes",...Hr()},proverEnabled:{env:"PXE_PROVER_ENABLED",description:"Enable real proofs",...Hr(!0)}};function _u(){return $l(Ao)}({...Ao});class pu{constructor(e=V("foundation:memory_fifo")){l(this,"log");l(this,"waiting");l(this,"flushing");this.log=e,this.waiting=[],this.flushing=!1}length(){return this.items.length}getImmediate(){return this.items.get()}get(e){return this.items.length?Promise.resolve(this.items.get()):this.items.length===0&&this.flushing?Promise.resolve(null):e===0?Promise.reject(new Xr("Timeout getting item from queue.")):new Promise((t,s)=>{this.waiting.push(t),e&&setTimeout(()=>{const a=this.waiting.findIndex(r=>r===t);if(a>-1){this.waiting.splice(a,1);const r=new Xr("Timeout getting item from queue.");s(r)}},e*1e3)})}put(e){return this.flushing?(this.log.warn("Discarding item because queue is flushing"),!1):this.waiting.length?(this.waiting.shift()(e),!0):(this.items.put(e),!0)}end(){this.flushing=!0,this.waiting.forEach(e=>e(null))}cancel(){this.flushing=!0,this.items.clear(),this.waiting.forEach(e=>e(null))}async process(e){try{for(;;){const t=await this.get();if(t===null)break;await e(t)}}catch(t){this.log.error("Queue handler exception",t)}}}class hu extends pu{constructor(t){super(t);l(this,"container",new mu)}get items(){return this.container}}class mu{constructor(){l(this,"items",[])}put(e){this.items.push(e)}get(){return this.items.shift()}get length(){return this.items.length}clear(){this.items=[]}}class gu{constructor(){l(this,"queue",new hu);l(this,"runningPromise");l(this,"started",!1)}start(){this.started||(this.runningPromise=this.queue.process(e=>e()),this.started=!0)}length(){return this.queue.length()}cancel(){return this.queue.cancel(),this.runningPromise}end(){return this.queue.end(),this.runningPromise}put(e){return new Promise((t,s)=>{this.queue.put(async()=>{try{const r=await e();t(r)}catch(r){s(r)}})||s(new Error("Could not enqueue function"))})}async syncPoint(){await this.put(async()=>{})}}async function M(n){const e=[];for await(const t of n)e.push(t);return e}class Rt{constructor(e,t,s,a,r,i,o){l(this,"noteHashes");l(this,"nullifiers");l(this,"l2ToL1Msgs");l(this,"privateLogs");l(this,"contractClassLogsHashes");l(this,"publicCallRequests");l(this,"privateCallStack");this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=s,this.privateLogs=a,this.contractClassLogsHashes=r,this.publicCallRequests=i,this.privateCallStack=o}toBuffer(){return I(this.noteHashes,this.nullifiers,this.l2ToL1Msgs,this.privateLogs,this.contractClassLogsHashes,this.publicCallRequests,this.privateCallStack)}toString(){return Qa(this.toBuffer())}static fromBuffer(e){const t=B.asReader(e);return new Rt(t.readArray(se,vs),t.readArray(le,ws),t.readArray(Te,At),t.readArray(xn,_a),t.readArray(Rn,pa),t.readArray(xs,ha),t.readArray(ma,ga))}static fromString(e){return Rt.fromBuffer(Qn(e))}static empty(){return new Rt(G(se,vs.empty),G(le,ws.empty),G(Te,At.empty),G(xn,_a.empty),G(Rn,pa.empty),G(xs,ha.empty),G(ma,ga.empty))}}class ri{constructor(e,t,s){l(this,"pre");l(this,"post");l(this,"blockOfChange");this.pre=e,this.post=t,this.blockOfChange=s}static empty(){return new this(void 0,void 0,0)}isEmpty(){return this.pre===void 0&&this.post===void 0&&this.blockOfChange===0}}class ii{constructor(e,t,s){l(this,"previous");l(this,"post");l(this,"blockOfChange");if(this.previous=e,this.post=t,this.blockOfChange=s,this.previous.length!==this.post.length)throw new Error("Previous and post must have the same length")}static empty(e){return new this(Array(e).fill(new f(0)),Array(e).fill(new f(0)),0)}isEmpty(){return this.previous.every(e=>e.isZero())&&this.post.every(e=>e.isZero())&&this.blockOfChange===0}getCurrentAt(e){return e<this.blockOfChange?this.previous:this.post}}const Po=2*As+1;class Zt{constructor(e,t){l(this,"svc");l(this,"sdc");this.svc=e,this.sdc=t}static fromFields(e){const t=Qt.asReader(e),s=t.readField().toBigInt(),a=t.readFieldArray(As),r=t.readFieldArray(As),i=s&0xffffffffn,o=new ii(a,r,Number(i)),c=s>>32n&0xffffffffn,d=s>>64n&1n,_=s>>72n&0xffffffffn,m=s>>104n&1n,h=s>>112n&0xffffffffn,g=new ri(m?Number(h):void 0,d?Number(_):void 0,Number(c));return new this(o,g)}toFields(){let e=BigInt(this.svc.blockOfChange);return e|=BigInt(this.sdc.blockOfChange)<<32n,e|=(this.sdc.post===void 0?0n:1n)<<64n,e|=BigInt(this.sdc.post||0)<<72n,e|=(this.sdc.pre===void 0?0n:1n)<<104n,e|=BigInt(this.sdc.pre||0)<<112n,[new f(e),...this.svc.previous,...this.svc.post]}toBuffer(){return I(this.toFields())}static fromBuffer(e,t){const s=B.asReader(e);return Zt.fromFields(s.readArray(2*t+1,f))}static empty(e){return new this(ii.empty(e),ri.empty())}static async readFromTree(e,t){const s=[];for(let a=0;a<Po;a++)s.push(await t(e.add(new f(a))));return Zt.fromFields(s)}isEmpty(){return this.svc.isEmpty()&&this.sdc.isEmpty()}async writeToTree(e,t){const s=this.toFields();for(let a=0;a<s.length;a++)await t(e.add(new f(a)),s[a])}async hash(){const e=this.toFields();return await wn(e)}}class rr{constructor(e,t){l(this,"x");l(this,"y");this.x=typeof e=="bigint"?new as(e):e,this.y=typeof t=="bigint"?new as(t):t}toBuffer(){return I(this.x,this.y)}static fromBuffer(e){const t=B.asReader(e);return new rr(as.fromBuffer(t),as.fromBuffer(t))}}class Ts{constructor(e){l(this,"record");this.record=e}toBuffer(){const e=Object.entries(this.record);return I(e.length,...e.flat())}static fromBuffer(e){const t=B.asReader(e);return new Ts(t.readMap(rr))}}const bu=0,yu=1,vu=3;class ae{constructor(e,t){l(this,"key");l(this,"hash");this.key=e,this.hash=t}get numPublicInputs(){return Number(this.key[yu])}get circuitSize(){return Number(this.key[bu])}get isRecursive(){return this.key[vu].equals(f.ONE)}static get schema(){return $a(ae)}toJSON(){return this.toBuffer()}toBuffer(){return I(...this.toFields())}toFields(){return[this.key.length,...this.key,this.hash]}static fromBuffer(e){const t=B.asReader(e);return new ae(t.readVector(f),t.readObject(f))}static makeFake(e,t=1){return new ae(G(e,f.random,t),f.random())}static makeFakeHonk(e=1){return new ae(G(ec,f.random,e),f.random())}static makeFakeRollupHonk(e=1){return new ae(G(Ui,t=>new f(t),e),new f(e+1))}static makeEmpty(e){return new ae(G(e,f.zero),f.zero())}}class Vt{constructor(e,t,s,a,r,i){l(this,"circuitType");l(this,"circuitSize");l(this,"numPublicInputs");l(this,"commitments");l(this,"containsRecursiveProof");l(this,"recursiveProofPublicInputIndices");this.circuitType=e,this.circuitSize=t,this.numPublicInputs=s,this.commitments=a,this.containsRecursiveProof=r,this.recursiveProofPublicInputIndices=i}toBuffer(){return I(this.circuitType,this.circuitSize,this.numPublicInputs,new Ts(this.commitments),this.containsRecursiveProof,I(this.recursiveProofPublicInputIndices.length,this.recursiveProofPublicInputIndices))}static fromBuffer(e){const t=B.asReader(e);return new Vt(t.readNumber(),t.readNumber(),t.readNumber(),t.readObject(Ts).record,t.readBoolean(),t.readNumberVector())}static makeRollupFake(){return new Vt(Cr.ULTRA,2048,116,{},!1,Dr(16,e=>e))}static makeFake(){return new Vt(Cr.ULTRA,2048,116,{},!1,Dr(16,e=>e))}}class fe{constructor(e,t){l(this,"keyAsFields");l(this,"keyAsBytes");this.keyAsFields=e,this.keyAsBytes=t}get numPublicInputs(){return this.keyAsFields.numPublicInputs}get circuitSize(){return this.keyAsFields.circuitSize}get isRecursive(){return this.keyAsFields.isRecursive}static empty(){return new fe(ae.makeEmpty(0),Buffer.alloc(0))}static makeFakeHonk(){return new fe(ae.makeFakeHonk(),Vt.makeFake().toBuffer())}static makeFakeRollupHonk(){return new fe(ae.makeFakeRollupHonk(),Vt.makeRollupFake().toBuffer())}static makeFake(e=Ui){return new fe(ae.makeFake(e),Vt.makeFake().toBuffer())}toBuffer(){return I(this.keyAsFields,this.keyAsBytes.length,this.keyAsBytes)}toString(){return Qa(this.toBuffer())}static fromBuffer(e){const t=B.asReader(e),s=t.readObject(ae),a=t.readNumber(),r=t.readBytes(a);return new fe(s,r)}static fromString(e){return fe.fromBuffer(Qn(e))}clone(){return fe.fromBuffer(this.toBuffer())}toJSON(){return this.toBuffer()}static get schema(){return $a(fe)}}class rt{constructor(e,t,s){l(this,"publicInputs");l(this,"vk");l(this,"verificationKeyHints");this.publicInputs=e,this.vk=t,this.verificationKeyHints=s}static getFields(e){return[e.publicInputs,e.vk,e.verificationKeyHints]}static from(e){return new rt(...rt.getFields(e))}toBuffer(){return I(...rt.getFields(this))}static fromBuffer(e){const t=B.asReader(e);return new rt(t.readObject($i),t.readObject(ae),t.readObject(kt))}}class kt{constructor(e,t,s,a,r,i,o,c){l(this,"contractClassArtifactHash");l(this,"contractClassPublicBytecodeCommitment");l(this,"publicKeys");l(this,"saltedInitializationHash");l(this,"functionLeafMembershipWitness");l(this,"protocolContractMembershipWitness");l(this,"protocolContractLeaf");l(this,"updatedClassIdHints");this.contractClassArtifactHash=e,this.contractClassPublicBytecodeCommitment=t,this.publicKeys=s,this.saltedInitializationHash=a,this.functionLeafMembershipWitness=r,this.protocolContractMembershipWitness=i,this.protocolContractLeaf=o,this.updatedClassIdHints=c}static getFields(e){return[e.contractClassArtifactHash,e.contractClassPublicBytecodeCommitment,e.publicKeys,e.saltedInitializationHash,e.functionLeafMembershipWitness,e.protocolContractMembershipWitness,e.protocolContractLeaf,e.updatedClassIdHints]}static from(e){return new kt(...kt.getFields(e))}toBuffer(){return I(...kt.getFields(this))}static fromBuffer(e){const t=B.asReader(e);return new kt(t.readObject(f),t.readObject(f),t.readObject(nc),t.readObject(f),t.readObject(ee.deserializer(ba)),t.readObject(ee.deserializer(Mi)),t.readObject(Pt),t.readObject(zt))}}class zt{constructor(e,t,s){l(this,"updatedClassIdWitness");l(this,"updatedClassIdLeaf");l(this,"updatedClassIdValues");this.updatedClassIdWitness=e,this.updatedClassIdLeaf=t,this.updatedClassIdValues=s}static getFields(e){return[e.updatedClassIdWitness,e.updatedClassIdLeaf,e.updatedClassIdValues]}static from(e){return new zt(...zt.getFields(e))}toBuffer(){return I(...zt.getFields(this))}static fromBuffer(e){const t=B.asReader(e);return new zt(t.readObject(ee.deserializer(Qi)),t.readObject(tc),t.readObject({fromBuffer(s){return Zt.fromBuffer(s,As)}}))}}class ct{constructor(e,t){l(this,"request");l(this,"contractAddress");this.request=e,this.contractAddress=t}toBuffer(){return I(this.request,this.contractAddress)}static fromBuffer(e){const t=B.asReader(e);return new ct(cs.fromBuffer(t),E.fromBuffer(t))}toFields(){const e=[...this.request.toFields(),this.contractAddress.toField()];if(e.length!==jr)throw new Error(`Invalid number of fields for ScopedKeyValidationRequestAndGenerator. Expected ${jr}, got ${e.length}`);return e}static fromFields(e){const t=Qt.asReader(e);return new ct(cs.fromFields(t),E.fromFields(t))}isEmpty(){return this.request.isEmpty()&&this.contractAddress.isZero()}static empty(){return new ct(cs.empty(),E.ZERO)}}class Xe{constructor(e,t){l(this,"isSome");l(this,"value");this.isSome=e,this.value=t}getSize(){return this.toBuffer().length}static getFields(e){return[e.isSome,e.value]}toBuffer(){return I(...Xe.getFields(this))}static fromBuffer(e){const t=B.asReader(e);return new Xe(t.readBoolean(),t.readNumber())}toFields(){return er(...Xe.getFields(this))}static fromFields(e){const t=Qt.asReader(e);return new Xe(t.readBoolean(),t.readU32())}isEmpty(){return!this.isSome&&!this.value}static empty(){return new Xe(!1,0)}}class it{constructor(e,t,s,a,r){l(this,"forRollup");l(this,"noteHashReadRequests");l(this,"nullifierReadRequests");l(this,"scopedKeyValidationRequestsAndGenerators");l(this,"splitCounter");this.forRollup=e,this.noteHashReadRequests=t,this.nullifierReadRequests=s,this.scopedKeyValidationRequestsAndGenerators=a,this.splitCounter=r}getSize(){return this.forRollup.getSize()+_n(this.noteHashReadRequests)+_n(this.nullifierReadRequests)+_n(this.scopedKeyValidationRequestsAndGenerators)+this.splitCounter.getSize()}toBuffer(){return I(this.forRollup,this.noteHashReadRequests,this.nullifierReadRequests,this.scopedKeyValidationRequestsAndGenerators,this.splitCounter)}toString(){return Qa(this.toBuffer())}static fromFields(e){const t=Qt.asReader(e);return new it(t.readObject(ds),t.readArray(ce,Ke),t.readArray(de,Ke),t.readArray(Mt,ct),t.readObject(Xe))}static fromBuffer(e){const t=B.asReader(e);return new it(t.readObject(ds),t.readArray(ce,Ke),t.readArray(de,Ke),t.readArray(Mt,ct),t.readObject(Xe))}static fromString(e){return it.fromBuffer(Qn(e))}static empty(){return new it(ds.empty(),G(ce,Ke.empty),G(de,Ke.empty),G(Mt,ct.empty),Xe.empty())}[re.inspect.custom](){return`PrivateValidationRequests {
  forRollup: ${re.inspect(this.forRollup)},
  noteHashReadRequests: [${this.noteHashReadRequests.filter(e=>!e.isEmpty()).map(e=>re.inspect(e)).join(", ")}],
  nullifierReadRequests: [${this.nullifierReadRequests.filter(e=>!e.isEmpty()).map(e=>re.inspect(e)).join(", ")}],
  scopedKeyValidationRequestsAndGenerators: [${this.scopedKeyValidationRequestsAndGenerators.filter(e=>!e.isEmpty()).map(e=>re.inspect(e)).join(", ")}],
  splitCounter: ${this.splitCounter.getSize()}
  `}}class dt{constructor(e,t,s,a,r,i,o,c){l(this,"constants");l(this,"minRevertibleSideEffectCounter");l(this,"validationRequests");l(this,"end");l(this,"publicTeardownCallRequest");l(this,"feePayer");l(this,"isPrivateOnly");l(this,"claimedFirstNullifier");this.constants=e,this.minRevertibleSideEffectCounter=t,this.validationRequests=s,this.end=a,this.publicTeardownCallRequest=r,this.feePayer=i,this.isPrivateOnly=o,this.claimedFirstNullifier=c}static get schema(){return $a(dt)}toJSON(){return this.toBuffer()}toBuffer(){return I(this.constants,this.minRevertibleSideEffectCounter,this.validationRequests,this.end,this.publicTeardownCallRequest,this.feePayer,this.isPrivateOnly,this.claimedFirstNullifier)}static fromBuffer(e){const t=B.asReader(e);return new dt(t.readObject(ya),t.readObject(f),t.readObject(it),t.readObject(Rt),t.readObject(va),t.readObject(E),t.readBoolean(),t.readObject(f))}static empty(){return new dt(ya.empty(),f.zero(),it.empty(),Rt.empty(),va.empty(),E.ZERO,!1,f.zero())}}class Kt{constructor(e,t,s,a){l(this,"publicInputs");l(this,"verificationKey");l(this,"vkIndex");l(this,"vkPath");this.publicInputs=e,this.verificationKey=t,this.vkIndex=s,this.vkPath=a}toBuffer(){return I(this.publicInputs,this.verificationKey,this.vkIndex,this.vkPath)}static fromBuffer(e){const t=B.asReader(e);return new this(t.readObject(dt),t.readObject(fe),t.readNumber(),t.readArray(Yt,f))}static empty(){return new Kt(dt.empty(),fe.empty(),0,G(Yt,f.zero))}}class ir{constructor(e,t,s,a,r,i){l(this,"txRequest");l(this,"vkTreeRoot");l(this,"protocolContractTreeRoot");l(this,"privateCall");l(this,"isPrivateOnly");l(this,"firstNullifierHint");this.txRequest=e,this.vkTreeRoot=t,this.protocolContractTreeRoot=s,this.privateCall=a,this.isPrivateOnly=r,this.firstNullifierHint=i}toBuffer(){return I(this.txRequest,this.vkTreeRoot,this.protocolContractTreeRoot,this.privateCall,this.firstNullifierHint)}static fromBuffer(e){const t=B.asReader(e);return new ir(t.readObject(sc),f.fromBuffer(t),f.fromBuffer(t),t.readObject(rt),t.readBoolean(),f.fromBuffer(t))}}class or{constructor(e,t){l(this,"previousKernel");l(this,"privateCall");this.previousKernel=e,this.privateCall=t}toBuffer(){return I(this.previousKernel,this.privateCall)}static fromBuffer(e){const t=B.asReader(e);return new or(t.readObject(Kt),t.readObject(rt))}}class wu{constructor(e,t){l(this,"previousKernel");l(this,"hints");this.previousKernel=e,this.hints=t}toBuffer(){return I(this.previousKernel,this.hints)}}class xu{constructor(e,t,s){l(this,"previousKernel");l(this,"hints");l(this,"dimensions");this.previousKernel=e,this.hints=t,this.dimensions=s}toBuffer(){return I(this.previousKernel,this.hints,this.dimensions)}trimToSizes(){const e=this.hints.trimToSizes(this.dimensions.NOTE_HASH_PENDING_AMOUNT,this.dimensions.NOTE_HASH_SETTLED_AMOUNT,this.dimensions.NULLIFIER_PENDING_AMOUNT,this.dimensions.NULLIFIER_SETTLED_AMOUNT,this.dimensions.NULLIFIER_KEYS,this.dimensions.TRANSIENT_DATA_AMOUNT);return new wu(this.previousKernel,e)}}class je{constructor(e,t,s,a,r,i,o,c,d){l(this,"NOTE_HASH_PENDING_AMOUNT");l(this,"NOTE_HASH_SETTLED_AMOUNT");l(this,"NULLIFIER_PENDING_AMOUNT");l(this,"NULLIFIER_SETTLED_AMOUNT");l(this,"NULLIFIER_KEYS");l(this,"TRANSIENT_DATA_AMOUNT");l(this,"NOTE_HASH_SILOING_AMOUNT");l(this,"NULLIFIER_SILOING_AMOUNT");l(this,"PRIVATE_LOG_SILOING_AMOUNT");this.NOTE_HASH_PENDING_AMOUNT=e,this.NOTE_HASH_SETTLED_AMOUNT=t,this.NULLIFIER_PENDING_AMOUNT=s,this.NULLIFIER_SETTLED_AMOUNT=a,this.NULLIFIER_KEYS=r,this.TRANSIENT_DATA_AMOUNT=i,this.NOTE_HASH_SILOING_AMOUNT=o,this.NULLIFIER_SILOING_AMOUNT=c,this.PRIVATE_LOG_SILOING_AMOUNT=d}toBuffer(){return I(this.NOTE_HASH_PENDING_AMOUNT,this.NOTE_HASH_SETTLED_AMOUNT,this.NULLIFIER_PENDING_AMOUNT,this.NULLIFIER_SETTLED_AMOUNT,this.NULLIFIER_KEYS,this.TRANSIENT_DATA_AMOUNT,this.NOTE_HASH_SILOING_AMOUNT,this.NULLIFIER_SILOING_AMOUNT,this.PRIVATE_LOG_SILOING_AMOUNT)}static empty(){return new je(0,0,0,0,0,0,0,0,0)}static from(e){const t=je.empty();return we.forEach(s=>t[s]=e[s]??0),t}static fromValues(e){if(e.length!==we.length)throw new Error(`Not enough values for all dimensions. Required ${we.length}. Got ${e.length}.`);const t=je.empty();return we.forEach((s,a)=>t[s]=e[a]),t}toValues(){return we.map(e=>this[e])}}const we=["NOTE_HASH_PENDING_AMOUNT","NOTE_HASH_SETTLED_AMOUNT","NULLIFIER_PENDING_AMOUNT","NULLIFIER_SETTLED_AMOUNT","NULLIFIER_KEYS","TRANSIENT_DATA_AMOUNT","NOTE_HASH_SILOING_AMOUNT","NULLIFIER_SILOING_AMOUNT","PRIVATE_LOG_SILOING_AMOUNT"];class lr{constructor(e){l(this,"previousKernel");this.previousKernel=e}isForPublic(){return ne(this.previousKernel.publicInputs.end.publicCallRequests)>0||!this.previousKernel.publicInputs.publicTeardownCallRequest.isEmpty()}toBuffer(){return I(this.previousKernel)}static fromBuffer(e){const t=B.asReader(e);return new lr(t.readObject(Kt))}}class Ze{constructor(e,t,s){l(this,"noteHashes");l(this,"nullifiers");l(this,"l2ToL1Msgs");this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=s}static get schema(){return Ja({noteHashes:ot.Fr.array().min(se).max(se),nullifiers:ot.Fr.array().min(le).max(le),l2ToL1Msgs:At.schema.array().min(Te).max(Te)}).transform(({noteHashes:e,nullifiers:t,l2ToL1Msgs:s})=>new Ze(_e(e,se),_e(t,le),_e(s,Te)))}getSize(){return _n(this.noteHashes)+_n(this.nullifiers)+_n(this.l2ToL1Msgs)}static getFields(e){return[e.noteHashes,e.nullifiers,e.l2ToL1Msgs]}static fromFields(e){const t=Qt.asReader(e);return new this(t.readFieldArray(se),t.readFieldArray(le),t.readArray(Te,At))}toFields(){const e=er(...Ze.getFields(this));if(e.length!==Ir)throw new Error(`Invalid number of fields for PrivateToAvmAccumulatedData. Expected ${Ir}, got ${e.length}`);return e}static from(e){return new Ze(...Ze.getFields(e))}static fromBuffer(e){const t=B.asReader(e);return new Ze(t.readArray(se,f),t.readArray(le,f),t.readArray(Te,At))}toBuffer(){return I(...Ze.getFields(this))}static empty(){return new Ze(G(se,f.zero),G(le,f.zero),G(Te,At.empty))}[re.inspect.custom](){return`PrivateToAvmAccumulatedData {
      noteHashes: [${this.noteHashes.filter(e=>!e.isZero()).map(e=>re.inspect(e)).join(", ")}],
      nullifiers: [${this.nullifiers.filter(e=>!e.isZero()).map(e=>re.inspect(e)).join(", ")}],
      l2ToL1Msgs: [${this.l2ToL1Msgs.filter(e=>!e.isEmpty()).map(e=>re.inspect(e)).join(", ")}],
    }`}}class wt{constructor(e,t,s){l(this,"noteHashes");l(this,"nullifiers");l(this,"l2ToL1Msgs");this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=s}static get schema(){return Ja({noteHashes:ot.UInt32,nullifiers:ot.UInt32,l2ToL1Msgs:ot.UInt32}).transform(({noteHashes:e,nullifiers:t,l2ToL1Msgs:s})=>new wt(e,t,s))}getSize(){return 4*3}static getFields(e){return[e.noteHashes,e.nullifiers,e.l2ToL1Msgs]}static fromFields(e){const t=Qt.asReader(e);return new this(t.readU32(),t.readU32(),t.readU32())}toFields(){return[this.noteHashes,this.nullifiers,this.l2ToL1Msgs]}static from(e){return new wt(...wt.getFields(e))}static fromBuffer(e){const t=B.asReader(e);return new wt(t.readNumber(),t.readNumber(),t.readNumber())}toBuffer(){return I(...wt.getFields(this))}static empty(){return new wt(0,0,0)}[re.inspect.custom](){return`PrivateToAvmAccumulatedDataArrayLengths {
      noteHashes: ${this.noteHashes},
      nullifiers: ${this.nullifiers},
      l2ToL1Msgs: ${this.l2ToL1Msgs},
    }`}}var K=function(n){return n[n.NADA=0]="NADA",n[n.PENDING=1]="PENDING",n[n.SETTLED=2]="SETTLED",n}({});class xe{constructor(e,t){l(this,"state");l(this,"hintIndex");this.state=e,this.hintIndex=t}static nada(){return new xe(0,0)}static pending(e){return new xe(1,e)}static settled(e){return new xe(2,e)}static fromBuffer(e){const t=B.asReader(e);return new xe(t.readNumber(),t.readNumber())}toBuffer(){return I(this.state,this.hintIndex)}}class Ie{constructor(e,t){l(this,"readRequestIndex");l(this,"pendingValueIndex");this.readRequestIndex=e,this.pendingValueIndex=t}static nada(e){return new Ie(e,0)}static fromBuffer(e){const t=B.asReader(e);return new Ie(t.readNumber(),t.readNumber())}toBuffer(){return I(this.readRequestIndex,this.pendingValueIndex)}}class ht{constructor(e,t,s){l(this,"readRequestIndex");l(this,"membershipWitness");l(this,"leafPreimage");this.readRequestIndex=e,this.membershipWitness=t,this.leafPreimage=s}static nada(e,t,s){return new ht(e,ee.empty(t),s())}static fromBuffer(e,t,s){const a=B.asReader(e);return new ht(a.readNumber(),ee.fromBuffer(a,t),a.readObject(s))}toBuffer(){return I(this.readRequestIndex,this.membershipWitness,this.leafPreimage)}}class Jt{constructor(e,t,s){l(this,"readRequestStatuses");l(this,"pendingReadHints");l(this,"settledReadHints");this.readRequestStatuses=e,this.pendingReadHints=t,this.settledReadHints=s}trimToSizes(e,t){return new Jt(this.readRequestStatuses,this.pendingReadHints.slice(0,e),this.settledReadHints.slice(0,t))}static fromBuffer(e,t,s,a,r,i){const o=B.asReader(e);return new Jt(o.readArray(t,xe),o.readArray(s,Ie),o.readArray(a,{fromBuffer:c=>ht.fromBuffer(c,r,i)}))}toBuffer(){return I(this.readRequestStatuses,this.pendingReadHints,this.settledReadHints)}}class kn{constructor(e,t){l(this,"states");l(this,"pendingReadHints");this.states=e,this.pendingReadHints=t}static empty(e){return new kn(G(e,()=>0),[])}}function Au(n,e,t){return Jt.fromBuffer(n,ce,e,t,eo,f)}class cr{constructor(e,t){l(this,"maxPending");l(this,"maxSettled");l(this,"hints");l(this,"numPendingReadHints");l(this,"numSettledReadHints");this.maxPending=e,this.maxSettled=t,this.numPendingReadHints=0,this.numSettledReadHints=0,this.hints=new Jt(G(ce,xe.nada),G(e,()=>Ie.nada(ce)),G(t,()=>ht.nada(ce,eo,f.zero)))}static empty(e,t){return new cr(e,t).toHints()}addPendingReadRequest(e,t){if(this.numPendingReadHints===this.maxPending)throw new Error("Cannot add more pending read request.");this.hints.readRequestStatuses[e]=new xe(K.PENDING,this.numPendingReadHints),this.hints.pendingReadHints[this.numPendingReadHints]=new Ie(e,t),this.numPendingReadHints++}addSettledReadRequest(e,t,s){if(this.numSettledReadHints===this.maxSettled)throw new Error("Cannot add more settled read request.");this.hints.readRequestStatuses[e]=new xe(K.SETTLED,this.numSettledReadHints),this.hints.settledReadHints[this.numSettledReadHints]=new ht(e,t,s),this.numSettledReadHints++}toHints(){return this.hints}}class Es{constructor(e){l(this,"cache",new Map);e.forEach(t=>{const s=t.value.toBigInt(),a=this.cache.get(s)??[];a.push(t),this.cache.set(s,a)})}get(e){return this.cache.get(e.value.toBigInt())??[]}}function ka(n,e){return e.value.equals(n.value)&&e.contractAddress.equals(n.contractAddress)&&n.counter>e.counter}function Pu(n,e,t){var o;const s=kn.empty(ce),a=new Map;An(e).forEach((c,d)=>{const _=c.value.toBigInt(),m=a.get(_)??[];m.push({noteHash:c,index:d}),a.set(_,m)});const r=new Es(t),i=ne(n);for(let c=0;c<i;++c){const d=n[c],_=(o=a.get(d.value.toBigInt()))==null?void 0:o.find(m=>ka(d,m.noteHash));_!==void 0?(s.states[c]=K.PENDING,s.pendingReadHints.push(new Ie(c,_.index))):r.get(d).find(m=>ka(d,m))||(s.states[c]=K.SETTLED)}return s}async function ku(n,e,t,s,a,r=ce,i=ce){const o=new cr(r,i);s.pendingReadHints.forEach(d=>{o.addPendingReadRequest(d.readRequestIndex,d.pendingValueIndex)});for(let d=0;d<s.states.length;d++)if(s.states[d]===K.SETTLED){const _=e[d],m=a.get(_.value.toBigInt());if(m===void 0)throw new Error("Read request is reading an unknown note hash.");const h=await n.getNoteHashMembershipWitness(m);o.addSettledReadRequest(d,h,_.value)}const c=new Map;return An(t).forEach((d,_)=>{const m=d.value.toBigInt(),h=c.get(m)??[];h.push({noteHash:d,index:_}),c.set(m,h)}),o.toHints()}function zu(n,e,t){return Jt.fromBuffer(n,de,e,t,tr,to)}class dr{constructor(e,t){l(this,"maxPending");l(this,"maxSettled");l(this,"hints");l(this,"numPendingReadHints");l(this,"numSettledReadHints");this.maxPending=e,this.maxSettled=t,this.numPendingReadHints=0,this.numSettledReadHints=0,this.hints=new Jt(G(de,xe.nada),G(e,()=>Ie.nada(de)),G(t,()=>ht.nada(de,tr,to.empty)))}static empty(e,t){return new dr(e,t).toHints()}addPendingReadRequest(e,t){if(this.numPendingReadHints===this.maxPending)throw new Error("Cannot add more pending read request.");this.hints.readRequestStatuses[e]=new xe(K.PENDING,this.numPendingReadHints),this.hints.pendingReadHints[this.numPendingReadHints]=new Ie(e,t),this.numPendingReadHints++}addSettledReadRequest(e,t,s){if(this.numSettledReadHints===this.maxSettled)throw new Error("Cannot add more settled read request.");this.hints.readRequestStatuses[e]=new xe(K.SETTLED,this.numSettledReadHints),this.hints.settledReadHints[this.numSettledReadHints]=new ht(e,t,s),this.numSettledReadHints++}toHints(){return this.hints}}function za(n,e){return n.value.equals(e.value)&&e.contractAddress.equals(n.contractAddress)&&n.counter>e.counter}function Nu(n,e,t){var o;const s=kn.empty(de),a=new Map;An(e).forEach((c,d)=>{const _=c.value.toBigInt(),m=a.get(_)??[];m.push({nullifier:c,index:d}),a.set(_,m)});const r=new Es(t),i=ne(n);for(let c=0;c<i;++c){const d=n[c],_=(o=a.get(d.value.toBigInt()))==null?void 0:o.find(({nullifier:m})=>za(d,m));_!==void 0?(s.states[c]=K.PENDING,s.pendingReadHints.push(new Ie(c,_.index))):r.get(d).some(m=>za(d,m))||(s.states[c]=K.SETTLED)}return s}async function Ou(n,e,t,s=de,a=de,r=!1){const i=new dr(s,a);t.pendingReadHints.forEach(o=>{i.addPendingReadRequest(o.readRequestIndex,o.pendingValueIndex)});for(let o=0;o<t.states.length;o++)if(t.states[o]===K.SETTLED){const c=e[o],d=r?c.value:await Pn(c.contractAddress,c.value),_=await n.getNullifierMembershipWitness(d);i.addSettledReadRequest(o,_.membershipWitness,_.leafPreimage)}return i.toHints()}class ut{constructor(e,t){l(this,"nullifierIndex");l(this,"noteHashIndex");this.nullifierIndex=e,this.noteHashIndex=t}toFields(){return[new f(this.nullifierIndex),new f(this.noteHashIndex)]}static fromFields(e){const t=Qt.asReader(e);return new ut(t.readU32(),t.readU32())}isEmpty(){return!this.nullifierIndex&&!this.noteHashIndex}static empty(){return new ut(0,0)}toBuffer(){return I(this.nullifierIndex,this.noteHashIndex)}static fromBuffer(e){const t=B.asReader(e);return new ut(t.readNumber(),t.readNumber())}toString(){return`nullifierIndex=${this.nullifierIndex} noteHashIndex=${this.noteHashIndex}`}[re.inspect.custom](){return`TransientDataIndexHint { ${this.toString()} }`}}function Tu(n,e,t,s,a,r,i=n.length,o=e.length){const c=new Es(t),d=new Es(s),_=new Map;e.forEach((g,b)=>_.set(g.counter,b));const m=[],h=ne(n);for(let g=0;g<h;g++){const b=n[g],N=a.get(b.counter);if(!N||c.get(b).find(P=>ka(P,b)))continue;const A=_.get(N);if(A===void 0)continue;const x=e[A];if(!(b.counter<r&&x.counter>=r)){if(x.counter<b.counter)throw new Error("Hinted nullifier has smaller counter than note hash.");if(!x.contractAddress.equals(b.contractAddress))throw new Error("Contract address of hinted note hash does not match.");x.nullifiedNoteHash.equals(b.value)&&(d.get(x).find(P=>za(P,x))||m.push(new ut(A,g)))}}return{numTransientData:m.length,hints:no(m,new ut(o,i),o)}}function Eu(n){return n!==void 0}function ur(n,e){return we.reduce((t,s)=>t+n[s]*e.dimensions[s].cost,0)}function Lu(n){return we.reduce((e,t)=>e+n[t],0)}function fr(n,e){const t=je.empty();let s=0;return we.forEach(a=>{n[a]>e[a]&&(s++,t[a]=n[a]-e[a])}),s?t:void 0}function ko(n,e){return e.reduce((s,a)=>a>=n&&(s===void 0||a<s)?a:s,void 0)??Math.max(...e)}function Su(n){return n.reduce((e,t)=>t.cost<e.cost?t:e,n[0])}function Hu(n){var t;const e=n.filter(s=>s.remainder).map(s=>({option:s,size:Lu(s.remainder)}));return(t=e.reduce((s,a)=>a.size<s.size?a:s,e[0]))==null?void 0:t.option}function zo(n){const e=n.filter(s=>!s.remainder),t=n.filter(s=>s.remainder);return Su(e)||Hu(t)}function Xu(n,e,t){const s=je.empty();if(we.forEach(a=>{s[a]=ko(n[a],e.dimensions[a].variants)}),!!t(s))return{dimensions:s,cost:ur(s,e),remainder:fr(n,s)}}function Cu(n,e,t){const s=we.filter(o=>n[o]>0);if(s.length!==1)return;const a=s[0],r=ko(n[a],e.dimensions[a].standalone);if(!r)return;const i=je.from({[a]:r});if(t(i))return{dimensions:i,cost:ur(i,e),remainder:fr(n,i)}}function Du(n,e,t){const a=e.specialCases.map(je.fromValues).filter(t).map(r=>({dimensions:r,cost:ur(r,e),remainder:fr(n,r)}));return zo(a)}function ju(n,e,t=!1,s=!1){const a=n.toValues(),r=s?()=>!0:c=>c.toValues().every((d,_)=>d>=a[_]),i=t?c=>c.NOTE_HASH_SILOING_AMOUNT===0&&c.NULLIFIER_SILOING_AMOUNT===0&&c.PRIVATE_LOG_SILOING_AMOUNT===0&&r(c):r,o=[Xu(n,e,i),Cu(n,e,i),Du(n,e,i)].filter(Eu);if(!o.length)throw new Error(`Cannot find an option for dimension: ${n.toValues()}`);return zo(o).dimensions}class zn{constructor(e,t){l(this,"skM");l(this,"requestIndex");this.skM=e,this.requestIndex=t}static fromBuffer(e){const t=B.asReader(e);return new zn(t.readObject(cn),t.readNumber())}toBuffer(){return I(this.skM,this.requestIndex)}static nada(e){return new zn(cn.zero(),e)}}class Ls{constructor(e,t,s,a,r){l(this,"noteHashReadRequestHints");l(this,"nullifierReadRequestHints");l(this,"keyValidationHints");l(this,"transientDataIndexHints");l(this,"validationRequestsSplitCounter");this.noteHashReadRequestHints=e,this.nullifierReadRequestHints=t,this.keyValidationHints=s,this.transientDataIndexHints=a,this.validationRequestsSplitCounter=r}toBuffer(){return I(this.noteHashReadRequestHints,this.nullifierReadRequestHints,this.keyValidationHints,this.transientDataIndexHints,this.validationRequestsSplitCounter)}trimToSizes(e,t,s,a,r,i){return new Ls(this.noteHashReadRequestHints.trimToSizes(e,t),this.nullifierReadRequestHints.trimToSizes(s,a),this.keyValidationHints.slice(0,r),this.transientDataIndexHints.slice(0,i),this.validationRequestsSplitCounter)}static fromBuffer(e,t,s,a,r,i,o){const c=B.asReader(e);return new Ls(c.readObject({fromBuffer:d=>Au(d,t,s)}),c.readObject({fromBuffer:d=>zu(d,a,r)}),c.readArray(i,zn),c.readArray(o,ut),c.readNumber())}}class _r{constructor(e,t,s,a){l(this,"callContext");l(this,"historicalHeader");l(this,"txContext");l(this,"startSideEffectCounter");this.callContext=e,this.historicalHeader=t,this.txContext=s,this.startSideEffectCounter=a}static empty(){return new _r(Ds.empty(),Ps.empty(),Ua.empty(),0)}toFields(){return er([this.callContext,this.historicalHeader,this.txContext,this.startSideEffectCounter])}}var W;class No{constructor(e){w(this,W);z(this,W,e.openMap("key_store"))}createAccount(){const e=f.random(),t=f.random();return this.addAccount(e,t)}async addAccount(e,t){const{masterNullifierSecretKey:s,masterIncomingViewingSecretKey:a,masterOutgoingViewingSecretKey:r,masterTaggingSecretKey:i,publicKeys:o}=await ac(e),c=await us.fromSecretKeyAndPartialAddress(e,t),{address:d}=c;await u(this,W).set(`${d.toString()}-ivsk_m`,a.toBuffer()),await u(this,W).set(`${d.toString()}-ovsk_m`,r.toBuffer()),await u(this,W).set(`${d.toString()}-tsk_m`,i.toBuffer()),await u(this,W).set(`${d.toString()}-nsk_m`,s.toBuffer()),await u(this,W).set(`${d.toString()}-npk_m`,o.masterNullifierPublicKey.toBuffer()),await u(this,W).set(`${d.toString()}-ivpk_m`,o.masterIncomingViewingPublicKey.toBuffer()),await u(this,W).set(`${d.toString()}-ovpk_m`,o.masterOutgoingViewingPublicKey.toBuffer()),await u(this,W).set(`${d.toString()}-tpk_m`,o.masterTaggingPublicKey.toBuffer());const _=await o.masterNullifierPublicKey.hash();await u(this,W).set(`${d.toString()}-npk_m_hash`,_.toBuffer());const m=await o.masterIncomingViewingPublicKey.hash();await u(this,W).set(`${d.toString()}-ivpk_m_hash`,m.toBuffer());const h=await o.masterOutgoingViewingPublicKey.hash();await u(this,W).set(`${d.toString()}-ovpk_m_hash`,h.toBuffer());const g=await o.masterTaggingPublicKey.hash();return await u(this,W).set(`${d.toString()}-tpk_m_hash`,g.toBuffer()),c}async getAccounts(){return(await M(u(this,W).keysAsync())).filter(s=>s.endsWith("-ivsk_m")).map(s=>s.split("-")[0]).map(s=>E.fromString(s))}async getKeyValidationRequest(e,t){const[s,a]=await this.getKeyPrefixAndAccount(e),r=await u(this,W).getAsync(`${a.toString()}-${s}pk_m`);if(!r)throw new Error(`Could not find ${s}pk_m for account ${a.toString()} whose address was successfully obtained with ${s}pk_m_hash ${e.toString()}.`);const i=Je.fromBuffer(r);if(!(await i.hash()).equals(e))throw new Error(`Could not find ${s}pkM for ${s}pk_m_hash ${e.toString()}.`);const c=await u(this,W).getAsync(`${a.toString()}-${s}sk_m`);if(!c)throw new Error(`Could not find ${s}sk_m for account ${a.toString()} whose address was successfully obtained with ${s}pk_m_hash ${e.toString()}.`);const d=cn.fromBuffer(c);if(!(await Br(d)).equals(i))throw new Error(`Could not derive ${s}pkM from ${s}skM.`);const m=await rc(d,t,s);return new so(i,m)}async getMasterNullifierPublicKey(e){const t=await u(this,W).getAsync(`${e.toString()}-npk_m`);if(!t)throw new Error(`Account ${e.toString()} does not exist. Registered accounts: ${await this.getAccounts()}.`);return Je.fromBuffer(t)}async getMasterIncomingViewingPublicKey(e){const t=await u(this,W).getAsync(`${e.toString()}-ivpk_m`);if(!t)throw new Error(`Account ${e.toString()} does not exist. Registered accounts: ${await this.getAccounts()}.`);return Je.fromBuffer(t)}async getMasterOutgoingViewingPublicKey(e){const t=await u(this,W).getAsync(`${e.toString()}-ovpk_m`);if(!t)throw new Error(`Account ${e.toString()} does not exist. Registered accounts: ${await this.getAccounts()}.`);return Je.fromBuffer(t)}async getMasterTaggingPublicKey(e){const t=await u(this,W).getAsync(`${e.toString()}-tpk_m`);if(!t)throw new Error(`Account ${e.toString()} does not exist. Registered accounts: ${await this.getAccounts()}.`);return Je.fromBuffer(t)}async getMasterIncomingViewingSecretKey(e){const t=await u(this,W).getAsync(`${e.toString()}-ivsk_m`);if(!t)throw new Error(`Account ${e.toString()} does not exist. Registered accounts: ${await this.getAccounts()}.`);return cn.fromBuffer(t)}async getAppOutgoingViewingSecretKey(e,t){const s=await u(this,W).getAsync(`${e.toString()}-ovsk_m`);if(!s)throw new Error(`Account ${e.toString()} does not exist. Registered accounts: ${await this.getAccounts()}.`);const a=cn.fromBuffer(s);return ic([a.hi,a.lo,t],oc.OVSK_M)}async getMasterSecretKey(e){const[t,s]=await this.getKeyPrefixAndAccount(e),a=await u(this,W).getAsync(`${s.toString()}-${t}sk_m`);if(!a)throw new Error(`Could not find ${t}sk_m for ${t}pk_m ${e.toString()}. This should not happen.`);const r=cn.fromBuffer(a);if(!(await Br(r)).equals(e))throw new Error(`Could not find ${t}skM for ${t}pkM ${e.toString()} in secret keys buffer.`);return Promise.resolve(r)}async getKeyPrefixAndAccount(e){const t=I(e);for await(const[s,a]of u(this,W).entriesAsync())if(Buffer.from(a).equals(t)){for(const r of Nd)if(s.includes(`-${r}`)){const i=E.fromString(s.split("-")[0]);return[r,i]}}throw new Error("Could not find key prefix.")}}W=new WeakMap,l(No,"SCHEMA_VERSION",1);class Iu{constructor(e,t){l(this,"l2TipsStore");l(this,"l2BlockHashesStore");this.l2TipsStore=e.openMap([t,"l2_tips"].join("_")),this.l2BlockHashesStore=e.openMap([t,"l2_block_hashes"].join("_"))}getL2BlockHash(e){return this.l2BlockHashesStore.getAsync(e)}async getL2Tips(){return{latest:await this.getL2Tip("latest"),finalized:await this.getL2Tip("finalized"),proven:await this.getL2Tip("proven")}}async getL2Tip(e){const t=await this.l2TipsStore.getAsync(e);if(t===void 0||t===0)return{number:0,hash:void 0};const s=await this.l2BlockHashesStore.getAsync(t);if(!s)throw new Error(`Block hash not found for block number ${t}`);return{number:t,hash:s}}async handleBlockStreamEvent(e){switch(e.type){case"blocks-added":{const t=e.blocks.map(s=>s.block);for(const s of t)await this.l2BlockHashesStore.set(s.number,(await s.header.hash()).toString());await this.l2TipsStore.set("latest",t.at(-1).number);break}case"chain-pruned":await this.saveTag("latest",e.block);break;case"chain-proven":await this.saveTag("proven",e.block);break;case"chain-finalized":await this.saveTag("finalized",e.block);for await(const t of this.l2BlockHashesStore.keysAsync({end:e.block.number}))await this.l2BlockHashesStore.delete(t);break}}async saveTag(e,t){await this.l2TipsStore.set(e,t.number),t.hash&&await this.l2BlockHashesStore.set(t.number,t.hash)}}class pr extends Error{constructor(t,s,a,r){super(t,r);l(this,"failingFunction");l(this,"noirCallStack");this.failingFunction=s,this.noirCallStack=a}}function Oo(n,e){let t=n;for(;t;)e(t),t.cause&&t.cause instanceof Error?t=t.cause:t=void 0}function oi(n,e){let t=n,s;const a=[];return Oo(n,r=>{t=r,r instanceof pr&&(a.push(r.failingFunction),r.noirCallStack&&(s=r.noirCallStack))}),new Sn(t.message,a,e,s,{cause:t})}function To(n,e,t,s){let a=n.flatMap(r=>Bu(r,e,t,s));if(a.length>0){const r=n[n.length-1].split(".");if(r.length===2){const i=e.acir_locations[r[0]];if(i!==void 0){const o=e.location_tree.locations[i];a=Eo(o,e.location_tree.locations,t).concat(a)}}}return a}function Eo(n,e,t){const s=[];for(;n.parent!==null;){const{file:a,span:r}=n.value,{path:i,source:o}=t[a],c=o.substring(r.start,r.end),_=o.substring(0,r.start).split(`
`),m=_.length,h=_[_.length-1].length+1;s.unshift({filePath:i,line:m,column:h,fileSource:o,locationText:c}),n=e[n.parent]}return s}function Bu(n,e,t,s){let a=e.acir_locations[n];const r=Fu(n);if(s!==void 0&&r!==void 0&&(a=e.brillig_locations[s][r],a===void 0))return[];if(a===void 0)return[];const i=e.location_tree.locations[a];return Eo(i,e.location_tree.locations,t)}function Fu(n){const e=n.split(".");if(e.length===2)return e[1]}function Lo(n,e){const t=yo({parameters:[],error_types:e.errorTypes,return_type:null},n);return typeof t=="string"?t:lc(t)}function qu(n,e){if(n.length==0)return;const[t,...s]=n;return Lo({selector:t.toBigInt().toString(),data:s.map(a=>a.toString())},e)}function So(n,e){return typeof n=="object"&&n!==null&&"rawAssertionPayload"in n&&n.rawAssertionPayload?`Assertion failed: ${Lo(n.rawAssertionPayload,e)}`:n.message}let q;function Xn(n){const e=q.__externref_table_alloc();return q.__wbindgen_export_2.set(e,n),e}function sn(n,e){try{return n.apply(this,e)}catch(t){const s=Xn(t);q.__wbindgen_exn_store(s)}}const Ho=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&Ho.decode();let Cn=null;function Fn(){return(Cn===null||Cn.byteLength===0)&&(Cn=new Uint8Array(q.memory.buffer)),Cn}function an(n,e){return n=n>>>0,Ho.decode(Fn().subarray(n,n+e))}let ft=0;const ps=typeof TextEncoder<"u"?new TextEncoder("utf-8"):{encode:()=>{throw Error("TextEncoder not available")}},Wu=typeof ps.encodeInto=="function"?function(n,e){return ps.encodeInto(n,e)}:function(n,e){const t=ps.encode(n);return e.set(t),{read:n.length,written:t.length}};function Ys(n,e,t){if(t===void 0){const o=ps.encode(n),c=e(o.length,1)>>>0;return Fn().subarray(c,c+o.length).set(o),ft=o.length,c}let s=n.length,a=e(s,1)>>>0;const r=Fn();let i=0;for(;i<s;i++){const o=n.charCodeAt(i);if(o>127)break;r[a+i]=o}if(i!==s){i!==0&&(n=n.slice(i)),a=t(a,s,s=i+n.length*3,1)>>>0;const o=Fn().subarray(a+i,a+s),c=Wu(n,o);i+=c.written,a=t(a,s,i,1)>>>0}return ft=i,a}let xt=null;function Ge(){return(xt===null||xt.buffer.detached===!0||xt.buffer.detached===void 0&&xt.buffer!==q.memory.buffer)&&(xt=new DataView(q.memory.buffer)),xt}function gt(n){return n==null}const li=typeof FinalizationRegistry>"u"?{register:()=>{},unregister:()=>{}}:new FinalizationRegistry(n=>{q.__wbindgen_export_6.get(n.dtor)(n.a,n.b)});function Mu(n,e,t,s){const a={a:n,b:e,cnt:1,dtor:t},r=(...i)=>{a.cnt++;const o=a.a;a.a=0;try{return s(o,a.b,...i)}finally{--a.cnt===0?(q.__wbindgen_export_6.get(a.dtor)(o,a.b),li.unregister(a)):a.a=o}};return r.original=a,li.register(r,a,a),r}function Na(n){const e=typeof n;if(e=="number"||e=="boolean"||n==null)return`${n}`;if(e=="string")return`"${n}"`;if(e=="symbol"){const a=n.description;return a==null?"Symbol":`Symbol(${a})`}if(e=="function"){const a=n.name;return typeof a=="string"&&a.length>0?`Function(${a})`:"Function"}if(Array.isArray(n)){const a=n.length;let r="[";a>0&&(r+=Na(n[0]));for(let i=1;i<a;i++)r+=", "+Na(n[i]);return r+="]",r}const t=/\[object ([^\]]+)\]/.exec(toString.call(n));let s;if(t&&t.length>1)s=t[1];else return toString.call(n);if(s=="Object")try{return"Object("+JSON.stringify(n)+")"}catch{return"Object"}return n instanceof Error?`${n.name}: ${n.message}
${n.stack}`:s}function Xo(n,e){const t=e(n.length*1,1)>>>0;return Fn().set(n,t/1),ft=n.length,t}function Ru(n,e,t){const s=Xo(n,q.__wbindgen_malloc),a=ft;return q.executeCircuit(s,a,e,t)}function Vu(n,e,t){const s=Xo(n,q.__wbindgen_malloc),a=ft;return q.executeCircuitWithReturnWitness(s,a,e,t)}function Yu(n,e,t){q.closure255_externref_shim(n,e,t)}function Gu(n,e,t,s,a){q.closure807_externref_shim(n,e,t,s,a)}function ci(n,e,t,s){q.closure811_externref_shim(n,e,t,s)}async function Zu(n,e){if(typeof Response=="function"&&n instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(n,e)}catch(s){if(n.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",s);else throw s}const t=await n.arrayBuffer();return await WebAssembly.instantiate(t,e)}else{const t=await WebAssembly.instantiate(n,e);return t instanceof WebAssembly.Instance?{instance:t,module:n}:t}}function Ku(){const n={};return n.wbg={},n.wbg.__wbg_call_672a4d21634d4a24=function(){return sn(function(e,t){return e.call(t)},arguments)},n.wbg.__wbg_call_7cccdd69e0791ae2=function(){return sn(function(e,t,s){return e.call(t,s)},arguments)},n.wbg.__wbg_call_833bed5770ea2041=function(){return sn(function(e,t,s,a){return e.call(t,s,a)},arguments)},n.wbg.__wbg_constructor_3e5bc3dc79a9d0b5=function(e){return new Error(e)},n.wbg.__wbg_constructor_635df50143ef60f3=function(e){return new Error(e)},n.wbg.__wbg_debug_3cb59063b29f58c1=function(e){console.debug(e)},n.wbg.__wbg_debug_e17b51583ca6a632=function(e,t,s,a){console.debug(e,t,s,a)},n.wbg.__wbg_error_524f506f44df1645=function(e){console.error(e)},n.wbg.__wbg_error_7534b8e9a36f1ab4=function(e,t){let s,a;try{s=e,a=t,console.error(an(e,t))}finally{q.__wbindgen_free(s,a,1)}},n.wbg.__wbg_error_80de38b3f7cc3c3c=function(e,t,s,a){console.error(e,t,s,a)},n.wbg.__wbg_forEach_d6a05ca96422eff9=function(e,t,s){try{var a={a:t,b:s},r=(i,o,c)=>{const d=a.a;a.a=0;try{return Gu(d,a.b,i,o,c)}finally{a.a=d}};e.forEach(r)}finally{a.a=a.b=0}},n.wbg.__wbg_forEach_e1cf6f7c8ecb7dae=function(e,t,s){try{var a={a:t,b:s},r=(i,o)=>{const c=a.a;a.a=0;try{return ci(c,a.b,i,o)}finally{a.a=c}};e.forEach(r)}finally{a.a=a.b=0}},n.wbg.__wbg_fromEntries_524679eecb0bdc2e=function(){return sn(function(e){return Object.fromEntries(e)},arguments)},n.wbg.__wbg_from_2a5d3e218e67aa85=function(e){return Array.from(e)},n.wbg.__wbg_get_b9b93047fe3cf45b=function(e,t){return e[t>>>0]},n.wbg.__wbg_info_033d8b8a0838f1d3=function(e,t,s,a){console.info(e,t,s,a)},n.wbg.__wbg_info_3daf2e093e091b66=function(e){console.info(e)},n.wbg.__wbg_length_e2d2a49132c1b256=function(e){return e.length},n.wbg.__wbg_new_23a2665fac83c611=function(e,t){try{var s={a:e,b:t},a=(i,o)=>{const c=s.a;s.a=0;try{return ci(c,s.b,i,o)}finally{s.a=c}};return new Promise(a)}finally{s.a=s.b=0}},n.wbg.__wbg_new_25051b8b4ad00d54=function(){return new Array},n.wbg.__wbg_new_5e0be73521bc8c17=function(){return new Map},n.wbg.__wbg_new_78feb108b6472713=function(){return new Array},n.wbg.__wbg_new_8a6f238a6ece86ea=function(){return new Error},n.wbg.__wbg_new_8c9cda6002b75bf5=function(){return new Map},n.wbg.__wbg_new_c68d7209be747379=function(e,t){return new Error(an(e,t))},n.wbg.__wbg_newnoargs_105ed471475aaf50=function(e,t){return new Function(an(e,t))},n.wbg.__wbg_parse_def2e24ef1252aff=function(){return sn(function(e,t){return JSON.parse(an(e,t))},arguments)},n.wbg.__wbg_push_737cfc8c1432c2c6=function(e,t){return e.push(t)},n.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5=function(e){queueMicrotask(e)},n.wbg.__wbg_queueMicrotask_d3219def82552485=function(e){return e.queueMicrotask},n.wbg.__wbg_resolve_4851785c9c5f573d=function(e){return Promise.resolve(e)},n.wbg.__wbg_reverse_71c11f9686a5c11b=function(e){return e.reverse()},n.wbg.__wbg_set_8fc6bf8a5b1071d1=function(e,t,s){return e.set(t,s)},n.wbg.__wbg_set_bb8cecf6a62b9f46=function(){return sn(function(e,t,s){return Reflect.set(e,t,s)},arguments)},n.wbg.__wbg_setcause_180f5110152d3ce3=function(e,t){e.cause=t},n.wbg.__wbg_stack_0ed75d68575b0f3c=function(e,t){const s=t.stack,a=Ys(s,q.__wbindgen_malloc,q.__wbindgen_realloc),r=ft;Ge().setInt32(e+4*1,r,!0),Ge().setInt32(e+4*0,a,!0)},n.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07=function(){const e=typeof globalThis>"u"?null:globalThis;return gt(e)?0:Xn(e)},n.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0=function(){const e=typeof globalThis>"u"?null:globalThis;return gt(e)?0:Xn(e)},n.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819=function(){const e=typeof self>"u"?null:self;return gt(e)?0:Xn(e)},n.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40=function(){const e=typeof window>"u"?null:window;return gt(e)?0:Xn(e)},n.wbg.__wbg_then_44b73946d2fb3e7d=function(e,t){return e.then(t)},n.wbg.__wbg_then_48b406749878a531=function(e,t,s){return e.then(t,s)},n.wbg.__wbg_values_fcb8ba8c0aad8b58=function(e){return Object.values(e)},n.wbg.__wbg_warn_4ca3906c248c47c4=function(e){console.warn(e)},n.wbg.__wbg_warn_aaf1f4664a035bd6=function(e,t,s,a){console.warn(e,t,s,a)},n.wbg.__wbindgen_cb_drop=function(e){const t=e.original;return t.cnt--==1?(t.a=0,!0):!1},n.wbg.__wbindgen_closure_wrapper739=function(e,t,s){return Mu(e,t,256,Yu)},n.wbg.__wbindgen_debug_string=function(e,t){const s=Na(t),a=Ys(s,q.__wbindgen_malloc,q.__wbindgen_realloc),r=ft;Ge().setInt32(e+4*1,r,!0),Ge().setInt32(e+4*0,a,!0)},n.wbg.__wbindgen_init_externref_table=function(){const e=q.__wbindgen_export_2,t=e.grow(4);e.set(0,void 0),e.set(t+0,void 0),e.set(t+1,null),e.set(t+2,!0),e.set(t+3,!1)},n.wbg.__wbindgen_is_array=function(e){return Array.isArray(e)},n.wbg.__wbindgen_is_function=function(e){return typeof e=="function"},n.wbg.__wbindgen_is_string=function(e){return typeof e=="string"},n.wbg.__wbindgen_is_undefined=function(e){return e===void 0},n.wbg.__wbindgen_number_get=function(e,t){const s=t,a=typeof s=="number"?s:void 0;Ge().setFloat64(e+8*1,gt(a)?0:a,!0),Ge().setInt32(e+4*0,!gt(a),!0)},n.wbg.__wbindgen_number_new=function(e){return e},n.wbg.__wbindgen_string_get=function(e,t){const s=t,a=typeof s=="string"?s:void 0;var r=gt(a)?0:Ys(a,q.__wbindgen_malloc,q.__wbindgen_realloc),i=ft;Ge().setInt32(e+4*1,i,!0),Ge().setInt32(e+4*0,r,!0)},n.wbg.__wbindgen_string_new=function(e,t){return an(e,t)},n.wbg.__wbindgen_throw=function(e,t){throw new Error(an(e,t))},n}function Ju(n,e){return q=n.exports,Co.__wbindgen_wasm_module=e,xt=null,Cn=null,q.__wbindgen_start(),q}async function Co(n){if(q!==void 0)return q;typeof n<"u"&&(Object.getPrototypeOf(n)===Object.prototype?{module_or_path:n}=n:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof n>"u"&&(n=new URL("/assets/acvm_js_bg-CY_NeZgE.wasm",import.meta.url));const e=Ku();(typeof n=="string"||typeof Request=="function"&&n instanceof Request||typeof URL=="function"&&n instanceof URL)&&(n=fetch(n));const{instance:t,module:s}=await Zu(await n,e);return Ju(t,s)}async function Uu(n,e,t){const s=V("simulator:acvm"),a=await Vu(n,e,(r,i)=>{try{s.debug(`Oracle callback ${r}`);const o=t[r];if(!o)throw new Error(`Oracle callback ${r} not found`);return o.call(t,...i)}catch(o){let c;throw o instanceof Error?c=o:c=new Error(`Error in oracle callback ${o}`),s.error(`Error in oracle callback ${r}: ${c.message}`),c}}).catch(r=>{const i=new Error().stack;throw Oo(r,o=>{o.stack&&(o.stack+=i)}),r});return{partialWitness:a.solvedWitness,returnWitness:a.returnWitness}}function hr(n,e){if(!("callStack"in n)||!n.callStack)return;const{callStack:t,brilligFunctionId:s}=n;if(!e)return t;try{return To(t,e.debugSymbols,e.files,s)}catch{return t}}function di(n,e){return n.slice(0,f.fromString(e).toNumber()).map(f.fromString)}function Qu(n,e,t){const s=n.slice(0,f.fromString(e).toNumber());return Buffer.concat(s.map(a=>Qn(a).subarray(-1)))}function Do(n){return[...n.keys()].sort((t,s)=>t-s).map(t=>n.get(t)).map(f.fromString)}function ui(n,e){return Buffer.concat(n.map(t=>Qn(t).slice(-1)))}function $u(n){const e=Buffer.alloc(f.SIZE_IN_BYTES);if(n.length>e.length)throw new Error("Buffer does not fit in field");return n.copy(e,e.length-n.length),e}function j(n){let e;return Buffer.isBuffer(n)?e=n:typeof n=="boolean"||typeof n=="number"||typeof n=="bigint"?e=new f(n).toBuffer():typeof n=="string"?e=f.fromHexString(n).toBuffer():e=n.toBuffer(),`0x${$u(e).toString("hex")}`}function fi(n){return Array.isArray(n)?n.map(j):j(n)}function jo(n,e){return e.reduce((t,s,a)=>(t.set(a+n,j(s)),t),new Map)}function ef(n){return Array.from(n).map(e=>j(BigInt(e)))}function tf(n,e){const t=ef(n);return nf(t,e)}function nf(n,e){if(n.length>e)throw new Error(`Array of length ${n.length} larger than maxLen ${e}`);const t=e-n.length,s=Array(t).fill(j(BigInt(0))),a=n.concat(s),r=j(BigInt(n.length));return[a,r]}function sf(n,e,t){if(n.length>e)throw new Error(`Array of length ${n.length} larger than maxLen ${e}`);if(!n.every(o=>o.length===t))throw new Error(`Nested array length passed in from Noir does not correspond to the length obtained in TS: ${t} !== ${n[0].length}`);const s=n.flat(),a=e*t-s.length,r=s.concat(Array(a).fill(j(BigInt(0)))),i=j(BigInt(n.length));return[r,i]}class Io{constructor(e){l(this,"typedOracle");this.typedOracle=e}getRandomField(){const e=this.typedOracle.getRandomField();return Promise.resolve([j(e)])}storeInExecutionCache(e,t,[s]){return this.typedOracle.storeInExecutionCache(t.map(f.fromString),f.fromString(s)),Promise.resolve([])}async loadFromExecutionCache([e]){return[(await this.typedOracle.loadFromExecutionCache(f.fromString(e))).map(j)]}async getBlockNumber(){return[j(await this.typedOracle.getBlockNumber())]}async getContractAddress(){return[j(await this.typedOracle.getContractAddress())]}async getVersion(){return[j(await this.typedOracle.getVersion())]}async getChainId(){return[j(await this.typedOracle.getChainId())]}async getKeyValidationRequest([e]){return(await this.typedOracle.getKeyValidationRequest(f.fromString(e))).toFields().map(j)}async getContractInstance([e]){const t=await this.typedOracle.getContractInstance(E.fromField(f.fromString(e)));return[t.salt,t.deployer,t.currentContractClassId,t.initializationHash,...t.publicKeys.toFields()].map(j)}async getMembershipWitness([e],[t],[s]){const a=f.fromString(e).toNumber(),r=f.fromString(t).toNumber(),i=f.fromString(s),o=await this.typedOracle.getMembershipWitness(a,r,i);if(!o)throw new Error(`Leaf ${s} not found in the tree ${Pe[r]} at block ${a}.`);return[j(o[0]),o.slice(1).map(j)]}async getNullifierMembershipWitness([e],[t]){const s=f.fromString(e).toNumber(),a=f.fromString(t),r=await this.typedOracle.getNullifierMembershipWitness(s,a);if(!r)throw new Error(`Nullifier witness not found for nullifier ${a} at block ${s}.`);return r.toNoirRepresentation()}async getLowNullifierMembershipWitness([e],[t]){const s=f.fromString(e).toNumber(),a=f.fromString(t),r=await this.typedOracle.getLowNullifierMembershipWitness(s,a);if(!r)throw new Error(`Low nullifier witness not found for nullifier ${a} at block ${s}.`);return r.toNoirRepresentation()}async getPublicDataWitness([e],[t]){const s=f.fromString(e).toNumber(),a=f.fromString(t),r=await this.typedOracle.getPublicDataWitness(s,a);if(!r)throw new Error(`Public data witness not found for slot ${a} at block ${s}.`);return r.toNoirRepresentation()}async getBlockHeader([e]){const t=f.fromString(e).toNumber(),s=await this.typedOracle.getBlockHeader(t);if(!s)throw new Error(`Block header not found for block ${t}.`);return s.toFields().map(j)}async getAuthWitness([e]){const t=f.fromString(e),s=await this.typedOracle.getAuthWitness(t);if(!s)throw new Error(`Unknown auth witness for message hash ${t}`);return[s.map(j)]}async getPublicKeysAndPartialAddress([e]){const t=E.fromField(f.fromString(e)),{publicKeys:s,partialAddress:a}=await this.typedOracle.getCompleteAddress(t);return[[...s.toFields(),a].map(j)]}async getNotes([e],[t],s,a,r,i,o,c,d,_,m,[h],[g],[b],[N],[A]){const x=await this.typedOracle.getNotes(f.fromString(e),+t,s.map(T=>+T),a.map(T=>+T),r.map(T=>+T),i.map(f.fromString),o.map(T=>+T),c.map(T=>+T),d.map(T=>+T),_.map(T=>+T),m.map(T=>+T),+h,+g,+b);if(x.length>0){const T=x[0].note.items.length;if(!x.every(({note:D})=>T===D.items.length))throw new Error("Notes should all be the same length.")}const F=x.map(({contractAddress:T,nonce:D,index:X,note:H})=>[T,D,!!(X===void 0),...H.items]).map(T=>T.map(j));return sf(F,+N,+A)}notifyCreatedNote([e],[t],s,[a],[r]){return this.typedOracle.notifyCreatedNote(f.fromString(e),cc.fromField(f.fromString(t)),s.map(f.fromString),f.fromString(a),+r),Promise.resolve([])}async notifyNullifiedNote([e],[t],[s]){return await this.typedOracle.notifyNullifiedNote(f.fromString(e),f.fromString(t),+s),[]}async notifyCreatedNullifier([e]){return await this.typedOracle.notifyCreatedNullifier(f.fromString(e)),[]}async checkNullifierExists([e]){const t=await this.typedOracle.checkNullifierExists(f.fromString(e));return[j(t)]}async getL1ToL2MembershipWitness([e],[t],[s]){return(await this.typedOracle.getL1ToL2MembershipWitness(E.fromString(e),f.fromString(t),f.fromString(s))).toNoirRepresentation()}async storageRead([e],[t],[s],[a]){return[(await this.typedOracle.storageRead(new E(f.fromString(e)),f.fromString(t),+s,+a)).map(j)]}async storageWrite([e],t){return(await this.typedOracle.storageWrite(f.fromString(e),t.map(f.fromString))).map(j)}notifyCreatedContractClassLog([e],t,[s],[a]){const r=new dc(t.map(f.fromString)),i=new uc(new E(f.fromString(e)),r,+s);return this.typedOracle.notifyCreatedContractClassLog(i,+a),Promise.resolve([])}debugLog(e,t,s){const a=e.map(i=>String.fromCharCode(f.fromString(i).toNumber())).join(""),r=s.map(f.fromString);return this.typedOracle.debugLog(a,r),Promise.resolve([])}async callPrivateFunction([e],[t],[s],[a],[r]){const{endSideEffectCounter:i,returnsHash:o}=await this.typedOracle.callPrivateFunction(E.fromField(f.fromString(e)),De.fromField(f.fromString(t)),f.fromString(s),f.fromString(a).toNumber(),f.fromString(r).toBool());return[[i,o].map(j)]}async notifyEnqueuedPublicFunctionCall([e],[t],[s],[a]){return await this.typedOracle.notifyEnqueuedPublicFunctionCall(E.fromString(e),f.fromString(t),f.fromString(s).toNumber(),f.fromString(a).toBool()),[]}async notifySetPublicTeardownFunctionCall([e],[t],[s],[a]){return await this.typedOracle.notifySetPublicTeardownFunctionCall(E.fromString(e),f.fromString(t),f.fromString(s).toNumber(),f.fromString(a).toBool()),[]}async notifySetMinRevertibleSideEffectCounter([e]){return await this.typedOracle.notifySetMinRevertibleSideEffectCounter(f.fromString(e).toNumber()),Promise.resolve([])}async getIndexedTaggingSecretAsSender([e],[t]){return(await this.typedOracle.getIndexedTaggingSecretAsSender(E.fromString(e),E.fromString(t))).toFields().map(j)}async incrementAppTaggingSecretIndexAsSender([e],[t]){return await this.typedOracle.incrementAppTaggingSecretIndexAsSender(E.fromString(e),E.fromString(t)),[]}async fetchTaggedLogs([e]){return await this.typedOracle.fetchTaggedLogs(f.fromString(e)),[]}async deliverNote([e],[t],[s],a,[r],[i],[o],[c],[d]){return await this.typedOracle.deliverNote(E.fromString(e),f.fromString(t),f.fromString(s),di(a,r),f.fromString(i),f.fromString(o),fn.fromString(c),E.fromString(d)),[j(!0)]}async getLogByTag([e]){const t=await this.typedOracle.getLogByTag(f.fromString(e));return t==null?[j(0),...js.noirSerializationOfEmpty().map(fi)]:[j(1),...t.toNoirSerialization().map(fi)]}async storeCapsule([e],[t],s){return await this.typedOracle.storeCapsule(E.fromField(f.fromString(e)),f.fromString(t),s.map(f.fromString)),[]}async loadCapsule([e],[t],[s]){const a=await this.typedOracle.loadCapsule(E.fromField(f.fromString(e)),f.fromString(t));return a===null?[j(0),Array(f.fromString(s).toNumber()).fill(j(0))]:[j(1),a.map(j)]}async deleteCapsule([e],[t]){return await this.typedOracle.deleteCapsule(E.fromField(f.fromString(e)),f.fromString(t)),[]}async copyCapsule([e],[t],[s],[a]){return await this.typedOracle.copyCapsule(E.fromField(f.fromString(e)),f.fromString(t),f.fromString(s),f.fromString(a).toNumber()),[]}async aes128Decrypt(e,[t],s,a){const r=Qu(e,t),i=ui(s),o=ui(a),c=await this.typedOracle.aes128Decrypt(r,i,o);return tf(c,e.length)}async getSharedSecret([e],[t],[s],[a]){return(await this.typedOracle.getSharedSecret(E.fromField(f.fromString(e)),Je.fromFields([t,s,a].map(f.fromString)))).toFields().map(j)}async storePrivateEventLog([e],[t],[s],a,[r],[i],[o],[c]){return await this.typedOracle.storePrivateEventLog(E.fromField(f.fromString(e)),E.fromField(f.fromString(t)),ao.fromField(f.fromString(s)),di(a,r),new fn(f.fromString(i)),f.fromString(o).toNumber(),f.fromString(c).toNumber()),[]}}class L extends Error{constructor(e){super(`Oracle method ${e} is not available.`)}}class af{getRandomField(){return f.random()}storeInExecutionCache(e,t){throw new L("storeInExecutionCache")}loadFromExecutionCache(e){return Promise.reject(new L("loadFromExecutionCache"))}getBlockNumber(){return Promise.reject(new L("getBlockNumber"))}getContractAddress(){return Promise.reject(new L("getContractAddress"))}getChainId(){return Promise.reject(new L("getChainId"))}getVersion(){return Promise.reject(new L("getVersion"))}getKeyValidationRequest(e){return Promise.reject(new L("getKeyValidationRequest"))}getContractInstance(e){return Promise.reject(new L("getContractInstance"))}getMembershipWitness(e,t,s){return Promise.reject(new L("getMembershipWitness"))}getNullifierMembershipWitness(e,t){return Promise.reject(new L("getNullifierMembershipWitness"))}getPublicDataWitness(e,t){return Promise.reject(new L("getPublicDataWitness"))}getLowNullifierMembershipWitness(e,t){return Promise.reject(new L("getLowNullifierMembershipWitness"))}getBlockHeader(e){return Promise.reject(new L("getBlockHeader"))}getCompleteAddress(e){return Promise.reject(new L("getCompleteAddress"))}getAuthWitness(e){return Promise.reject(new L("getAuthWitness"))}getNotes(e,t,s,a,r,i,o,c,d,_,m,h,g,b){return Promise.reject(new L("getNotes"))}notifyCreatedNote(e,t,s,a,r){throw new L("notifyCreatedNote")}notifyNullifiedNote(e,t,s){return Promise.reject(new L("notifyNullifiedNote"))}notifyCreatedNullifier(e){return Promise.reject(new L("notifyCreatedNullifier"))}checkNullifierExists(e){return Promise.reject(new L("checkNullifierExists"))}getL1ToL2MembershipWitness(e,t,s){return Promise.reject(new L("getL1ToL2MembershipWitness"))}storageRead(e,t,s,a){return Promise.reject(new L("storageRead"))}storageWrite(e,t){return Promise.reject(new L("storageWrite"))}notifyCreatedContractClassLog(e,t){throw new L("notifyCreatedContractClassLog")}callPrivateFunction(e,t,s,a,r){return Promise.reject(new L("callPrivateFunction"))}notifyEnqueuedPublicFunctionCall(e,t,s,a){return Promise.reject(new L("notifyEnqueuedPublicFunctionCall"))}notifySetPublicTeardownFunctionCall(e,t,s,a){return Promise.reject(new L("notifySetPublicTeardownFunctionCall"))}notifySetMinRevertibleSideEffectCounter(e){throw new L("notifySetMinRevertibleSideEffectCounter")}debugLog(e,t){throw new L("debugLog")}getIndexedTaggingSecretAsSender(e,t){return Promise.reject(new L("getIndexedTaggingSecretAsSender"))}incrementAppTaggingSecretIndexAsSender(e,t){return Promise.reject(new L("incrementAppTaggingSecretIndexAsSender"))}fetchTaggedLogs(e){return Promise.reject(new L("fetchTaggedLogs"))}deliverNote(e,t,s,a,r,i,o,c){return Promise.reject(new L("deliverNote"))}getLogByTag(e){throw new L("getLogByTag")}storeCapsule(e,t,s){return Promise.reject(new L("storeCapsule"))}loadCapsule(e,t){return Promise.reject(new L("loadCapsule"))}deleteCapsule(e,t){return Promise.reject(new L("deleteCapsule"))}copyCapsule(e,t,s,a){return Promise.reject(new L("copyCapsule"))}aes128Decrypt(e,t,s){return Promise.reject(new L("aes128Decrypt"))}getSharedSecret(e,t){return Promise.reject(new L("getSharedSecret"))}storePrivateEventLog(e,t,s,a,r,i,o){return Promise.reject(new L("storePrivateEventLog"))}}var Vn,Oa;class rf{constructor(e){w(this,Vn);l(this,"txRequestHash");l(this,"notes");l(this,"noteMap");l(this,"nullifierMap");l(this,"allNullifiers");l(this,"minRevertibleSideEffectCounter");l(this,"inRevertiblePhase");l(this,"usedTxRequestHashForNonces");this.txRequestHash=e,this.notes=[],this.noteMap=new Map,this.nullifierMap=new Map,this.allNullifiers=new Set,this.minRevertibleSideEffectCounter=0,this.inRevertiblePhase=!1,this.usedTxRequestHashForNonces=!0}async setMinRevertibleSideEffectCounter(e){if(this.inRevertiblePhase)throw new Error(`Cannot enter the revertible phase twice. Current counter: ${e}. Previous enter counter: ${this.minRevertibleSideEffectCounter}`);this.inRevertiblePhase=!0,this.minRevertibleSideEffectCounter=e;let t=this.txRequestHash;const s=this.getAllNullifiers();s.length>0&&(t=new f(s[0]),this.usedTxRequestHashForNonces=!1);const a=await Promise.all(this.notes.map(async({note:r,counter:i},o)=>{const c=await fc(t,o),d=await nr(c,await sr(r.contractAddress,r.noteHash));return{counter:i,note:{...r,nonce:c},noteHashForConsumption:d}}));this.notes=[],this.noteMap=new Map,a.forEach(r=>v(this,Vn,Oa).call(this,r))}finish(){return this.inRevertiblePhase||(this.usedTxRequestHashForNonces=this.getAllNullifiers().length===0),{usedTxRequestHashForNonces:this.usedTxRequestHashForNonces}}addNewNote(e,t){const s=this.notes[this.notes.length-1];if(s&&s.counter>=t)throw new Error(`Note hash counters must be strictly increasing. Current counter: ${t}. Previous counter: ${s.counter}.`);v(this,Vn,Oa).call(this,{note:e,counter:t,noteHashForConsumption:e.noteHash})}async nullifyNote(e,t,s){const a=await Pn(e,t);let r;if(s.isEmpty())this.recordNullifier(e,a);else{const i=this.noteMap.get(e.toBigInt())??[],o=i.findIndex(d=>d.noteHashForConsumption.equals(s));if(o===-1)throw new Error("Attempt to remove a pending note that does not exist.");const c=i.splice(o,1)[0];r=c.counter,this.noteMap.set(e.toBigInt(),i),this.notes=this.notes.filter(d=>d.counter!==c.counter),this.inRevertiblePhase&&c.counter<this.minRevertibleSideEffectCounter&&this.recordNullifier(e,a)}return r}async nullifierCreated(e,t){const s=await Pn(e,t);this.recordNullifier(e,s)}getNotes(e,t){return(this.noteMap.get(e.toBigInt())??[]).filter(a=>a.note.storageSlot.equals(t)).map(a=>a.note)}checkNoteExists(e,t){return(this.noteMap.get(e.toBigInt())??[]).some(a=>a.note.noteHash.equals(t))}getNullifiers(e){return this.nullifierMap.get(e.toBigInt())??new Set}getAllNotes(){return this.notes}getAllNullifiers(){return[...this.allNullifiers].map(e=>new f(e))}recordNullifier(e,t){const s=this.getNullifiers(e);s.add(t.toBigInt()),this.nullifierMap.set(e.toBigInt(),s),this.allNullifiers.add(t.toBigInt())}}Vn=new WeakSet,Oa=function(e){this.notes.push(e);const t=this.noteMap.get(e.note.contractAddress.toBigInt())??[];t.push(e),this.noteMap.set(e.note.contractAddress.toBigInt(),t)};class mr{constructor(e=[]){l(this,"cache");this.cache=new Map;for(const t of e)this.cache.set(t.hash.toBigInt(),t.values)}static create(e=[]){return new mr(e)}getPreimage(e){return e.isEmpty()?[]:this.cache.get(e.toBigInt())}store(e,t){this.cache.set(t.toBigInt(),e)}}class Bo{constructor(e,t){l(this,"smv");this.smv=new Zt(e,t)}async toFields(){return[...this.smv.toFields(),await this.smv.hash()]}async writeToTree(e,t){const s=await this.toFields();for(let a=0;a<s.length;a++)await t(e.add(new f(a)),s[a])}static async getContractUpdateSlots(e){const t=await xd(new f(_c),e),s=t.add(new f(Po));return{sharedMutableSlot:t,sharedMutableHashSlot:s}}}async function Fo(n,e,t,s,a,r=V("simulator:private_execution")){const i=await e.getDebugFunctionName();r.verbose(`Executing private function ${i}`,{contract:s});const o=e.getInitialWitness(t),c=new Io(e),d=new U,_=await n.executeUserCircuit(o,t,c).catch(D=>{throw D.message=So(D,t),new pr(D.message,{contractAddress:s,functionSelector:a},hr(D,t.debug),{cause:D})}),m=d.ms(),h=_.partialWitness,g=of(t,h),b=Do(o).length*f.SIZE_IN_BYTES;r.debug(`Ran external function ${s.toString()}:${a}`,{circuitName:"app-circuit",duration:m,eventName:"circuit-witness-generation",inputSize:b,outputSize:g.toBuffer().length,appCircuitName:i});const N=e.getContractClassLogs(),A=await e.loadFromExecutionCache(g.returnsHash),x=e.getNoteHashLeafIndexMap(),P=e.getNewNotes(),F=e.getNoteHashNullifierCounterMap(),T=e.getNestedExecutions();return r.debug(`Returning from call to ${s.toString()}:${a}`),new pc(t.bytecode,Buffer.from(t.verificationKey,"base64"),h,g,x,P,F,A,T,N,{timings:{witgen:m-T.reduce((D,X)=>{var H;return D+(((H=X.profileResult)==null?void 0:H.timings.witgen)??0)},0),oracles:_.oracles}})}function of(n,e){const t=ro(n)+io,s=hc,a=[];for(let r=t;r<t+s;r++){const i=e.get(r);if(i===void 0)throw new Error(`Missing return value for index ${r}`);a.push(f.fromString(i))}return $i.fromFields(a)}async function qo(n,e,t,s){const{sharedMutableSlot:a}=await Bo.getContractUpdateSlots(n);let i=(await Zt.readFromTree(a,o=>t.getPublicStorageAt(s,Ce.ContractInstanceDeployer,o))).svc.getCurrentAt(s)[0];return i.isZero()&&(i=e.originalContractClassId),i}async function Ta(n,e,t){const s=await e.getContractInstance(n);t=t??await e.getBlockNumber();const a=await qo(n,s,e,t);if(!s.currentContractClassId.equals(a))throw new Error(`Contract ${n} is outdated, current class id is ${a}, local class id is ${s.currentContractClassId}`)}const Ea=(n,e)=>{const s=n[e.index].toBuffer().subarray(e.offset,e.offset+e.length);return f.fromBuffer(s)},lf=(n,e)=>n.filter(t=>e.every(({selector:s,value:a,comparator:r})=>{const i=Ea(t.note.items,s);return{[tn.EQ]:()=>i.equals(a),[tn.NEQ]:()=>!i.equals(a),[tn.LT]:()=>i.lt(a),[tn.LTE]:()=>i.lt(a)||i.equals(a),[tn.GT]:()=>!i.lt(a)&&!i.equals(a),[tn.GTE]:()=>!i.lt(a)}[r]()})),Wo=(n,e,t,s=0)=>{if(t[s]===void 0)return 0;const{selector:a,order:r}=t[s];if(r===0)return 0;const i=Ea(n,a),o=Ea(e,a),c=r===1?[-1,1]:[1,-1];return i.toBigInt()===o.toBigInt()?Wo(n,e,t,s+1):i.toBigInt()>o.toBigInt()?c[0]:c[1]};function Mo(n,{selects:e=[],sorts:t=[],limit:s=0,offset:a=0}){return lf(n,e).sort((r,i)=>Wo(r.note.items,i.note.items,t)).slice(a,s?a+s:void 0)}class Ro extends af{constructor(t,s,a,r,i=V("simulator:client_view_context"),o){super();l(this,"contractAddress");l(this,"authWitnesses");l(this,"capsules");l(this,"executionDataProvider");l(this,"log");l(this,"scopes");this.contractAddress=t,this.authWitnesses=s,this.capsules=a,this.executionDataProvider=r,this.log=i,this.scopes=o}getBlockNumber(){return this.executionDataProvider.getBlockNumber()}getContractAddress(){return Promise.resolve(this.contractAddress)}getChainId(){return Promise.resolve(this.executionDataProvider.getChainId().then(t=>new f(t)))}getVersion(){return Promise.resolve(this.executionDataProvider.getVersion().then(t=>new f(t)))}getKeyValidationRequest(t){return this.executionDataProvider.getKeyValidationRequest(t,this.contractAddress)}getMembershipWitness(t,s,a){return this.executionDataProvider.getMembershipWitness(t,s,a)}async getNullifierMembershipWitness(t,s){return await this.executionDataProvider.getNullifierMembershipWitness(t,s)}async getLowNullifierMembershipWitness(t,s){return await this.executionDataProvider.getLowNullifierMembershipWitness(t,s)}async getPublicDataWitness(t,s){return await this.executionDataProvider.getPublicDataWitness(t,s)}async getBlockHeader(t){const s=await this.executionDataProvider.getBlock(t);if(s)return s.header}getCompleteAddress(t){return this.executionDataProvider.getCompleteAddress(t)}getContractInstance(t){return this.executionDataProvider.getContractInstance(t)}getAuthWitness(t){var s;return Promise.resolve((s=this.authWitnesses.find(a=>a.requestHash.equals(t)))==null?void 0:s.witness)}async getNotes(t,s,a,r,i,o,c,d,_,m,h,g,b,N){const A=await this.executionDataProvider.getNotes(this.contractAddress,t,N,this.scopes);return Mo(A,{selects:a.slice(0,s).map((x,P)=>({selector:{index:x,offset:r[P],length:i[P]},value:o[P],comparator:c[P]})),sorts:d.map((x,P)=>({selector:{index:x,offset:_[P],length:m[P]},order:h[P]})),limit:g,offset:b})}async checkNullifierExists(t){const s=await Pn(this.contractAddress,t);return await this.executionDataProvider.getNullifierIndex(s)!==void 0}async getL1ToL2MembershipWitness(t,s,a){return await this.executionDataProvider.getL1ToL2MembershipWitness(t,s,a)}async storageRead(t,s,a,r){const i=[];for(let o=0n;o<r;o++){const c=new f(s.value+o),d=await this.executionDataProvider.getPublicStorageAt(a,t,c);this.log.debug(`Oracle storage read: slot=${c.toString()} address-${t.toString()} value=${d}`),i.push(d)}return i}debugLog(t,s){this.log.verbose(`${mo(t,s)}`,{module:`${this.log.module}:debug_log`})}async getIndexedTaggingSecretAsSender(t,s){return await this.executionDataProvider.getIndexedTaggingSecretAsSender(this.contractAddress,t,s)}async fetchTaggedLogs(t){await this.executionDataProvider.syncTaggedLogs(this.contractAddress,t,this.scopes),await this.executionDataProvider.removeNullifiedNotes(this.contractAddress)}async deliverNote(t,s,a,r,i,o,c,d){if(!this.contractAddress.equals(t))throw new Error(`Got a note delivery request from ${t}, expected ${this.contractAddress}`);await this.executionDataProvider.deliverNote(t,s,a,r,i,o,c,d)}getLogByTag(t){return this.executionDataProvider.getLogByTag(t)}storeCapsule(t,s,a){if(!t.equals(this.contractAddress))throw new Error(`Contract ${t} is not allowed to access ${this.contractAddress}'s PXE DB`);return this.executionDataProvider.storeCapsule(this.contractAddress,s,a)}async loadCapsule(t,s){var a;if(!t.equals(this.contractAddress))throw new Error(`Contract ${t} is not allowed to access ${this.contractAddress}'s PXE DB`);return((a=this.capsules.find(r=>r.contractAddress.equals(t)&&r.storageSlot.equals(s)))==null?void 0:a.data)??await this.executionDataProvider.loadCapsule(this.contractAddress,s)}deleteCapsule(t,s){if(!t.equals(this.contractAddress))throw new Error(`Contract ${t} is not allowed to access ${this.contractAddress}'s PXE DB`);return this.executionDataProvider.deleteCapsule(this.contractAddress,s)}copyCapsule(t,s,a,r){if(!t.equals(this.contractAddress))throw new Error(`Contract ${t} is not allowed to access ${this.contractAddress}'s PXE DB`);return this.executionDataProvider.copyCapsule(this.contractAddress,s,a,r)}aes128Decrypt(t,s,a){return new kd().decryptBufferCBC(t,s,a)}getSharedSecret(t,s){return this.executionDataProvider.getSharedSecret(t,s)}storePrivateEventLog(t,s,a,r,i,o,c){return this.executionDataProvider.storePrivateEventLog(t,s,a,r,i,o,c)}}var Ut,Vo,Sa;const Nr=class Nr extends Ro{constructor(t,s,a,r,i,o,c,d,_,m,h,g=0,b=V("simulator:client_execution_context"),N){super(a.contractAddress,i,o,_,b,N);w(this,Ut);l(this,"argsHash");l(this,"txContext");l(this,"callContext");l(this,"historicalHeader");l(this,"executionCache");l(this,"noteCache");l(this,"provider");l(this,"totalPublicCalldataCount");l(this,"sideEffectCounter");l(this,"newNotes");l(this,"noteHashLeafIndexMap");l(this,"noteHashNullifierCounterMap");l(this,"contractClassLogs");l(this,"nestedExecutions");this.argsHash=t,this.txContext=s,this.callContext=a,this.historicalHeader=r,this.executionCache=c,this.noteCache=d,this.provider=m,this.totalPublicCalldataCount=h,this.sideEffectCounter=g,this.newNotes=[],this.noteHashLeafIndexMap=new Map,this.noteHashNullifierCounterMap=new Map,this.contractClassLogs=[],this.nestedExecutions=[]}getInitialWitness(t){const s=ro(t),a=this.executionCache.getPreimage(this.argsHash);if((a==null?void 0:a.length)!==s)throw new Error(`Invalid arguments size: expected ${s}, got ${a==null?void 0:a.length}`);const i=new _r(this.callContext,this.historicalHeader,this.txContext,this.sideEffectCounter).toFields();if(i.length!==io)throw new Error("Invalid private context inputs size");const o=[...i,...a];return jo(0,o)}getNoteHashLeafIndexMap(){return this.noteHashLeafIndexMap}getNewNotes(){return this.newNotes}getNoteHashNullifierCounterMap(){return this.noteHashNullifierCounterMap}getContractClassLogs(){return this.contractClassLogs}getNestedExecutions(){return this.nestedExecutions}storeInExecutionCache(t,s){return this.executionCache.store(t,s)}loadFromExecutionCache(t){const s=this.executionCache.getPreimage(t);if(!s)throw new Error(`Preimage for hash ${t.toString()} not found in cache`);return Promise.resolve(s)}async getNotes(t,s,a,r,i,o,c,d,_,m,h,g,b,N){const A=this.noteCache.getNotes(this.callContext.contractAddress,t),x=this.noteCache.getNullifiers(this.callContext.contractAddress),F=(await this.executionDataProvider.getNotes(this.callContext.contractAddress,t,N,this.scopes)).filter(X=>!x.has(X.siloedNullifier.value)),T=Mo([...F,...A],{selects:a.slice(0,s).map((X,H)=>({selector:{index:X,offset:r[H],length:i[H]},value:o[H],comparator:c[H]})),sorts:d.map((X,H)=>({selector:{index:X,offset:_[H],length:m[H]},order:h[H]})),limit:g,offset:b});return this.log.debug(`Returning ${T.length} notes for ${this.callContext.contractAddress} at ${t}: ${T.map(X=>`${X.nonce.toString()}:[${X.note.items.map(H=>H.toString()).join(",")}]`).join(", ")}`),(await Promise.all(T.map(async X=>{if(X.index!==void 0){const H=await sr(X.contractAddress,X.noteHash);return{hash:await nr(X.nonce,H),index:X.index}}}))).filter(X=>X!==void 0).forEach(X=>{this.noteHashLeafIndexMap.set(X.hash.toBigInt(),X.index)}),T}notifyCreatedNote(t,s,a,r,i){this.log.debug(`Notified of new note with inner hash ${r}`,{contractAddress:this.callContext.contractAddress,storageSlot:t,noteTypeId:s,counter:i});const o=new ks(a);this.noteCache.addNewNote({contractAddress:this.callContext.contractAddress,storageSlot:t,nonce:f.ZERO,note:o,siloedNullifier:void 0,noteHash:r},i),this.newNotes.push(new mc(o,t,s))}async notifyNullifiedNote(t,s,a){const r=await this.noteCache.nullifyNote(this.callContext.contractAddress,t,s);r!==void 0&&this.noteHashNullifierCounterMap.set(r,a)}notifyCreatedNullifier(t){return this.noteCache.nullifierCreated(this.callContext.contractAddress,t)}notifyCreatedContractClassLog(t,s){this.contractClassLogs.push(new gc(t,s));const a=t.toBuffer().toString("hex");this.log.verbose(`Emitted log from ContractClassRegisterer: "${a.length>100?a.slice(0,100)+"...":a}"`)}async callPrivateFunction(t,s,a,r,i){this.log.debug(`Calling private function ${t}:${s} from ${this.callContext.contractAddress}`),i=i||this.callContext.isStaticCall,await Ta(t,this.executionDataProvider,this.historicalHeader.globalVariables.blockNumber.toNumber());const o=await this.executionDataProvider.getFunctionArtifact(t,s),c=this.txContext.clone(),d=await this.deriveCallContext(t,o,i),_=new Nr(a,c,d,this.historicalHeader,this.authWitnesses,this.capsules,this.executionCache,this.noteCache,this.executionDataProvider,this.provider,this.totalPublicCalldataCount,r,this.log,this.scopes),m=await Fo(this.provider,_,o,t,s);i&&v(this,Ut,Vo).call(this,m),this.nestedExecutions.push(m);const h=m.publicInputs;return{endSideEffectCounter:h.endSideEffectCounter,returnsHash:h.returnsHash}}notifyEnqueuedPublicFunctionCall(t,s,a,r){return v(this,Ut,Sa).call(this,s),Promise.resolve()}notifySetPublicTeardownFunctionCall(t,s,a,r){return v(this,Ut,Sa).call(this,s),Promise.resolve()}notifySetMinRevertibleSideEffectCounter(t){return this.noteCache.setMinRevertibleSideEffectCounter(t)}async deriveCallContext(t,s,a=!1){return new Ds(this.contractAddress,t,await De.fromNameAndParameters(s.name,s.parameters),a)}getDebugFunctionName(){return this.executionDataProvider.getDebugFunctionName(this.contractAddress,this.callContext.functionSelector)}async incrementAppTaggingSecretIndexAsSender(t,s){await this.executionDataProvider.incrementAppTaggingSecretIndexAsSender(this.contractAddress,t,s)}async fetchTaggedLogs(t){await this.executionDataProvider.syncTaggedLogs(this.contractAddress,t,this.scopes),await this.executionDataProvider.removeNullifiedNotes(this.contractAddress)}};Ut=new WeakSet,Vo=function(t){if(t.publicInputs.noteHashes.some(s=>!s.isEmpty())||t.publicInputs.nullifiers.some(s=>!s.isEmpty())||t.publicInputs.l2ToL1Msgs.some(s=>!s.isEmpty())||t.publicInputs.privateLogs.some(s=>!s.isEmpty())||t.publicInputs.contractClassLogsHashes.some(s=>!s.isEmpty()))throw new Error("Static call cannot update the state, emit L2->L1 messages or generate logs")},Sa=function(t){const s=this.executionCache.getPreimage(t);if(!s)throw new Error("Calldata for public call not found in cache");if(this.totalPublicCalldataCount+=s.length,this.totalPublicCalldataCount>Fr)throw new Error(`Too many total args to all enqueued public calls! (> ${Fr})`)};let La=Nr;class cf{constructor(e,t){l(this,"executionDataProvider");l(this,"simulationProvider");l(this,"log");this.executionDataProvider=e,this.simulationProvider=t,this.log=V("simulator")}async run(e,t,s,a=E.fromField(f.MAX_FIELD_VALUE),r){const i=await this.executionDataProvider.getBlockHeader();await Ta(t,this.executionDataProvider);const o=await this.executionDataProvider.getFunctionArtifact(t,s);if(o.functionType!==lt.PRIVATE)throw new Error(`Cannot run ${o.functionType} function as private`);e.origin!==t&&this.log.warn(`Request origin does not match contract address in simulation. Request origin: ${e.origin}, contract address: ${t}`);const c=1,d=new Ds(a,t,await De.fromNameAndParameters(o.name,o.parameters),o.isStatic),_=await e.toTxRequest().hash(),m=new rf(_),h=new La(e.firstCallArgsHash,e.txContext,d,i,e.authWitnesses,e.capsules,mr.create(e.argsOfCalls),m,this.executionDataProvider,this.simulationProvider,0,c,void 0,r);try{const g=await Fo(this.simulationProvider,h,o,t,e.functionSelector),{usedTxRequestHashForNonces:b}=m.finish(),N=b?f.ZERO:m.getAllNullifiers()[0],A=zs([g],P=>[...P.publicInputs.publicCallRequests.map(F=>F.inner),P.publicInputs.publicTeardownCallRequest]).filter(P=>!P.isEmpty()),x=await Promise.all(A.map(async P=>{const F=await h.loadFromExecutionCache(P.calldataHash);return new Vi(F,P.calldataHash)}));return new bc(g,N,x)}catch(g){throw oi(g instanceof Error?g:new Error("Unknown error during private execution"))}}async runUtility(e,t,s){await Ta(e.to,this.executionDataProvider);const a=await this.executionDataProvider.getFunctionArtifact(e.to,e.selector);if(a.functionType!==lt.UTILITY)throw new Error(`Cannot run ${a.functionType} function as utility`);const r=new Ro(e.to,t,[],this.executionDataProvider,void 0,s);try{this.log.verbose(`Executing utility function ${a.name}`,{contract:e.to,selector:e.selector});const i=jo(0,e.args),o=await this.simulationProvider.executeUserCircuit(i,a,new Io(r)).catch(d=>{throw d.message=So(d,a),new pr(d.message,{contractAddress:e.to,functionSelector:e.selector},hr(d,a.debug),{cause:d})}),c=Do(o.returnWitness);return this.log.verbose(`Utility simulation for ${e.to}.${e.selector} completed`),wa(a.returnTypes,c)}catch(i){throw oi(i instanceof Error?i:new Error("Unknown error during private execution"))}}}class df{constructor(e,t){l(this,"index");l(this,"siblingPath");this.index=e,this.siblingPath=t}toFields(){return[new f(this.index),...this.siblingPath.toFields()]}toNoirRepresentation(){return[new f(this.index).toString(),this.siblingPath.toFields().map(e=>e.toString())]}}function uf(n,e){const t=e;if(e.rawAssertionPayload)try{const s=yo(n.abi,e.rawAssertionPayload);typeof s=="string"?t.message=`Circuit execution failed: ${s}`:t.decodedAssertionPayload=s}catch{}try{const s=hr(e,{debugSymbols:yc(n.debug_symbols)[0],files:n.file_map});t.noirCallStack=s==null?void 0:s.map(a=>typeof a=="string"?`at opcode ${a}`:`at ${a.locationText} (${a.filePath}:${a.line}:${a.column})`)}catch{}return t}class ff{constructor(e=V("wasm-simulator")){l(this,"log");this.log=e}async init(){typeof Aa=="function"&&await Promise.all([Aa(),Co()])}async executeProtocolCircuit(e,t,s){this.log.debug("init",{hash:t.hash}),await this.init();const a=Buffer.from(t.bytecode,"base64");try{const r=new U,i=await Ru(a,e,s);return this.log.debug("execution successful",{hash:t.hash}),{witness:i,duration:r.ms()}}catch(r){if(typeof r=="object"&&r!==null&&"rawAssertionPayload"in r){const i=uf(t,r);throw this.log.debug("execution failed",{hash:t.hash,error:i,message:i.message}),i}throw this.log.debug("execution failed",{hash:t.hash,error:r}),new Error(`Circuit execution failed: ${r}`)}}async executeUserCircuit(e,t,s){return await this.init(),Uu(t.bytecode,e,s)}}var _f={};const Gs={};function pf(){return["1","true"].includes(_f.AZTEC_GENERATE_TEST_DATA??"")&&typeof expect<"u"}function _t(n,e){if(!pf()||typeof expect>"u")return;const s=`${expect.getState().currentTestName} ${n}`;Gs[s]||(Gs[s]=[]),Gs[s].push(e)}const gr=new Fi(6,["06ec631481cff5fc9ac4d6181e31f1ceb99c1afa7a0bcd814ab9069488b55f11","0793534d3bbc60c04be64affd0b5b278346fd298ba6152d480e34e72dc501a76","090f60c41495e39d7ce371981fddb29760af9f141669c90b5a6a835c93cfa138","012729d240020b177a63dcef76842d4d04e5c3d39b536210ad930ef93177debd","1b23c3804f754a73a109576e989b6e2bd588fba8ffa913a2bdb7c218d2776ec2","0000000000000000000000000000000000000000000000000000000000000000","2e86db213373c31f45332068561928c2c703fd83e1524877b43cc4220174bc37","1f290778ff99829fb8cb8f0fe476791ffb5c4256b67622bd6341773cfd15077c","2156ec2d787d4b803247ac3ffe8381ea24d882d2af0eeed98ae7b80e3521a050","27f15127e833baad0a58f2160b734eead0215a46c432fc9b113b67137fd8ceee","231516d9f18d98b4209c5b5a2ff8d9c3f524779308e87b8bd1a07139d5836d19","2190866831d3420bbac2f0f905b07791931ad3029daeac0b8452a7511c610717","09181a1251e661c2c89a4f991cbd4a21e705d5c940f6554cd9c97eebc8c35aff","2a966192e29f06b4c37515636ac2be6235798df99d0a0c9aec9cdd701bb8cbf4","037ff6f5a0bbb8ae28ac3ae63579d7c7786cdc7f7bdc64868b5aab1479f542f7","0c091d80ec68b40819561739b7cbcb54c4df71c018c745de97baf192a135a99a","0000000000000000000000000000000000000000000000000000000000000000","0000000000000000000000000000000000000000000000000000000000000000","0000000000000000000000000000000000000000000000000000000000000000","0000000000000000000000000000000000000000000000000000000000000000","006ccc0be79c0060062d85341b75d4ecd2b0a502c7ad8ab7d1cbf0bc72ee2c60","2f96714ca67d8ab5c8d59fe953dd220ea1593f851adeedece9eeb209cbf89dad","0450727cc65055b44fed1312546bd8a0b38ce13c1e06190fd62c58dda22dc388","10486ef8ed68f0a771c48da41d7800df0eb0c21a2d2dafddd6e31a05958feebe","1baa8434e1b240812c22a647033c1212ebad599f39bfcb7c629f119a313e253d","08e2bf71ec1c8ca0ea48f1ffe885e12497d99a0fc90c3eaf9fb927b518200574","2693541df7ab25ae80bb46a1fe89ea718a9fcf7863db8938cb3fef726469eab6","0c1aa7ef227ba6668108dddd74e6636a70d0d9f5740cf7ea46ac1ec2f0d019dc","1e1a19abf9e95af3bc9786b9bc7e8eb1ae9ffb44ef0540c15adcf42ba3b61242","24c7f48d0ed66692274ee996683388754e5225d67e2c9e2b475471345b467d7b","2e8af0019633ec0dd0a125cee0ffcac7d372e9388896cf96448609b5bf27db1d","0ce6839691dc603098eee819d53f87a6c27a53b9ec40e252fd8b041f9d4ea78a","1fefa621ef2d793097e61103bc709173c471bda38397b6904d1ec1be59f3f3f1","04e593cb7bc1ee2e53493eb6d6ef0c78b31599f1d727d229ee166f462b763e6e","265af26eda8bbfb6c6d172921e954ed7aaae350ed5ac5390449844b4124b2532","04eb5b201168d89f2a2387868c5e732fbdaf9ccea7088be9dbe6686f64bac422","245b4cc86fcc84f9dc07c50a0c7bda3faf365c65c42310fff18cfae3cac521ea","0f4b3049c5d90f8e4080a6a812bd4717d4b6ecf429d53b145d70e3bfe7ba2539","21572fa32cddd87e0aef06dc4ae04995ff8cf348d17e336e301f28b9c8f8e9fe","01034b87b7d77dad9417e10f84763ba899d456d277417aeccba1d1de3a50c727","14193512b22668b57b5695f7e0e9bbd77e872d41286d9211551bc6f1f6d1bbeb","100ca75a47184e8705412028ee52de1bc46ecd9e9e4c127610f054232dd2a13e","07757dabeaade9a1f4b749f0558ed20a7fb61f52b9fcd8ad81b6bddf3fcb46ae","154a12babaa0d455cd9599326e6b4795f101b630a0b725ca6d4dd069410f5a16","04773e67f8db89b2fd0231d5505d841e276f55b6779dbb9c9f267dcad08cdd06","09ef5f032bcfba53a6ab72fbaff519e6d4d466fcc2e761472021a507e93f58da","1d84f8d80815f387733da6e810d750c1d7a507b40fd34bb5147d7d88edf82c3a","16b9d7401b814823223032d0bbe6c7f86d81fd90e3f186581e84a837bad8274d","2a56498dbfda2ef53633088c5ca674d2f02a9deb926a705dd8bf343c925e453c","0de2c5889b61b00a5211f5f00ebf741a5da8ab2d2610aa429431b242e5cf9d21","0e44909fbe9ce7c0f3d318d9f86ff88e3fc624e4d3f5a8c3eaeebff69519e8b8","2c5ae86a2a349eee586a27b0b8660d567d1d7411e6ad0f3fce7885f5e5694011","019f144787643e75ced2a2e9a679c5e319f9a0395d5ba956075ae02373883ec9","19144d626bf0b3adea7b8f96c9749f51ebfd536a6513cea36e258941e1ccca0f","2a29f587e2a1ad772286171e3b1eb9ae770df427588fb0240442bb3fc25661fd","18c5c7b71021b581fca572e5901a9002555b40a4f468fb4cbeb7f9c5bc2d3f4a","05164b468d4c73a04cdbc6ba1b9539571819e2eab07e974178166540c0b8d589","2618501cef44e572ed744c04bc6f6007758a79446034ac7e2ced896ec3a92528","183fdfe7852289f26c756ab91a72dd1fc3d1e9c2b5159ddb3b5cc1b67acab8d4","0aee02cfd3f720cebebe32ec1a6f867c944f51cdcf2ffe87059b5bb2060e7973","191fb86d6e30aa39510e32e9a352866816f817f55b9db9d72f3947d2c8040e5f","01ff09aac4b0ac204b326d1ebd61aa5a67a46e67aa74557f86f8029c4cf643c7","0000000000000000000000000000000000000000000000000000000000000000","0000000000000000000000000000000000000000000000000000000000000000","0bac7e2ecaf0bd3f4eec814807b801068b932c7fbc7bb5fcebf031d02c62d061","07e3d7a1354559f822154e3c2891d6eb6313ab0c972eca4ac0a81cf380d6a872","166d9200203972a67e495e091356eb547f3ad77502de0163b0eb32598c42137d","2465894eaa369607a5e8106cbba449e3bba5c224c5767f186ace4ee1fe0d10ce","0b931a32de663cff0af0649fd98775f0727bb50d5e3f69be450ba32ee0e36c3f","1f3a9b25b307f6e4f06d9e12da07fa8935fb46a476eed38c2408971440d46482","1e1fb4ad5c015f5338db8f75a7d7509a4ddd83d8d01d7e95e4ab6697906f57e4","01ff85398b01c8e2c813f9994b46246e3fc6cf720fc7d03e20de848f7970129a","0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1","0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1","0a09019cf4c19c483c9111cc4d2edbaa3d53cb7eeb8f0c2d4ece5b88a38687f0","147e61d3c06981a6fb949aa10044b7d9b895c454d17c3a68130b5e94639a1893","00afa25f4093056d24a84743b4d589ecccfb9c69233d43bec58db94b5fd4d56a","1e65a746cc1d317f1cb16d7e2dfbb6f6c7d0b043cf435cb6464b27e031ea602f","1096cf5c2d09ff8e63fd505a2f8356c90e52b44b7440ea356b09c4eb18d5e5ae","28f907853c72790ceb54df20955622cf27ddae6a251314785692e81e2ecb8b6b","29f30a900cc616b2626212f8e18f823d453d59d9ee3b5583ed3797008c0005a4","06543d041ca2b091070cfa046479b369b78d100b187d9c2e6de7d4d2da802213","2a5fae94bca3c706e9ea064008dd6cfe6bba508a5209ffbb9dcd10fac8e4adc2","220cae723bc280c9e9e8931ca8e1878e01064afc76cf260c14ece9deb8c1d443","0d91c451376db299d50b977693ece847cf0b6ccea94974a2fc7514af6a96404b","0876666f9995feb9c5efd13dc9fde39cc764c798b65b67854b8bb3ba1ed622ed","1f5442d31f796f3097b2d76ce21d242ba9e6b4dfec9ee228e785c376d820129b","026980d9911eac34748cb27bd6768b14eb5c56f9ba3dd397f8ceef62918a6bc8","2f12916c09758771f970a4d0849c7fef2c1e207b64810e19a1a28a32108bbce1","2af305ad79d7b41d6fc685dcd940809f3c87aa1fa758164f6099051dd23f304d","1cf94085cc6886f5bc2d61f53960ae2c9af9739ff967a81630af85020531dc54","108edb88b06512219e726d5d9b24653c7a42c3ce13c3ffcee0a6073da77cfe60","1b85f8b61357cf724c1b758610a40aaf9a6a244454b6dd0bebda3f34f1012864","08ba68bc6efd352c42796f108faf23b3a27518951b94f58dadea97e3c2f0f44d","093ba11771dd8de3a500574f69c33438e0436c1fcc3ab3a98d8f81eec67dc36c","0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1","01f21fa5d851286a2293e7b4ac4c72535292f1df8bb6882bb76970d8574cd75d","1406e455e506865f5ebbe88662b925a104cb429b86af13d9b8131b43451c68fc","1b39283c4123864a052d50bf75f6bfc379a88fde1e5cf9fe89407596c75f960f","22f09f0347140c29358a5238e65ec66e5df68b50777db90539f9c1912fe861b6","0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290","139c0cea1492839bf67f13de287cc10373b9ed067d3849078dd1c34b1412ecfe","1ce36c65a9c7992f428d1a202bc1a1e63750a371597c5c769429ae5c75384410","1e9b9c3e6f323cdb604f5442d12c679708d8f2fd915c600d057cff0d29ea7299","0ef9e4c2f38cd54cf90c2208c59fd142c4118e9493dce6b1e785343c896e4c80","23c55d2debdf315be1d1478cc7c0f02deffc487aba34f52437e59eaced21932a","051ae9fdc97eb6541317723da8f7b7d74e61bdeeb4f86c7015555389343e3522","07b6fc85f7764ac6fc369067c9edb1411eafb9637c68e10fa0b694402d4eea2f","27f69fbe5821d5e85d65ed59c74d955403ce4d97e99da87c4b4ca87d8c9c3184","27cd5f685749077b2afacda68dd1175b6425904e01a1bcddf3f673920c5504b6","18589a6a97a59aafdcd31b32d56ab771aaaa0b680fef326684eb720be341011d","1dbd58e54106abfe02a2afda30801a732c2fe45a9948aeedd37ed2651434f5c5","1ae7e0b4584895a6211c88b1562e2b135048f51b23521487b716c5012e5890dd","04cbdf2947d7dfd6fd9e946bc46f4a2e380274ae8c911b9f68d5071d7595959a","234d50478335e27ef5ead917ab3a150b6d6d04f2b1922459409d520102f85018","29c456e74e111cf0cecb003aafe3a80de6836f41bef37657bca9a4b7ba83c366","2600209bfc0f30e8fe7ff66c37f330e00c928c4104b709ae256e0472f95d3f63","14d7205faa9775bde144fdcd08eb9ae76de199f7e9e67feccd9b839aaef920b3","21afa288e79fa0738a796e6a338befc097614804137854147220d54cda5ed4db","1ac26adb2d68d4d7a28a9105b39c71f00946e3a84560aee47cb9f28f5c949031","158d9d9415969945b2a6e281246c74402f4c74f27c299f8c364f7f7bdf3c9712","246a3ea3fff457e4dcbaa2f1c3b2073ecf84a619438742e7fa16159cb6a83c8d","05bac82a81f3d3304af6f2c29b19fd7313a51180df2965a694f80d34385ba4cd","1da799ba003d3c557825aa81e383ddc4060208eccc4364255df854936cbba8f8","2d25384f930ac504a6bf629490476f8755096d032b97381dda6cc49feb0731de","13f550e609cef269968296efdfbdd92fc51b58e7d1405809e45d3b3cebea9409","2339da454741e2360c4e27c6f68767215a5b6ce150527d32d6b6c95aa92ec8c9"].map(n=>Buffer.from(n,"hex")));function hf(){return f.fromBuffer(gr.root)}function mf(n){let e;n instanceof fe?e=n.keyAsFields.hash:n instanceof ae?e=n.hash:e=n;const t=gr.getIndex(e.toBuffer());if(t<0)throw new Error(`VK index for ${e.toString()} not found in VK tree`);return t}function gf(n){return _e(gr.getSiblingPath(n).map(e=>new f(e)),Yt)}function y(n){return n.toString()}function S(n){return f.fromHexString(n)}function bf(n){return{inner:y(n)}}function ie(n){return Number(f.fromHexString(n).toBigInt())}function Y(n){return new f(BigInt(n)).toString()}function Dn(n){return{x:y(n.x),y:y(n.y),is_infinite:n.isInfinite}}function yf(n){return new Je(S(n.x),S(n.y),n.is_infinite)}function vf(n){return{hi:y(n.hi),lo:y(n.lo)}}function pe(n){return{inner:y(n.toField())}}function oe(n){return E.fromField(S(n.inner))}function Yo(n){return{inner:y(n.toField())}}function Go(n){return Ji.fromField(S(n.inner))}function Ss(n){return wc.from({daGas:ie(n.da_gas),l2Gas:ie(n.l2_gas)})}function _i(n){return{da_gas:Y(n.daGas),l2_gas:Y(n.l2Gas)}}function wf(n){return new Oc(Ss(n.gas_limits),Ss(n.teardown_gas_limits),Xa(n.max_fees_per_gas),Xa(n.max_priority_fees_per_gas))}function xf(n){return{gas_limits:_i(n.gasLimits),teardown_gas_limits:_i(n.teardownGasLimits),max_fees_per_gas:Ha(n.maxFeesPerGas),max_priority_fees_per_gas:Ha(n.maxPriorityFeesPerGas)}}function Ha(n){return{fee_per_da_gas:y(n.feePerDaGas),fee_per_l2_gas:y(n.feePerL2Gas)}}function Xa(n){return new Lc(S(n.fee_per_da_gas),S(n.fee_per_l2_gas))}function Af(n){return{fields:R(n.fields,y),length:Y(n.emittedLength)}}function br(n){return new Sc(Q(n.fields,Wi,S),ie(n.length))}function Q(n,e,t){if(n.length!=e)throw new Error(`Expected ${e} items, got ${n.length}`);return Array.from({length:e},(s,a)=>t(n[a]))}function qn(n){return new Pc(S(n.root),ie(n.next_available_leaf_index))}function Wn(n){return{root:y(n.root),next_available_leaf_index:y(new f(n.nextAvailableLeafIndex))}}function Pf(n){return{num_txs:y(n.numTxs),blobs_hash:Ks(n.blobsHash),in_hash:Ks(n.inHash),out_hash:Ks(n.outHash)}}function kf(n){return new kc(S(n.num_txs),Zs(n.blobs_hash),Zs(n.in_hash),Zs(n.out_hash))}function Zo(n){return{last_archive:Wn(n.lastArchive),content_commitment:Pf(n.contentCommitment),state:Cf(n.state),global_variables:Hf(n.globalVariables),total_fees:y(n.totalFees),total_mana_used:y(n.totalManaUsed)}}function zf(n){return new Ps(qn(n.last_archive),kf(n.content_commitment),Df(n.state),Xf(n.global_variables),S(n.total_fees),S(n.total_mana_used))}function Zs(n){return qt(S(n).toBigInt(),Tc)}function Ks(n){return y(Ac(n))}function Nf(n){return{_is_some:n.isSome,_value:Y(n.value)}}function Of(n){return new Xe(n._is_some,ie(n._value))}function Ko(n){return{_opt:{_is_some:n.isSome,_value:y(n.value)}}}function Tf(n){return new xc(n._opt._is_some,S(n._opt._value))}function Jo(n){return{recipient:Yo(n.recipient),content:y(n.content),counter:Y(n.counter)}}function Ef(n){return new Xc(Go(n.recipient),S(n.content),ie(n.counter))}function yr(n){return new At(Ef(n.message),oe(n.contract_address))}function Uo(n){return{inner:y(n.toField())}}function Lf(n){return De.fromField(S(n.inner))}function Is(n){return new va(oe(n.msg_sender),oe(n.contract_address),n.is_static_call,S(n.calldata_hash))}function vr(n){return{msg_sender:pe(n.msgSender),contract_address:pe(n.contractAddress),is_static_call:n.isStaticCall,calldata_hash:y(n.calldataHash)}}function Sf(n){return{message:Jo(n.message),contract_address:pe(n.contractAddress)}}function Qo(n,e){if(n.key.length!==e)throw new Error(`Expected ${e} fields, got ${n.key.length}`);return{key:n.key.map(y),hash:y(n.hash)}}function Hf(n){return{chain_id:y(n.chainId),version:y(n.version),block_number:y(n.blockNumber),slot_number:y(n.slotNumber),timestamp:y(n.timestamp),coinbase:Yo(n.coinbase),fee_recipient:pe(n.feeRecipient),gas_fees:Ha(n.gasFees)}}function Xf(n){return new Nc(S(n.chain_id),S(n.version),S(n.block_number),S(n.slot_number),S(n.timestamp),Go(n.coinbase),oe(n.fee_recipient),Xa(n.gas_fees))}function Cf(n){return{l1_to_l2_message_tree:Wn(n.l1ToL2MessageTree),partial:jf(n.partial)}}function Df(n){return new zc(qn(n.l1_to_l2_message_tree),If(n.partial))}function jf(n){return{note_hash_tree:Wn(n.noteHashTree),nullifier_tree:Wn(n.nullifierTree),public_data_tree:Wn(n.publicDataTree)}}function If(n){return new Ec(qn(n.note_hash_tree),qn(n.nullifier_tree),qn(n.public_data_tree))}function Bf(n){return{nullifier:y(n.leaf.nullifier),next_nullifier:y(n.nextKey),next_index:Y(Number(n.nextIndex))}}function Ff(n){return{slot:y(n.leaf.slot),value:y(n.leaf.value),next_slot:y(n.nextKey),next_index:Y(Number(n.nextIndex))}}function qf(n){return{address:y(n.address),next_address:y(n.nextAddress)}}function Mn(n){const e=R(n.siblingPath,y);return{leaf_index:n.leafIndex.toString(),sibling_path:e}}function Wf(n){return{value:y(n.value),length:Y(n.length)}}function $o(n){return new Cc(S(n.value),ie(n.length))}function el(n){return{inner:Wf(n.logHash),counter:Y(n.counter)}}function Mf(n){return new Dc($o(n.inner),ie(n.counter))}function Rf(n){return{inner:el(n.inner),contract_address:pe(n.contractAddress)}}function Vf(n){return new pa(Mf(n.inner),oe(n.contract_address))}function tl(n){return new Hc($o(n.inner),oe(n.contract_address))}function Yf(n){return new vc(Q(n.note_hashes,se,S),Q(n.nullifiers,le,S),Q(n.l2_to_l1_msgs,Te,yr),Q(n.private_logs,xn,br),Q(n.contract_class_logs_hashes,Rn,tl))}function wr(n){return{chain_id:y(n.chainId),version:y(n.version),gas_settings:xf(n.gasSettings)}}function Gf(n){return new Ua(S(n.chain_id),S(n.version),wf(n.gas_settings))}function Zf(n){return{selector:Uo(n.selector),is_private:n.isPrivate}}function Kf(n){return{origin:pe(n.origin),args_hash:y(n.argsHash),tx_context:wr(n.txContext),function_data:Zf(n.functionData),salt:y(n.salt)}}function nl(n){return{value:y(n.value),counter:Y(n.counter)}}function Jf(n){return new Wc(S(n.value),ie(n.counter))}function Uf(n){return{note_hash:nl(n.noteHash),contract_address:pe(n.contractAddress)}}function Qf(n){return new vs(Jf(n.note_hash),oe(n.contract_address))}function sl(n){return{value:y(n.value),counter:Y(n.counter),note_hash:y(n.noteHash)}}function $f(n){return new Mc(S(n.value),ie(n.counter),S(n.note_hash))}function e_(n){return{nullifier:sl(n.nullifier),contract_address:pe(n.contractAddress)}}function t_(n){return new ws($f(n.nullifier),oe(n.contract_address))}function al(n){return{log:Af(n.log),note_hash_counter:Y(n.noteHashCounter),counter:Y(n.counter)}}function n_(n){return new Rc(br(n.log),ie(n.note_hash_counter),ie(n.counter))}function s_(n){return{inner:al(n.inner),contract_address:pe(n.contractAddress)}}function a_(n){return new _a(n_(n.inner),oe(n.contract_address))}function r_(n){return new qc(S(n.value),ie(n.counter))}function pi(n){return{read_request:Ca(n.readRequest),contract_address:pe(n.contractAddress)}}function hi(n){return new Ke(r_(n.read_request),oe(n.contract_address))}function i_(n){return{pk_m:Dn(n.pkM),sk_app:y(n.skApp)}}function rl(n){return{request:i_(n.request),sk_app_generator:y(n.skAppGenerator)}}function o_(n){return new so(yf(n.pk_m),S(n.sk_app))}function l_(n){return new cs(o_(n.request),S(n.sk_app_generator))}function c_(n){return{request:rl(n.request),contract_address:pe(n.contractAddress)}}function d_(n){return new ct(l_(n.request),oe(n.contract_address))}function u_(n){return new Ds(oe(n.msg_sender),oe(n.contract_address),Lf(n.function_selector),n.is_static_call)}function il(n){return{msg_sender:pe(n.msgSender),contract_address:pe(n.contractAddress),function_selector:Uo(n.functionSelector),is_static_call:n.isStaticCall}}function f_(n){return new ga(u_(n.call_context),S(n.args_hash),S(n.returns_hash),ie(n.start_side_effect_counter),ie(n.end_side_effect_counter))}function ol(n){return{call_context:il(n.callContext),args_hash:y(n.argsHash),returns_hash:y(n.returnsHash),start_side_effect_counter:Y(n.startSideEffectCounter),end_side_effect_counter:Y(n.endSideEffectCounter)}}function __(n){return new ha(Is(n.inner),ie(n.counter))}function ll(n){return{inner:vr(n.inner),counter:Y(n.counter)}}function Ca(n){return{value:y(n.value),counter:Y(n.counter)}}function p_(n){return{max_block_number:Ko(n.maxBlockNumber)}}function xr(n){return new ds(Tf(n.max_block_number))}function h_(n){return{for_rollup:p_(n.forRollup),note_hash_read_requests:R(n.noteHashReadRequests,pi),nullifier_read_requests:R(n.nullifierReadRequests,pi),scoped_key_validation_requests_and_generators:R(n.scopedKeyValidationRequestsAndGenerators,c_),split_counter:Nf(n.splitCounter)}}function m_(n){return new it(xr(n.for_rollup),Q(n.note_hash_read_requests,ce,hi),Q(n.nullifier_read_requests,de,hi),Q(n.scoped_key_validation_requests_and_generators,Mt,d_),Of(n.split_counter))}function g_(n){return new Rt(Q(n.note_hashes,se,Qf),Q(n.nullifiers,le,t_),Q(n.l2_to_l1_msgs,Te,yr),Q(n.private_logs,xn,a_),Q(n.contract_class_logs_hashes,Rn,Vf),Q(n.public_call_requests,xs,__),Q(n.private_call_stack,ma,f_))}function b_(n){return{note_hashes:R(n.noteHashes,Uf),nullifiers:R(n.nullifiers,e_),l2_to_l1_msgs:R(n.l2ToL1Msgs,Sf),private_logs:R(n.privateLogs,s_),contract_class_logs_hashes:R(n.contractClassLogsHashes,Rf),public_call_requests:R(n.publicCallRequests,ll),private_call_stack:R(n.privateCallStack,ol)}}function cl(n){return{max_block_number:Ko(n.maxBlockNumber),call_context:il(n.callContext),args_hash:y(n.argsHash),returns_hash:y(n.returnsHash),note_hash_read_requests:R(n.noteHashReadRequests,Ca),nullifier_read_requests:R(n.nullifierReadRequests,Ca),key_validation_requests_and_generators:R(n.keyValidationRequestsAndGenerators,rl),note_hashes:R(n.noteHashes,nl),nullifiers:R(n.nullifiers,sl),private_call_requests:R(n.privateCallRequests,ol),public_call_requests:R(n.publicCallRequests,ll),public_teardown_call_request:vr(n.publicTeardownCallRequest),l2_to_l1_msgs:R(n.l2ToL1Msgs,Jo),private_logs:R(n.privateLogs,al),contract_class_logs_hashes:R(n.contractClassLogsHashes,el),start_side_effect_counter:y(n.startSideEffectCounter),end_side_effect_counter:y(n.endSideEffectCounter),historical_header:Zo(n.historicalHeader),tx_context:wr(n.txContext),min_revertible_side_effect_counter:y(n.minRevertibleSideEffectCounter),is_fee_payer:n.isFeePayer}}function y_(n){return{npk_m:{inner:Dn(n.masterNullifierPublicKey)},ivpk_m:{inner:Dn(n.masterIncomingViewingPublicKey)},ovpk_m:{inner:Dn(n.masterOutgoingViewingPublicKey)},tpk_m:{inner:Dn(n.masterTaggingPublicKey)}}}function v_(n){const e=_e(n.updatedClassIdHints.updatedClassIdValues.toFields(),Bc);return{function_leaf_membership_witness:Mn(n.functionLeafMembershipWitness),contract_class_artifact_hash:y(n.contractClassArtifactHash),contract_class_public_bytecode_commitment:y(n.contractClassPublicBytecodeCommitment),public_keys:y_(n.publicKeys),salted_initialization_hash:bf(n.saltedInitializationHash),protocol_contract_membership_witness:Mn(n.protocolContractMembershipWitness),protocol_contract_leaf:qf(n.protocolContractLeaf),updated_class_id_witness:Mn(n.updatedClassIdHints.updatedClassIdWitness),updated_class_id_leaf:Ff(n.updatedClassIdHints.updatedClassIdLeaf),updated_class_id_shared_mutable_values:R(e,y)}}function dl(n){return{vk:Qo(n.vk,lo),verification_key_hints:v_(n.verificationKeyHints)}}function Ar(n){return new ya(zf(n.historical_header),Gf(n.tx_context),S(n.vk_tree_root),S(n.protocol_contract_tree_root))}function w_(n){return{historical_header:Zo(n.historicalHeader),tx_context:wr(n.txContext),vk_tree_root:y(n.vkTreeRoot),protocol_contract_tree_root:y(n.protocolContractTreeRoot)}}function Pr(n){return new dt(Ar(n.constants),S(n.min_revertible_side_effect_counter),m_(n.validation_requests),g_(n.end),Is(n.public_teardown_call_request),oe(n.fee_payer),n.is_private_only,S(n.claimed_first_nullifier))}function ts(n){return{constants:w_(n.constants),validation_requests:h_(n.validationRequests),end:b_(n.end),min_revertible_side_effect_counter:y(n.minRevertibleSideEffectCounter),public_teardown_call_request:vr(n.publicTeardownCallRequest),fee_payer:pe(n.feePayer),is_private_only:n.isPrivateOnly,claimed_first_nullifier:y(n.claimedFirstNullifier)}}function ns(n){return{vk:Qo(n.verificationKey.keyAsFields,lo),vk_index:y(new f(n.vkIndex)),vk_path:R(n.vkPath,y)}}function x_(n){const e=new jc(Yf(n.end));return new oo(Ar(n.constants),xr(n.rollup_validation_requests),Ss(n.gas_used),oe(n.fee_payer),void 0,e)}function mi(n){return new Fc(Q(n.note_hashes,se,S),Q(n.nullifiers,le,S),Q(n.l2_to_l1_msgs,Te,yr),Q(n.private_logs,xn,br),Q(n.contract_class_logs_hashes,Rn,tl),Q(n.public_call_requests,xs,Is))}function A_(n){const e=new Ic(mi(n.non_revertible_accumulated_data),mi(n.revertible_accumulated_data),Is(n.public_teardown_call_request));return new oo(Ar(n.constants),xr(n.rollup_validation_requests),Ss(n.gas_used),oe(n.fee_payer),e)}function P_(n){return{nullifier_index:Y(n.nullifierIndex),note_hash_index:Y(n.noteHashIndex)}}function ul(n){return{state:Y(n.state),hint_index:Y(n.hintIndex)}}function fl(n){return{read_request_index:Y(n.readRequestIndex),pending_value_index:Y(n.pendingValueIndex)}}function k_(n){return{value:y(n)}}function z_(n){return{read_request_index:Y(n.readRequestIndex),membership_witness:Mn(n.membershipWitness),leaf_preimage:k_(n.leafPreimage)}}function N_(n){return{read_request_index:Y(n.readRequestIndex),membership_witness:Mn(n.membershipWitness),leaf_preimage:Bf(n.leafPreimage)}}function O_(n){return{read_request_statuses:R(n.readRequestStatuses,ul),pending_read_hints:n.pendingReadHints.map(fl),settled_read_hints:n.settledReadHints.map(z_)}}function T_(n){return{read_request_statuses:R(n.readRequestStatuses,ul),pending_read_hints:n.pendingReadHints.map(fl),settled_read_hints:n.settledReadHints.map(e=>N_(e))}}function E_(n){return{sk_m:vf(n.skM),request_index:Y(n.requestIndex)}}function _l(n){return{note_hash_read_request_hints:O_(n.noteHashReadRequestHints),nullifier_read_request_hints:T_(n.nullifierReadRequestHints),key_validation_hints:n.keyValidationHints.map(E_),transient_data_index_hints:n.transientDataIndexHints.map(P_),validation_requests_split_counter:Y(n.validationRequestsSplitCounter)}}function gi(n,e){const t={tx_request:Kf(n.txRequest),vk_tree_root:y(n.vkTreeRoot),protocol_contract_tree_root:y(n.protocolContractTreeRoot),private_call:dl(n.privateCall),is_private_only:n.isPrivateOnly,first_nullifier_hint:y(n.firstNullifierHint),app_public_inputs:cl(n.privateCall.publicInputs)};return _t("private-kernel-init",t),$n(e,t)}function bi(n,e){const t={previous_kernel:ns(n.previousKernel),previous_kernel_public_inputs:ts(n.previousKernel.publicInputs),private_call:dl(n.privateCall),app_public_inputs:cl(n.privateCall.publicInputs)};return _t("private-kernel-inner",t),$n(e,t)}function yi(n,e){const t={previous_kernel:ns(n.previousKernel),previous_kernel_public_inputs:ts(n.previousKernel.publicInputs),hints:_l(n.hints)};return $n(e,t)}function vi(n,e){const t={previous_kernel:ns(n.previousKernel),previous_kernel_public_inputs:ts(n.previousKernel.publicInputs)};return _t("private-kernel-tail",t),$n(e,t)}function wi(n,e){const t={previous_kernel:ns(n.previousKernel),previous_kernel_public_inputs:ts(n.previousKernel.publicInputs)};return _t("private-kernel-tail-to-public",t),$n(e,t)}function xi(n,e){const s=es(e,n).return_value;return Pr(s)}function Ai(n,e){const s=es(e,n).return_value;return Pr(s)}function Pi(n,e){const s=es(e,n).return_value;return Pr(s)}function ki(n,e){const s=es(e,n).return_value;return x_(s)}function zi(n,e){const s=es(e,n).return_value;return A_(s)}const L_={PrivateKernelResetArtifact_32_4_32_4_4_4_4_4_4:"private_kernel_reset_32_4_32_4_4_4_4_4_4",PrivateKernelResetArtifact_32_4_32_4_4_4_4_4_32:"private_kernel_reset_32_4_32_4_4_4_4_4_32",PrivateKernelResetArtifact_32_4_32_4_4_4_4_64_4:"private_kernel_reset_32_4_32_4_4_4_4_64_4",PrivateKernelResetArtifact_32_4_32_4_4_4_4_64_32:"private_kernel_reset_32_4_32_4_4_4_4_64_32",PrivateKernelResetArtifact_32_4_32_4_4_4_64_4_4:"private_kernel_reset_32_4_32_4_4_4_64_4_4",PrivateKernelResetArtifact_32_4_32_4_4_4_64_4_32:"private_kernel_reset_32_4_32_4_4_4_64_4_32",PrivateKernelResetArtifact_32_4_32_4_4_4_64_64_4:"private_kernel_reset_32_4_32_4_4_4_64_64_4",PrivateKernelResetArtifact_32_4_32_4_4_4_64_64_32:"private_kernel_reset_32_4_32_4_4_4_64_64_32",PrivateKernelResetArtifact_32_4_32_16_4_4_4_4_4:"private_kernel_reset_32_4_32_16_4_4_4_4_4",PrivateKernelResetArtifact_32_4_32_16_4_4_4_4_32:"private_kernel_reset_32_4_32_16_4_4_4_4_32",PrivateKernelResetArtifact_32_4_32_16_4_4_4_64_4:"private_kernel_reset_32_4_32_16_4_4_4_64_4",PrivateKernelResetArtifact_32_4_32_16_4_4_4_64_32:"private_kernel_reset_32_4_32_16_4_4_4_64_32",PrivateKernelResetArtifact_32_4_32_16_4_4_64_4_4:"private_kernel_reset_32_4_32_16_4_4_64_4_4",PrivateKernelResetArtifact_32_4_32_16_4_4_64_4_32:"private_kernel_reset_32_4_32_16_4_4_64_4_32",PrivateKernelResetArtifact_32_4_32_16_4_4_64_64_4:"private_kernel_reset_32_4_32_16_4_4_64_64_4",PrivateKernelResetArtifact_32_4_32_16_4_4_64_64_32:"private_kernel_reset_32_4_32_16_4_4_64_64_32",PrivateKernelResetArtifact_32_16_32_4_4_4_4_4_4:"private_kernel_reset_32_16_32_4_4_4_4_4_4",PrivateKernelResetArtifact_32_16_32_4_4_4_4_4_32:"private_kernel_reset_32_16_32_4_4_4_4_4_32",PrivateKernelResetArtifact_32_16_32_4_4_4_4_64_4:"private_kernel_reset_32_16_32_4_4_4_4_64_4",PrivateKernelResetArtifact_32_16_32_4_4_4_4_64_32:"private_kernel_reset_32_16_32_4_4_4_4_64_32",PrivateKernelResetArtifact_32_16_32_4_4_4_64_4_4:"private_kernel_reset_32_16_32_4_4_4_64_4_4",PrivateKernelResetArtifact_32_16_32_4_4_4_64_4_32:"private_kernel_reset_32_16_32_4_4_4_64_4_32",PrivateKernelResetArtifact_32_16_32_4_4_4_64_64_4:"private_kernel_reset_32_16_32_4_4_4_64_64_4",PrivateKernelResetArtifact_32_16_32_4_4_4_64_64_32:"private_kernel_reset_32_16_32_4_4_4_64_64_32",PrivateKernelResetArtifact_32_16_32_16_4_4_4_4_4:"private_kernel_reset_32_16_32_16_4_4_4_4_4",PrivateKernelResetArtifact_32_16_32_16_4_4_4_4_32:"private_kernel_reset_32_16_32_16_4_4_4_4_32",PrivateKernelResetArtifact_32_16_32_16_4_4_4_64_4:"private_kernel_reset_32_16_32_16_4_4_4_64_4",PrivateKernelResetArtifact_32_16_32_16_4_4_4_64_32:"private_kernel_reset_32_16_32_16_4_4_4_64_32",PrivateKernelResetArtifact_32_16_32_16_4_4_64_4_4:"private_kernel_reset_32_16_32_16_4_4_64_4_4",PrivateKernelResetArtifact_32_16_32_16_4_4_64_4_32:"private_kernel_reset_32_16_32_16_4_4_64_4_32",PrivateKernelResetArtifact_32_16_32_16_4_4_64_64_4:"private_kernel_reset_32_16_32_16_4_4_64_64_4",PrivateKernelResetArtifact_32_16_32_16_4_4_64_64_32:"private_kernel_reset_32_16_32_16_4_4_64_64_32",PrivateKernelResetArtifact_64_0_0_0_0_0_0_0_0:"private_kernel_reset_64_0_0_0_0_0_0_0_0",PrivateKernelResetArtifact_0_64_0_0_0_0_0_0_0:"private_kernel_reset_0_64_0_0_0_0_0_0_0",PrivateKernelResetArtifact_0_0_64_0_0_0_0_0_0:"private_kernel_reset_0_0_64_0_0_0_0_0_0",PrivateKernelResetArtifact_0_0_0_64_0_0_0_0_0:"private_kernel_reset_0_0_0_64_0_0_0_0_0",PrivateKernelResetArtifact_0_0_0_0_64_0_0_0_0:"private_kernel_reset_0_0_0_0_64_0_0_0_0",PrivateKernelResetArtifact_0_0_0_0_0_64_0_0_0:"private_kernel_reset_0_0_0_0_0_64_0_0_0",PrivateKernelResetArtifact_4_4_4_4_4_4_4_4_4:"private_kernel_reset_4_4_4_4_4_4_4_4_4",PrivateKernelResetArtifact_16_16_16_16_16_16_16_16_16:"private_kernel_reset_16_16_16_16_16_16_16_16_16",PrivateKernelResetArtifact_32_32_32_32_32_32_32_32_32:"private_kernel_reset_32_32_32_32_32_32_32_32_32",PrivateKernelResetArtifact_64_64_64_64_64_64_64_64_32:"private_kernel_reset"},S_={dimensions:{NOTE_HASH_PENDING_AMOUNT:{variants:[32],standalone:[64],cost:100},NOTE_HASH_SETTLED_AMOUNT:{variants:[4,16],standalone:[64],cost:3e3},NULLIFIER_PENDING_AMOUNT:{variants:[32],standalone:[64],cost:100},NULLIFIER_SETTLED_AMOUNT:{variants:[4,16],standalone:[64],cost:3e3},NULLIFIER_KEYS:{variants:[4],standalone:[64],cost:2500},TRANSIENT_DATA_AMOUNT:{variants:[4],standalone:[64],cost:100},NOTE_HASH_SILOING_AMOUNT:{variants:[4,64],standalone:[],cost:250},NULLIFIER_SILOING_AMOUNT:{variants:[4,64],standalone:[],cost:150},PRIVATE_LOG_SILOING_AMOUNT:{variants:[4,32],standalone:[],cost:150}},specialCases:[[4,4,4,4,4,4,4,4,4],[16,16,16,16,16,16,16,16,16],[32,32,32,32,32,32,32,32,32],[64,64,64,64,64,64,64,64,32]]};je.fromValues([64,64,64,64,64,64,64,64,32]);function H_(n){return we.map(e=>n[e]).join("_")}function Ni(n){const t=`PrivateKernelResetArtifact_${H_(n)}`;if(!L_[t])throw new Error(`Unknown private reset artifact: ${t}`);return t}function X_(n){const e={previous_kernel:ns(n.previousKernel),previous_kernel_public_inputs:ts(n.previousKernel.publicInputs),hints:_l(n.hints)};_t("private-kernel-reset",e)}function Oi(n,e){const t=V("noir-protocol-circuits:oracle");if(n==="debugLog"){Vc.strict(e.length===3,"expected 3 arguments for debugLog: msg, fields_length, fields");const[s,a,r]=e,i=s.map(c=>String.fromCharCode(f.fromString(c).toNumber())).join(""),o=r.map(c=>f.fromString(c));t.verbose("debug_log "+mo(i,o))}else if(n!=="noOp")throw Error(`unexpected oracle during execution: ${n}`);return Promise.resolve([])}function Ti(n,e){return zs(n,t=>An(e(t)).map(a=>new Ke(a,t.publicInputs.callContext.contractAddress)))}function C_(n){return async e=>{const t=await n.getNullifierMembershipWitness(e);if(!t)throw new Error(`Cannot find the leaf for nullifier ${e}.`);const{index:s,siblingPath:a,leafPreimage:r}=t;return{membershipWitness:new ee(tr,s,a.toTuple()),leafPreimage:r}}}async function D_(n,e){const t=[];for(let s=0;s<n.length;++s){const a=n[s].request;if(a.isEmpty())break;const r=await e.getMasterSecretKey(a.request.pkM);t.push(new zn(r,s))}return no(t,zn.nada(Mt),Mt)}class ls{constructor(e,t,s,a){l(this,"previousKernelOutput");l(this,"executionStack");l(this,"noteHashNullifierCounterMap");l(this,"validationRequestsSplitCounter");l(this,"previousKernel");l(this,"nextIteration");l(this,"noteHashResetStates");l(this,"nullifierResetStates");l(this,"numTransientData");l(this,"transientDataIndexHints");l(this,"requestedDimensions");var r;this.previousKernelOutput=e,this.executionStack=t,this.noteHashNullifierCounterMap=s,this.validationRequestsSplitCounter=a,this.previousKernel=e.publicInputs,this.requestedDimensions=je.empty(),this.noteHashResetStates=kn.empty(ce),this.nullifierResetStates=kn.empty(de),this.transientDataIndexHints=G(le,()=>new ut(le,se)),this.nextIteration=(r=t[this.executionStack.length-1])==null?void 0:r.publicInputs}needsReset(){const e=[()=>this.needsResetNoteHashReadRequests(),()=>this.needsResetNullifierReadRequests(),()=>this.needsResetNullifierKeys(),()=>this.needsResetTransientData()];return this.nextIteration?e.some(t=>t()):(e.push(()=>this.needsSiloNoteHashes(),()=>this.needsSiloNullifiers(),()=>this.needsSiloPrivateLogs()),e.map(s=>s()).some(s=>s))}async build(e,t){if(we.every(c=>!this.requestedDimensions[c]))throw new Error("Reset is not required.");const s=!!this.nextIteration,a=s,r=ju(this.requestedDimensions,S_,s,a),i=await e.getVkMembershipWitness(this.previousKernelOutput.verificationKey.keyAsFields),o=new Kt(this.previousKernelOutput.publicInputs,this.previousKernelOutput.verificationKey,Number(i.leafIndex),_e(i.siblingPath,Yt));return this.reduceReadRequestStates(this.noteHashResetStates,r.NOTE_HASH_PENDING_AMOUNT,r.NOTE_HASH_SETTLED_AMOUNT),this.reduceReadRequestStates(this.nullifierResetStates,r.NULLIFIER_PENDING_AMOUNT,r.NULLIFIER_SETTLED_AMOUNT),new xu(o,new Ls(await ku(e,this.previousKernel.validationRequests.noteHashReadRequests,this.previousKernel.end.noteHashes,this.noteHashResetStates,t),await Ou({getNullifierMembershipWitness:C_(e)},this.previousKernel.validationRequests.nullifierReadRequests,this.nullifierResetStates),await D_(this.previousKernel.validationRequests.scopedKeyValidationRequestsAndGenerators,e),this.transientDataIndexHints,this.validationRequestsSplitCounter),r)}reduceReadRequestStates(e,t,s){let a=0,r=0;for(let i=0;i<e.states.length;i++){const o=e.states[i];o===K.PENDING?a<t?a++:e.states[i]=K.NADA:o===K.SETTLED&&(r<s?r++:e.states[i]=K.NADA)}e.pendingReadHints=e.pendingReadHints.slice(0,t)}needsResetNoteHashReadRequests(e=!1){const t=ne(this.previousKernel.validationRequests.noteHashReadRequests),s=this.nextIteration?ne(this.nextIteration.noteHashReadRequests):0,a=!this.nextIteration||e?0:ce;if(t+s<=a)return!1;const r=zs(this.executionStack,d=>An(d.publicInputs.noteHashes).map(m=>new vs(m,d.publicInputs.callContext.contractAddress))),i=Pu(this.previousKernel.validationRequests.noteHashReadRequests,this.previousKernel.end.noteHashes,r),o=i.pendingReadHints.length,c=i.states.reduce((d,_)=>d+(_===K.SETTLED?1:0),0);return this.nextIteration?o>c?(this.requestedDimensions.NOTE_HASH_PENDING_AMOUNT=o,this.noteHashResetStates.states=_e(i.states.map(d=>d===K.PENDING?d:K.NADA),ce),this.noteHashResetStates.pendingReadHints=i.pendingReadHints):(this.requestedDimensions.NOTE_HASH_SETTLED_AMOUNT=c,this.noteHashResetStates.states=_e(i.states.map(d=>d===K.SETTLED?d:K.NADA),ce)):(this.noteHashResetStates=i,this.requestedDimensions.NOTE_HASH_PENDING_AMOUNT=o,this.requestedDimensions.NOTE_HASH_SETTLED_AMOUNT=c),!0}needsResetNullifierReadRequests(e=!1){const t=ne(this.previousKernel.validationRequests.nullifierReadRequests),s=this.nextIteration?ne(this.nextIteration.nullifierReadRequests):0,a=!this.nextIteration||e?0:de;if(t+s<=a)return!1;const r=zs(this.executionStack,d=>An(d.publicInputs.nullifiers).map(m=>new ws(m,d.publicInputs.callContext.contractAddress))),i=Nu(this.previousKernel.validationRequests.nullifierReadRequests,this.previousKernel.end.nullifiers,r),o=i.pendingReadHints.length,c=i.states.reduce((d,_)=>d+(_===K.SETTLED?1:0),0);return this.nextIteration?o>c?(this.requestedDimensions.NULLIFIER_PENDING_AMOUNT=o,this.nullifierResetStates.states=_e(i.states.map(d=>d===K.PENDING?d:K.NADA),de),this.nullifierResetStates.pendingReadHints=i.pendingReadHints):(this.requestedDimensions.NULLIFIER_SETTLED_AMOUNT=c,this.nullifierResetStates.states=_e(i.states.map(d=>d===K.SETTLED?d:K.NADA),de)):(this.nullifierResetStates=i,this.requestedDimensions.NULLIFIER_PENDING_AMOUNT=o,this.requestedDimensions.NULLIFIER_SETTLED_AMOUNT=c),!0}needsResetNullifierKeys(){const e=ne(this.previousKernel.validationRequests.scopedKeyValidationRequestsAndGenerators),t=this.nextIteration?ne(this.nextIteration.keyValidationRequestsAndGenerators):0,s=this.nextIteration?Mt:0;return e+t<=s?!1:(this.requestedDimensions.NULLIFIER_KEYS=e,!0)}needsResetTransientData(){var m,h,g;this.numTransientData=0;const t=ne(this.previousKernel.end.noteHashes)+ne(((m=this.nextIteration)==null?void 0:m.noteHashes)??[])>se,a=ne(this.previousKernel.end.nullifiers)+ne(((h=this.nextIteration)==null?void 0:h.nullifiers)??[])>le,i=ne(this.previousKernel.end.privateLogs)+ne(((g=this.nextIteration)==null?void 0:g.privateLogs)??[])>xn;if(this.nextIteration&&!t&&!a&&!i)return!1;const o=Ti(this.executionStack,b=>b.publicInputs.noteHashReadRequests),c=Ti(this.executionStack,b=>b.publicInputs.nullifierReadRequests);this.nextIteration&&(o.push(...this.previousKernel.validationRequests.noteHashReadRequests.filter(b=>!b.isEmpty())),c.push(...this.previousKernel.validationRequests.nullifierReadRequests.filter(b=>!b.isEmpty())));const{numTransientData:d,hints:_}=Tu(this.previousKernel.end.noteHashes,this.previousKernel.end.nullifiers,o,c,this.noteHashNullifierCounterMap,this.validationRequestsSplitCounter,se,le);if(this.nextIteration&&!d){if(!(t&&this.needsResetNoteHashReadRequests(!0)||a&&this.needsResetNullifierReadRequests(!0)||i&&this.needsResetNoteHashReadRequests(!0))){const A=t?"note hashes":a?"nullifiers":"private logs";throw new Error(`Number of ${A} exceeds the limit.`)}return!0}return this.numTransientData=d,this.transientDataIndexHints=_,this.requestedDimensions.TRANSIENT_DATA_AMOUNT=d,d>0}needsSiloNoteHashes(){if(this.numTransientData===void 0)throw new Error("`needsResetTransientData` must be run before `needsSiloNoteHashes`.");const e=this.previousKernel.end.noteHashes.filter(s=>!s.contractAddress.isZero()).length,t=Math.max(0,e-this.numTransientData);return this.requestedDimensions.NOTE_HASH_SILOING_AMOUNT=t,t>0}needsSiloNullifiers(){if(this.numTransientData===void 0)throw new Error("`needsResetTransientData` must be run before `needsSiloNullifiers`.");const e=this.previousKernel.end.nullifiers.filter(a=>!a.contractAddress.isZero()).length,t=Math.max(0,e-this.numTransientData),s=t?t+1:0;return this.requestedDimensions.NULLIFIER_SILOING_AMOUNT=s,t>0}needsSiloPrivateLogs(){if(this.numTransientData===void 0)throw new Error("`needsResetTransientData` must be run before `needsSiloPrivateLogs`.");const e=this.previousKernel.end.privateLogs,t=e.filter(o=>!o.contractAddress.isZero()).length,s=this.previousKernel.end.noteHashes,a=this.transientDataIndexHints.filter(o=>o.noteHashIndex<s.length).map(o=>s[o.noteHashIndex].counter),r=e.filter(o=>a.includes(o.inner.noteHashCounter)).length,i=t-r;return this.requestedDimensions.PRIVATE_LOG_SILOING_AMOUNT=i,i>0}}const j_={publicInputs:dt.empty(),verificationKey:fe.empty(),outputWitness:new Map,bytecode:Buffer.from([])};class I_{constructor(e,t,s=!1){l(this,"oracle");l(this,"proofCreator");l(this,"fakeProofs");l(this,"log");this.oracle=e,this.proofCreator=t,this.fakeProofs=s,this.log=V("pxe:private-kernel-execution-prover")}async proveWithKernels(e,t,{simulate:s,skipFeeEnforcement:a,profileMode:r}={simulate:!1,skipFeeEnforcement:!1,profileMode:"none"}){var Ye,On;const i=this.fakeProofs||s,o=!i||r!=="none",c=new U,d=t.publicFunctionCalldata.length===0,_=[t.entrypoint];let m=!0,h=j_;const g=[],b=Yc(t),N=Gc(t),A=d?0:Zc(t);for(;_.length;){if(!m){let Ae=new ls(h,_,N,A);for(;Ae.needsReset();){const $t=await Ae.build(this.oracle,b),En=new U;h=o?await this.proofCreator.generateResetOutput($t):await this.proofCreator.simulateReset($t),g.push({functionName:"private_kernel_reset",bytecode:h.bytecode,witness:h.outputWitness,vk:h.verificationKey.keyAsBytes,timings:{witgen:En.ms()}}),Ae=new ls(h,_,N,A)}}const J=_.pop();_.push(...[...J.nestedExecutions].reverse());const Tn=await this.oracle.getDebugFunctionName(J.publicInputs.callContext.contractAddress,J.publicInputs.callContext.functionSelector);g.push({functionName:Tn,bytecode:J.acir,witness:J.partialWitness,vk:J.vk,timings:{witgen:((Ye=J.profileResult)==null?void 0:Ye.timings.witgen)??0,oracles:(On=J.profileResult)==null?void 0:On.timings.oracles}});const ss=await this.createPrivateCallData(J);if(m){const Ae=new ir(e,hf(),Kc,ss,d,t.firstNullifier);this.log.debug(`Calling private kernel init with isPrivateOnly ${d} and firstNullifierHint ${Ae.firstNullifierHint}`),_t("private-kernel-inputs-init",Ae);const $t=new U;h=o?await this.proofCreator.generateInitOutput(Ae):await this.proofCreator.simulateInit(Ae),g.push({functionName:"private_kernel_init",bytecode:h.bytecode,witness:h.outputWitness,vk:h.verificationKey.keyAsBytes,timings:{witgen:$t.ms()}})}else{const Ae=await this.oracle.getVkMembershipWitness(h.verificationKey.keyAsFields),$t=new Kt(h.publicInputs,h.verificationKey,Number(Ae.leafIndex),_e(Ae.siblingPath,Yt)),En=new or($t,ss);_t("private-kernel-inputs-inner",En);const Bl=new U;h=o?await this.proofCreator.generateInnerOutput(En):await this.proofCreator.simulateInner(En),g.push({functionName:"private_kernel_inner",bytecode:h.bytecode,witness:h.outputWitness,vk:h.verificationKey.keyAsBytes,timings:{witgen:Bl.ms()}})}m=!1}let x=new ls(h,[],N,A);for(;x.needsReset();){const J=await x.build(this.oracle,b),Tn=new U;h=o?await this.proofCreator.generateResetOutput(J):await this.proofCreator.simulateReset(J),g.push({functionName:"private_kernel_reset",bytecode:h.bytecode,witness:h.outputWitness,vk:h.verificationKey.keyAsBytes,timings:{witgen:Tn.ms()}}),x=new ls(h,[],N,A)}if(h.publicInputs.feePayer.isZero()&&a){if(!i)throw new Error("Fee payment must be enforced when creating real proof.");h.publicInputs.feePayer=new E(f.MAX_FIELD_VALUE)}const P=await this.oracle.getVkMembershipWitness(h.verificationKey.keyAsFields),F=new Kt(h.publicInputs,h.verificationKey,Number(P.leafIndex),_e(P.siblingPath,Yt));this.log.debug(`Calling private kernel tail with hwm ${F.publicInputs.minRevertibleSideEffectCounter}`);const T=new lr(F);_t("private-kernel-inputs-ordering",T);const D=new U,X=o?await this.proofCreator.generateTailOutput(T):await this.proofCreator.simulateTail(T);if(g.push({functionName:"private_kernel_tail",bytecode:X.bytecode,witness:X.outputWitness,vk:X.verificationKey.keyAsBytes,timings:{witgen:D.ms()}}),r=="gates"||r=="full")for(const J of g){const Tn=new U,ss=await this.proofCreator.computeGateCountForCircuit(J.bytecode,J.functionName);J.gateCount=ss,J.timings.gateCount=Tn.ms()}if(r==="gates")for(const J of g)J.bytecode=Buffer.from([]),J.witness=new Map;o&&this.log.info(`Private kernel witness generation took ${c.ms()}ms`);let H,te;if(i)H=co.random();else{const J=new U;H=await this.proofCreator.createClientIvcProof(g),te=J.ms()}return{publicInputs:X.publicInputs,executionSteps:g,clientIvcProof:H,vk:X.verificationKey.keyAsBytes,timings:te?{proving:te}:void 0}}async createPrivateCallData({publicInputs:e,vk:t}){const{contractAddress:s,functionSelector:a}=e.callContext,r=await Jc(t),i=new ae(r,await Uc(r)),{currentContractClassId:o,publicKeys:c,saltedInitializationHash:d}=await this.oracle.getContractAddressPreimage(s),_=await this.oracle.getFunctionMembershipWitness(o,a),{artifactHash:m,publicBytecodeCommitment:h}=await this.oracle.getContractClassIdPreimage(o),g=await uo({originalContractClassId:o,saltedInitializationHash:d,publicKeys:c}),{lowLeaf:b,witness:N}=await Rd(s,g),A=await this.oracle.getUpdatedClassIdHints(s);return rt.from({publicInputs:e,vk:i,verificationKeyHints:kt.from({publicKeys:c,contractClassArtifactHash:m,contractClassPublicBytecodeCommitment:h,saltedInitializationHash:d,functionLeafMembershipWitness:_,protocolContractMembershipWitness:N,protocolContractLeaf:b,updatedClassIdHints:A})})}}class B_{constructor(e,t,s,a="latest",r=V("pxe:kernel_oracle")){l(this,"contractDataProvider");l(this,"keyStore");l(this,"node");l(this,"blockNumber");l(this,"log");this.contractDataProvider=e,this.keyStore=t,this.node=s,this.blockNumber=a,this.log=r}async getContractAddressPreimage(e){const t=await this.contractDataProvider.getContractInstance(e);if(!t)throw new Error(`Contract instance not found when getting address preimage. Contract address: ${e}.`);return{saltedInitializationHash:await Qc(t),...t}}async getContractClassIdPreimage(e){const t=await this.contractDataProvider.getContractClass(e);if(!t)throw new Error(`Contract class not found when getting class id preimage. Class id: ${e}.`);return $c(t)}async getFunctionMembershipWitness(e,t){const s=await this.contractDataProvider.getFunctionMembershipWitness(e,t);if(!s)throw new Error(`Membership witness not found for contract class id ${e} and selector ${t}.`);return s}getVkMembershipWitness(e){const t=mf(e);return Promise.resolve(new ee(Yt,BigInt(t),gf(t)))}async getNoteHashMembershipWitness(e){const t=await this.node.getNoteHashSiblingPath(this.blockNumber,e);return new ee(t.pathSize,e,t.toFields())}getNullifierMembershipWitness(e){return this.node.getNullifierMembershipWitness(this.blockNumber,e)}async getNoteHashTreeRoot(){const e=await this.node.getBlockHeader(this.blockNumber);if(!e)throw new Error(`No block header found for block number ${this.blockNumber}`);return e.state.partial.noteHashTree.root}getMasterSecretKey(e){return this.keyStore.getMasterSecretKey(e)}getDebugFunctionName(e,t){return this.contractDataProvider.getDebugFunctionName(e,t)}async getUpdatedClassIdHints(e){const{sharedMutableSlot:t,sharedMutableHashSlot:s}=await Bo.getContractUpdateSlots(e),a=await ed(Ce.ContractInstanceDeployer,s),r=await this.node.getPublicDataWitness(this.blockNumber,a);if(!r)throw new Error(`No public data tree witness found for ${a}`);const i=c=>this.node.getPublicStorageAt(this.blockNumber,Ce.ContractInstanceDeployer,c),o=await Zt.readFromTree(t,i);return new zt(new ee(Qi,r.index,r.siblingPath.toTuple()),r.leafPreimage,o)}}class Ve{constructor(e,t,s,a,r,i,o,c,d,_,m){l(this,"note");l(this,"contractAddress");l(this,"storageSlot");l(this,"nonce");l(this,"noteHash");l(this,"siloedNullifier");l(this,"txHash");l(this,"l2BlockNumber");l(this,"l2BlockHash");l(this,"index");l(this,"recipient");this.note=e,this.contractAddress=t,this.storageSlot=s,this.nonce=a,this.noteHash=r,this.siloedNullifier=i,this.txHash=o,this.l2BlockNumber=c,this.l2BlockHash=d,this.index=_,this.recipient=m}toBuffer(){return I([this.note,this.contractAddress,this.storageSlot,this.nonce,this.noteHash,this.siloedNullifier,this.txHash,this.l2BlockNumber,f.fromHexString(this.l2BlockHash),this.index,this.recipient])}static fromBuffer(e){const t=B.asReader(e),s=ks.fromBuffer(t),a=E.fromBuffer(t),r=f.fromBuffer(t),i=f.fromBuffer(t),o=f.fromBuffer(t),c=f.fromBuffer(t),d=t.readObject(fn),_=t.readNumber(),m=f.fromBuffer(t).toString(),h=Wt(t.readBytes(32)),g=E.fromBuffer(t);return new Ve(s,a,r,i,o,c,d,_,m,h,g)}toString(){return"0x"+this.toBuffer().toString("hex")}static fromString(e){const t=e.replace(/^0x/,"");return Ve.fromBuffer(Buffer.from(t,"hex"))}getSize(){const e=Math.ceil(Math.log2(Number(this.index)));return 4+this.note.items.length*f.SIZE_IN_BYTES+E.SIZE_IN_BYTES+f.SIZE_IN_BYTES*4+fn.SIZE+Je.SIZE_IN_BYTES+e}static async random({note:e=ks.random(),contractAddress:t=void 0,storageSlot:s=f.random(),nonce:a=f.random(),noteHash:r=f.random(),siloedNullifier:i=f.random(),txHash:o=fn.random(),l2BlockNumber:c=Math.floor(Math.random()*1e3),l2BlockHash:d=f.random().toString(),index:_=f.random().toBigInt(),recipient:m=void 0}={}){return new Ve(e,t??await E.random(),s,a,r,i,o,c,d,_,m??await E.random())}}const Js=10;function F_(n){const e=[];for(const t of n)for(let s=t.leftMostIndex;s<=t.rightMostIndex;s++)e.push(new vt(t.appTaggingSecret,s));return e}function q_(n){const e={};for(const t of n)e[t.appTaggingSecret.toString()]=t.index;return e}var ue,Da,pl,hs,hl,ml;class W_{constructor(e,t,s,a,r,i,o,c,d,_=V("pxe:pxe_oracle_interface")){w(this,ue);l(this,"aztecNode");l(this,"keyStore");l(this,"contractDataProvider");l(this,"noteDataProvider");l(this,"capsuleDataProvider");l(this,"syncDataProvider");l(this,"taggingDataProvider");l(this,"addressDataProvider");l(this,"privateEventDataProvider");l(this,"log");this.aztecNode=e,this.keyStore=t,this.contractDataProvider=s,this.noteDataProvider=a,this.capsuleDataProvider=r,this.syncDataProvider=i,this.taggingDataProvider=o,this.addressDataProvider=c,this.privateEventDataProvider=d,this.log=_}getKeyValidationRequest(e,t){return this.keyStore.getKeyValidationRequest(e,t)}async getCompleteAddress(e){const t=await this.addressDataProvider.getCompleteAddress(e);if(!t)throw new Error(`No public key registered for address ${e}.
        Register it by calling pxe.registerAccount(...).
See docs for context: https://docs.aztec.network/developers/reference/debugging/aztecnr-errors#simulation-error-no-public-key-registered-for-address-0x0-register-it-by-calling-pxeregisterrecipient-or-pxeregisteraccount`);return t}async getContractInstance(e){const t=await this.contractDataProvider.getContractInstance(e);if(!t)throw new Error(`No contract instance found for address ${e.toString()}`);return t}async getNotes(e,t,s,a){return(await this.noteDataProvider.getNotes({contractAddress:e,storageSlot:t,status:s,scopes:a})).map(({contractAddress:i,storageSlot:o,nonce:c,note:d,noteHash:_,siloedNullifier:m,index:h})=>({contractAddress:i,storageSlot:o,nonce:c,note:d,noteHash:_,siloedNullifier:m,index:h}))}async getFunctionArtifact(e,t){const s=await this.contractDataProvider.getFunctionArtifact(e,t);if(!s)throw new Error(`Function artifact not found for contract ${e} and selector ${t}.`);const a=await this.contractDataProvider.getFunctionDebugMetadata(e,t);return{...s,debug:a}}async getFunctionArtifactByName(e,t){const s=await this.contractDataProvider.getContractInstance(e);if(!s)return;const a=await this.contractDataProvider.getContractArtifact(s.currentContractClassId);return a&&td(a,t)}async getL1ToL2MembershipWitness(e,t,s){const[a,r]=await po(this.aztecNode,e,t,s);return new df(a,r)}getL1ToL2MessageHash(e){throw new Error("Unimplemented in private!")}getNoteHash(e){throw new Error("Unimplemented in private!")}async getNullifierIndex(e){return await v(this,ue,Da).call(this,"latest",Pe.NULLIFIER_TREE,e)}async getMembershipWitness(e,t,s){const a=await v(this,ue,Da).call(this,e,t,s);if(!a)throw new Error(`Leaf value: ${s} not found in ${Pe[t]}`);const r=await v(this,ue,pl).call(this,e,t,a);return[new f(a),...r]}async getNullifierMembershipWitnessAtLatestBlock(e){return this.getNullifierMembershipWitness(await this.getBlockNumber(),e)}getNullifierMembershipWitness(e,t){return this.aztecNode.getNullifierMembershipWitness(e,t)}getLowNullifierMembershipWitness(e,t){return this.aztecNode.getLowNullifierMembershipWitness(e,t)}async getBlock(e){return await this.aztecNode.getBlock(e)}async getPublicDataWitness(e,t){return await this.aztecNode.getPublicDataWitness(e,t)}async getPublicStorageAt(e,t,s){return await this.aztecNode.getPublicStorageAt(e,t,s)}getBlockHeader(){return this.syncDataProvider.getBlockHeader()}async getBlockNumber(){return await this.aztecNode.getBlockNumber()}async getChainId(){return await this.aztecNode.getChainId()}async getVersion(){return await this.aztecNode.getVersion()}getDebugFunctionName(e,t){return this.contractDataProvider.getDebugFunctionName(e,t)}getSenders(){return this.taggingDataProvider.getSenderAddresses()}async getIndexedTaggingSecretAsSender(e,t,s){await this.syncTaggedLogsAsSender(e,t,s);const a=await v(this,ue,hs).call(this,e,t,s),[r]=await this.taggingDataProvider.getTaggingSecretsIndexesAsSender([a],t);return new vt(a,r)}async incrementAppTaggingSecretIndexAsSender(e,t,s){const a=await v(this,ue,hs).call(this,e,t,s),r=await this.contractDataProvider.getDebugContractName(e);this.log.debug(`Incrementing app tagging secret at ${r}(${e})`,{secret:a,sender:t,recipient:s,contractName:r,contractAddress:e});const[i]=await this.taggingDataProvider.getTaggingSecretsIndexesAsSender([a],t);await this.taggingDataProvider.setTaggingSecretsIndexesAsSender([new vt(a,i+1)],t)}async syncTaggedLogsAsSender(e,t,s){const a=await v(this,ue,hs).call(this,e,t,s),[r]=await this.taggingDataProvider.getTaggingSecretsIndexesAsSender([a],t),i=10,o=i*2;let[c,d]=[0,r];do{const m=await nd(o,b=>new vt(a,d+b).computeSiloedTag(s,e)),g=(await this.aztecNode.getLogsByTags(m)).findLastIndex(b=>b.length!==0);if(g===-1)break;d+=g+1,c=o-g-1}while(c<i);const _=await this.contractDataProvider.getDebugContractName(e);d!==r?(await this.taggingDataProvider.setTaggingSecretsIndexesAsSender([new vt(a,d)],t),this.log.debug(`Syncing logs for sender ${t} at contract ${_}(${e})`,{sender:t,secret:a,index:d,contractName:_,contractAddress:e})):this.log.debug(`No new logs found for sender ${t} at contract ${_}(${e})`)}async syncTaggedLogs(e,t,s){this.log.verbose("Searching for tagged logs",{contract:e});const a=await this.syncDataProvider.getBlockNumber(),r=s||await this.keyStore.getAccounts(),i=await this.contractDataProvider.getDebugContractName(e);for(const o of r){const c=await v(this,ue,hl).call(this,e,o);let d=c.map(h=>({appTaggingSecret:h.appTaggingSecret,leftMostIndex:Math.max(0,h.index-Js),rightMostIndex:h.index+Js}));const _={},m=q_(c);for(;d.length>0;){const h=F_(d),g=await Promise.all(h.map(x=>x.computeSiloedTag(o,e))),b={},N=await this.aztecNode.getLogsByTags(g);for(let x=0;x<N.length;x++){const P=N[x];if(P.length>0){const F=P.filter(H=>!H.isFromPublic);F.length<P.length&&this.log.warn(`Discarded ${P.filter(H=>H.isFromPublic).length} public logs with matching tags`);const T=F.filter(H=>H.blockNumber<=a);await v(this,ue,ml).call(this,e,t,o,T);const D=h[x],X=m[D.appTaggingSecret.toString()];this.log.debug(`Found ${F.length} logs as recipient ${o}`,{recipient:o,secret:D.appTaggingSecret,contractName:i,contractAddress:e}),D.index>=X&&(b[D.appTaggingSecret.toString()]===void 0||D.index>=b[D.appTaggingSecret.toString()])&&(b[D.appTaggingSecret.toString()]=D.index+1,this.log.debug(`Incrementing index to ${D.index+1} at contract ${i}(${e})`))}}const A=[];for(const[x,P]of Object.entries(b)){const F=c.find(T=>T.appTaggingSecret.toString()===x);if(F)A.push({appTaggingSecret:F.appTaggingSecret,leftMostIndex:P,rightMostIndex:P+Js}),_[x]=P;else throw new Error(`Secret not found for appTaggingSecret ${x}. This is a bug as it should never happen!`)}d=A}await this.taggingDataProvider.setTaggingSecretsIndexesAsRecipient(Object.entries(_).map(([h,g])=>new vt(f.fromHexString(h),g)),o)}}async deliverNote(e,t,s,a,r,i,o,c){const d=await this.syncDataProvider.getBlockNumber(),_=await nr(s,await sr(e,r)),m=await Pn(e,i),[h]=await this.aztecNode.findLeavesIndexes(d,Pe.NOTE_HASH_TREE,[_]);if(h===void 0)throw new Error(`Note hash ${r} (uniqued as ${_}) is not present on the tree at block ${d} (from tx ${o})`);const g=new Ve(new ks(a),e,t,s,r,m,o,h==null?void 0:h.l2BlockNumber,h==null?void 0:h.l2BlockHash,h==null?void 0:h.data,c);await this.noteDataProvider.addNotes([g],c),this.log.verbose("Added note",{index:g.index,contract:g.contractAddress.toString(),slot:g.storageSlot.toString(),noteHash:g.noteHash.toString(),nullifier:g.siloedNullifier.toString()});const[b]=await this.aztecNode.findLeavesIndexes(d,Pe.NULLIFIER_TREE,[m]);if(b!==void 0){const{data:N,...A}=b;await this.noteDataProvider.removeNullifiedNotes([{data:m,...A}],c),this.log.verbose("Removed just-added note",{contract:e,slot:t,noteHash:r,nullifier:m.toString()})}}async getLogByTag(e){const s=(await this.aztecNode.getLogsByTags([e]))[0];if(this.log.debug(`Got ${s.length} logs for tag ${e}`),s.length==0)return null;if(s.length>1)throw new Error(`Got ${s.length} logs for tag ${e}. getLogByTag currently only supports a single log per tag`);const a=s[0],r=await this.aztecNode.getTxEffect(a.txHash);if(r==null)throw new Error(`Unexpected: failed to retrieve tx effects for tx ${a.txHash} which is known to exist`);const i=(a.isFromPublic?[a.log.contractAddress.toField()]:[]).concat(a.log.getEmittedFields());return new js(i,a.txHash,r.data.noteHashes,r.data.nullifiers[0])}async removeNullifiedNotes(e){this.log.verbose("Searching for nullifiers of known notes",{contract:e});const t=await this.syncDataProvider.getBlockNumber();for(const s of await this.keyStore.getAccounts()){const a=await this.noteDataProvider.getNotes({contractAddress:e,recipient:s});if(a.length===0)continue;const r=a.map(d=>d.siloedNullifier),i=await this.aztecNode.findLeavesIndexes(t,Pe.NULLIFIER_TREE,r),o=r.map((d,_)=>{if(i[_]!==void 0)return{...i[_],data:d}}).filter(d=>d!==void 0);(await this.noteDataProvider.removeNullifiedNotes(o,s)).forEach(d=>{this.log.verbose(`Removed note for contract ${d.contractAddress} at slot ${d.storageSlot}`,{contract:d.contractAddress,slot:d.storageSlot,nullifier:d.siloedNullifier.toString()})})}}storeCapsule(e,t,s){return this.capsuleDataProvider.storeCapsule(e,t,s)}loadCapsule(e,t){return this.capsuleDataProvider.loadCapsule(e,t)}deleteCapsule(e,t){return this.capsuleDataProvider.deleteCapsule(e,t)}copyCapsule(e,t,s,a){return this.capsuleDataProvider.copyCapsule(e,t,s,a)}async getSharedSecret(e,t){const s=await this.getCompleteAddress(e),a=await this.keyStore.getMasterSecretKey(s.publicKeys.masterIncomingViewingPublicKey),r=await sd(await s.getPreaddress(),a);return Fd(r,t)}async storePrivateEventLog(e,t,s,a,r,i,o){const d=(await this.aztecNode.getTxReceipt(r)).blockNumber;if(d===void 0)throw new Error(`Block number is undefined for tx ${r} in storePrivateEventLog`);const _=await this.syncDataProvider.getBlockNumber();if(d>_)throw new Error(`Attempting to store private event log from a block newer than the historical block of the simulation. Log block number: ${d}, historical block number: ${_}`);return this.privateEventDataProvider.storePrivateEventLog(e,t,s,a,r,i,o,d)}}ue=new WeakSet,Da=async function(e,t,s){const[a]=await this.aztecNode.findLeavesIndexes(e,t,[s]);return a==null?void 0:a.data},pl=async function(e,t,s){switch(t){case Pe.NULLIFIER_TREE:return(await this.aztecNode.getNullifierSiblingPath(e,s)).toFields();case Pe.NOTE_HASH_TREE:return(await this.aztecNode.getNoteHashSiblingPath(e,s)).toFields();case Pe.PUBLIC_DATA_TREE:return(await this.aztecNode.getPublicDataSiblingPath(e,s)).toFields();case Pe.ARCHIVE:return(await this.aztecNode.getArchiveSiblingPath(e,s)).toFields();default:throw new Error("Not implemented")}},hs=async function(e,t,s){const a=await this.getCompleteAddress(t),r=await this.keyStore.getMasterIncomingViewingSecretKey(t);return qr(a,r,s,e)},hl=async function(e,t){const s=await this.getCompleteAddress(t),a=await this.keyStore.getMasterIncomingViewingSecretKey(t),r=[...await this.taggingDataProvider.getSenderAddresses(),...await this.keyStore.getAccounts()].filter((c,d,_)=>d===_.findIndex(m=>m.equals(c))),i=await Promise.all(r.map(c=>qr(s,a,c,e))),o=await this.taggingDataProvider.getTaggingSecretsIndexesAsRecipient(i,t);return i.map((c,d)=>new vt(c,o[d]))},ml=async function(e,t,s,a){const r=await Promise.all(a.map(async i=>{const o=await this.aztecNode.getTxEffect(i.txHash);if(!o)throw new Error(`Could not find tx effect for tx hash ${i.txHash}`);return new Bd(i.log.fields,i.txHash,o.data.noteHashes,o.data.nullifiers[0],s,i.logIndexInTx,o.txIndexInBlock).toFields()}));return this.capsuleDataProvider.appendToCapsuleArray(e,t,r)};var Nt,Ee,Ot,Xs,gl;class M_{constructor(e){w(this,Xs);w(this,Nt);w(this,Ee);w(this,Ot);z(this,Nt,e),z(this,Ee,u(this,Nt).openArray("complete_addresses")),z(this,Ot,u(this,Nt).openMap("complete_address_index"))}addCompleteAddress(e){return u(this,Nt).transactionAsync(async()=>{const t=e.address.toString(),s=e.toBuffer(),a=await u(this,Ot).getAsync(t);if(a===void 0){const r=await u(this,Ee).lengthAsync();return await u(this,Ee).push(s),await u(this,Ot).set(t,r),!0}else{const r=await u(this,Ee).atAsync(a);if(r&&Buffer.from(r).equals(s))return!1;throw new Error(`Complete address with aztec address ${t} but different public key or partial key already exists in memory database`)}})}getCompleteAddress(e){return v(this,Xs,gl).call(this,e)}async getCompleteAddresses(){return await Promise.all((await M(u(this,Ee).valuesAsync())).map(e=>us.fromBuffer(e)))}async getSize(){return await u(this,Ee).lengthAsync()*us.SIZE_IN_BYTES}}Nt=new WeakMap,Ee=new WeakMap,Ot=new WeakMap,Xs=new WeakSet,gl=async function(e){const t=await u(this,Ot).getAsync(e.toString());if(t===void 0)return;const s=await u(this,Ee).atAsync(t);return s?await us.fromBuffer(s):void 0};var Tt,Le;class R_{constructor(e){w(this,Tt);w(this,Le);l(this,"logger");z(this,Tt,e),z(this,Le,u(this,Tt).openMap("capsules")),this.logger=V("pxe:capsule-data-provider")}async storeCapsule(e,t,s){await u(this,Le).set(Ln(e,t),Buffer.concat(s.map(a=>a.toBuffer())))}async loadCapsule(e,t){const s=await u(this,Le).getAsync(Ln(e,t));if(!s)return this.logger.debug(`Data not found for contract ${e.toString()} and slot ${t.toString()}`),null;const a=[];for(let r=0;r<s.length;r+=f.SIZE_IN_BYTES)a.push(f.fromBuffer(s.subarray(r,r+f.SIZE_IN_BYTES)));return a}async deleteCapsule(e,t){await u(this,Le).delete(Ln(e,t))}copyCapsule(e,t,s,a){return u(this,Tt).transactionAsync(async()=>{const r=Array.from(Array(a).keys());t.lt(s)&&r.reverse();for(const i of r){const o=Ln(e,t.add(new f(i))),c=Ln(e,s.add(new f(i))),d=await u(this,Le).getAsync(o);if(!d)throw new Error(`Attempted to copy empty slot ${o} for contract ${e.toString()}`);await u(this,Le).set(c,d)}})}appendToCapsuleArray(e,t,s){return u(this,Tt).transactionAsync(async()=>{const a=await this.loadCapsule(e,t),r=a?a[0].toBigInt():0n;for(let o=0;o<s.length;o++){const c=t.add(new f(1)).add(new f(r+BigInt(o)));await this.storeCapsule(e,c,s[o])}const i=r+BigInt(s.length);await this.storeCapsule(e,t,[new f(i)])})}async getSize(){return(await M(u(this,Le).valuesAsync())).reduce((e,t)=>e+t.length*f.SIZE_IN_BYTES,0)}}Tt=new WeakMap,Le=new WeakMap;function Ln(n,e){return`${n.toString()}:${e.toString()}`}class kr{constructor(e){l(this,"privateFunctions");l(this,"tree");this.privateFunctions=e}static async create(e){const t=await Promise.all(e.functions.filter(s=>s.functionType===lt.PRIVATE).map(ad));return new kr(t)}async getFunctionMembershipWitness(e){const t=this.privateFunctions.find(o=>o.selector.equals(e));if(!t)throw new Error(`Private function with selector ${e.toString()} not found in contract class.`);const s=await rd(t),a=await this.getTree(),r=a.getIndex(s),i=a.getSiblingPath(r);return new ee(ba,BigInt(r),_e(i.map(f.fromBuffer),ba))}async getTree(){return this.tree||(this.tree=await id(this.privateFunctions)),this.tree}}var pn,Et,Lt,Ue,$,bl,yl,Fe,ja,Ia;class V_{constructor(e){w(this,$);w(this,pn,new Map);w(this,Et,new Map);w(this,Lt);w(this,Ue);z(this,Lt,e.openMap("contract_artifacts")),z(this,Ue,e.openMap("contracts_instances"))}async addContractArtifact(e,t){const s=t.functions.filter(r=>r.functionType===lt.PRIVATE),a=await Promise.all(s.map(async r=>(await De.fromNameAndParameters(r.name,r.parameters)).toString()));if(a.length!==new Set(a).size)throw new Error("Repeated function selectors of private functions");await u(this,Lt).set(e.toString(),od(t))}async addContractInstance(e){u(this,Et).set(e.address.toString(),e.currentContractClassId),await u(this,Ue).set(e.address.toString(),new Wr(e).toBuffer())}async getContractsAddresses(){return(await M(u(this,Ue).keysAsync())).map(E.fromString)}async getContractInstance(e){const t=await u(this,Ue).getAsync(e.toString());return t&&Wr.fromBuffer(t).withAddress(e)}async getContractArtifact(e){const t=await u(this,Lt).getAsync(e.toString());return t&&ld(Buffer.from(t))}async getContractClass(e){const t=await this.getContractArtifact(e);return t&&dn(t)}async getContract(e){const t=await this.getContractInstance(e);if(!t)return;const s=await this.getContractArtifact(t.currentContractClassId);if(s)return{...t,...s}}async getFunctionArtifact(e,t){const s=await v(this,$,Fe).call(this,e),a=s&&await v(this,$,ja).call(this,s,t);return a&&{...a,contractName:s.name}}async getPublicFunctionArtifact(e){const t=await v(this,$,Fe).call(this,e),s=t&&t.functions.find(a=>a.functionType===lt.PUBLIC);return s&&{...s,contractName:t.name}}async getFunctionArtifactByName(e,t){const s=await v(this,$,Fe).call(this,e);return s==null?void 0:s.functions.find(a=>a.name===t)}async getFunctionAbi(e,t){const s=await v(this,$,Fe).call(this,e);return s&&await v(this,$,Ia).call(this,s,t)}async getFunctionDebugMetadata(e,t){const s=await v(this,$,Fe).call(this,e),a=s&&await v(this,$,ja).call(this,s,t);return a&&Mr(s,a)}async getPublicFunctionDebugMetadata(e){const t=await v(this,$,Fe).call(this,e),s=t&&t.functions.find(a=>a.functionType===lt.PUBLIC);return s&&Mr(t,s)}async getFunctionMembershipWitness(e,t){const s=await v(this,$,yl).call(this,e);return s==null?void 0:s.getFunctionMembershipWitness(t)}async getDebugContractName(e){const t=await v(this,$,Fe).call(this,e);return t==null?void 0:t.name}async getDebugFunctionName(e,t){const s=await v(this,$,Fe).call(this,e),a=s&&await v(this,$,Ia).call(this,s,t);return`${(s==null?void 0:s.name)??e}:${(a==null?void 0:a.name)??t}`}async getSize(){return(await M(u(this,Ue).valuesAsync())).concat(await M(u(this,Lt).valuesAsync())).reduce((e,t)=>e+t.length,0)}}pn=new WeakMap,Et=new WeakMap,Lt=new WeakMap,Ue=new WeakMap,$=new WeakSet,bl=async function(e){if(!u(this,Et).has(e.toString())){const t=await this.getContractInstance(e);if(!t)return;u(this,Et).set(e.toString(),t.currentContractClassId)}return u(this,Et).get(e.toString())},yl=async function(e){if(!u(this,pn).has(e.toString())){const t=await this.getContractArtifact(e);if(!t)return;const s=await kr.create(t);u(this,pn).set(e.toString(),s)}return u(this,pn).get(e.toString())},Fe=async function(e){const t=await v(this,$,bl).call(this,e);return t&&this.getContractArtifact(t)},ja=async function(e,t){const s=e.functions;for(let a=0;a<s.length;a++){const r=s[a];if((await De.fromNameAndParameters(r.name,r.parameters)).equals(t))return r}},Ia=async function(e,t){const s=[...e.functions,...e.nonDispatchPublicFunctions??[]];for(let a=0;a<s.length;a++){const r=s[a];if((await De.fromNameAndParameters(r.name,r.parameters)).equals(t))return r}};var he,ke,qe,We,St,Ht,Xt,Ct,Dt,jt,It,me,Me,ze,Ne,Oe,ge;const Or=class Or{constructor(e){w(this,he);w(this,ke);w(this,qe);w(this,We);w(this,St);w(this,Ht);w(this,Xt);w(this,Ct);w(this,Dt);w(this,jt);w(this,It);w(this,me);w(this,Me);w(this,ze);w(this,Ne);w(this,Oe);w(this,ge);z(this,he,e),z(this,ke,e.openMap("notes")),z(this,qe,e.openMap("nullified_notes")),z(this,We,e.openMap("nullifier_to_note")),z(this,St,e.openMultiMap("nullifier_to_block_number")),z(this,Ht,e.openMultiMap("nullified_notes_to_scope")),z(this,Xt,e.openMultiMap("nullified_notes_by_contract")),z(this,Ct,e.openMultiMap("nullified_notes_by_storage_slot")),z(this,Dt,e.openMultiMap("nullified_notes_by_tx_hash")),z(this,jt,e.openMultiMap("nullified_notes_by_recipient")),z(this,It,e.openMap("nullified_notes_by_nullifier")),z(this,me,e.openMap("scopes")),z(this,Me,e.openMultiMap("notes_to_scope")),z(this,ze,new Map),z(this,Ne,new Map),z(this,Oe,new Map),z(this,ge,new Map)}static async create(e){const t=new Or(e);for await(const s of u(t,me).keysAsync())u(t,ze).set(s,e.openMultiMap(`${s}:notes_by_contract`)),u(t,Ne).set(s,e.openMultiMap(`${s}:notes_by_storage_slot`)),u(t,Oe).set(s,e.openMultiMap(`${s}:notes_by_tx_hash`)),u(t,ge).set(s,e.openMultiMap(`${s}:notes_by_recipient`));return t}async addScope(e){const t=e.toString();return await u(this,me).hasAsync(t)?!1:(await u(this,me).set(t,!0),u(this,ze).set(t,u(this,he).openMultiMap(`${t}:notes_by_contract`)),u(this,Ne).set(t,u(this,he).openMultiMap(`${t}:notes_by_storage_slot`)),u(this,Oe).set(t,u(this,he).openMultiMap(`${t}:notes_by_tx_hash`)),u(this,ge).set(t,u(this,he).openMultiMap(`${t}:notes_by_recipient`)),!0)}async addNotes(e,t=E.ZERO){return await u(this,me).hasAsync(t.toString())||await this.addScope(t),u(this,he).transactionAsync(async()=>{for(const s of e){const a=qt(s.index,32).toString("hex");await u(this,ke).set(a,s.toBuffer()),await u(this,Me).set(a,t.toString()),await u(this,We).set(s.siloedNullifier.toString(),a),await u(this,ze).get(t.toString()).set(s.contractAddress.toString(),a),await u(this,Ne).get(t.toString()).set(s.storageSlot.toString(),a),await u(this,Oe).get(t.toString()).set(s.txHash.toString(),a),await u(this,ge).get(t.toString()).set(s.recipient.toString(),a)}})}removeNotesAfter(e){return u(this,he).transactionAsync(async()=>{const t=await M(u(this,ke).valuesAsync());for(const s of t){const a=Ve.fromBuffer(s);if(a.l2BlockNumber>e){const r=qt(a.index,32).toString("hex");await u(this,ke).delete(r),await u(this,Me).delete(r),await u(this,We).delete(a.siloedNullifier.toString());const i=await M(u(this,me).keysAsync());for(const o of i)await u(this,ge).get(o).deleteValue(a.recipient.toString(),r),await u(this,Oe).get(o).deleteValue(a.txHash.toString(),r),await u(this,ze).get(o).deleteValue(a.contractAddress.toString(),r),await u(this,Ne).get(o).deleteValue(a.storageSlot.toString(),r)}}})}async unnullifyNotesAfter(e,t){const s=[],a=e+1,r=t??a;for(let _=a;_<=r;_++)s.push(...await M(u(this,St).getValuesAsync(_)));const o=(await Promise.all(s.map(_=>u(this,It).getAsync(_)))).filter(_=>_!=null),d=(await Promise.all(o.map(_=>u(this,qe).getAsync(_)))).filter(_=>_!=null).map(_=>Ve.fromBuffer(_));await u(this,he).transactionAsync(async()=>{for(const _ of d){const m=qt(_.index,32).toString("hex");await u(this,ke).set(m,_.toBuffer()),await u(this,We).set(_.siloedNullifier.toString(),m);let h=await M(u(this,Ht).getValuesAsync(m))??[];h.length===0&&(h=[_.recipient.toString()]);for(const g of h)await u(this,ze).get(g.toString()).set(_.contractAddress.toString(),m),await u(this,Ne).get(g.toString()).set(_.storageSlot.toString(),m),await u(this,Oe).get(g.toString()).set(_.txHash.toString(),m),await u(this,ge).get(g.toString()).set(_.recipient.toString(),m),await u(this,Me).set(m,g);await u(this,qe).delete(m),await u(this,Ht).delete(m),await u(this,St).deleteValue(_.l2BlockNumber,_.siloedNullifier.toString()),await u(this,Xt).deleteValue(_.contractAddress.toString(),m),await u(this,Ct).deleteValue(_.storageSlot.toString(),m),await u(this,Dt).deleteValue(_.txHash.toString(),m),await u(this,jt).deleteValue(_.recipient.toString(),m),await u(this,It).delete(_.siloedNullifier.toString())}})}async getNotes(e){e.status=e.status??Rr.ACTIVE;const t=[];e.scopes??(e.scopes=(await M(u(this,me).keysAsync())).map(r=>E.fromString(r)));const s=[];for(const r of new Set(e.scopes)){const i=r.toString();if(!await u(this,me).hasAsync(i))throw new Error("Trying to get incoming notes of an scope that is not in the PXE database");s.push(e.recipient?await M(u(this,ge).get(i).getValuesAsync(e.recipient.toString())):e.txHash?await M(u(this,Oe).get(i).getValuesAsync(e.txHash.toString())):e.contractAddress?await M(u(this,ze).get(i).getValuesAsync(e.contractAddress.toString())):e.storageSlot?await M(u(this,Ne).get(i).getValuesAsync(e.storageSlot.toString())):await M(u(this,ge).get(i).valuesAsync()))}t.push({ids:new Set(s.flat()),notes:u(this,ke)}),e.status==Rr.ACTIVE_OR_NULLIFIED&&t.push({ids:e.recipient?await M(u(this,jt).getValuesAsync(e.recipient.toString())):e.txHash?await M(u(this,Dt).getValuesAsync(e.txHash.toString())):e.contractAddress?await M(u(this,Xt).getValuesAsync(e.contractAddress.toString())):e.storageSlot?await M(u(this,Ct).getValuesAsync(e.storageSlot.toString())):await M(u(this,qe).keysAsync()),notes:u(this,qe)});const a=[];for(const{ids:r,notes:i}of t)for(const o of r){const c=await i.getAsync(o);if(!c)continue;const d=Ve.fromBuffer(c);e.contractAddress&&!d.contractAddress.equals(e.contractAddress)||e.txHash&&!d.txHash.equals(e.txHash)||e.storageSlot&&!d.storageSlot.equals(e.storageSlot)||e.recipient&&!d.recipient.equals(e.recipient)||e.siloedNullifier&&!d.siloedNullifier.equals(e.siloedNullifier)||a.push(d)}return a}removeNullifiedNotes(e,t){return e.length===0?Promise.resolve([]):u(this,he).transactionAsync(async()=>{const s=[];for(const a of e){const{data:r,l2BlockNumber:i}=a,o=await u(this,We).getAsync(r.toString());if(!o)throw new Error("Nullifier not found in removeNullifiedNotes");const c=o?await u(this,ke).getAsync(o):void 0;if(!c)throw new Error("Note not found in removeNullifiedNotes");const d=await M(u(this,Me).getValuesAsync(o))??[],_=Ve.fromBuffer(c);if(!_.recipient.equals(t))throw new Error("Tried to nullify someone else's note");s.push(_),await u(this,ke).delete(o),await u(this,Me).delete(o);const m=await M(u(this,me).keysAsync());for(const h of m)await u(this,ge).get(h).deleteValue(_.recipient.toString(),o),await u(this,Oe).get(h).deleteValue(_.txHash.toString(),o),await u(this,ze).get(h).deleteValue(_.contractAddress.toString(),o),await u(this,Ne).get(h).deleteValue(_.storageSlot.toString(),o);if(d!==void 0)for(const h of d)await u(this,Ht).set(o,h);await u(this,qe).set(o,_.toBuffer()),await u(this,St).set(i,r.toString()),await u(this,Xt).set(_.contractAddress.toString(),o),await u(this,Ct).set(_.storageSlot.toString(),o),await u(this,Dt).set(_.txHash.toString(),o),await u(this,jt).set(_.recipient.toString(),o),await u(this,It).set(r.toString(),o),await u(this,We).delete(r.toString())}return s})}async getSize(){return(await this.getNotes({})).reduce((e,t)=>e+t.getSize(),0)}};he=new WeakMap,ke=new WeakMap,qe=new WeakMap,We=new WeakMap,St=new WeakMap,Ht=new WeakMap,Xt=new WeakMap,Ct=new WeakMap,Dt=new WeakMap,jt=new WeakMap,It=new WeakMap,me=new WeakMap,Me=new WeakMap,ze=new WeakMap,Ne=new WeakMap,Oe=new WeakMap,ge=new WeakMap;let Ba=Or;var Qe,$e,Bt,hn;class Y_{constructor(e){w(this,Qe);w(this,$e);w(this,Bt);w(this,hn);l(this,"logger",V("private_event_data_provider"));z(this,Qe,e),z(this,$e,u(this,Qe).openArray("private_event_logs")),z(this,Bt,u(this,Qe).openMap("private_event_log_index")),z(this,hn,u(this,Qe).openMap("seen_logs"))}storePrivateEventLog(e,t,s,a,r,i,o,c){return u(this,Qe).transactionAsync(async()=>{const d=`${e.toString()}_${t.toString()}_${s.toString()}`,_=`${r.toString()}_${i}`;if(await u(this,hn).getAsync(_)){this.logger.verbose("Ignoring duplicate event log",{txHash:r.toString(),logIndexInTx:i});return}this.logger.verbose("storing private event log",{contractAddress:e,recipient:t,msgContent:a,blockNumber:c});const h=await u(this,$e).lengthAsync();await u(this,$e).push({msgContent:I(a),blockNumber:c,logIndexInTx:i,txIndexInBlock:o});const g=await u(this,Bt).getAsync(d)||[];await u(this,Bt).set(d,[...g,h]),await u(this,hn).set(_,!0)})}async getPrivateEvents(e,t,s,a,r){const i=[];for(const o of a){const c=`${e.toString()}_${o.toString()}_${r.toString()}`,d=await u(this,Bt).getAsync(c)||[];for(const _ of d){const m=await u(this,$e).atAsync(_);if(!m||m.blockNumber<t||m.blockNumber>=t+s)continue;const h=B.asReader(m.msgContent),g=m.msgContent.length/f.SIZE_IN_BYTES,b=h.readArray(g,f);i.push({msgContent:b,blockNumber:m.blockNumber,logIndexInTx:m.logIndexInTx,txIndexInBlock:m.txIndexInBlock})}}return i.sort((o,c)=>o.blockNumber!==c.blockNumber?o.blockNumber-c.blockNumber:o.txIndexInBlock!==c.txIndexInBlock?o.txIndexInBlock-c.txIndexInBlock:o.logIndexInTx-c.logIndexInTx),i.map(o=>o.msgContent)}getSize(){return u(this,$e).lengthAsync()}}Qe=new WeakMap,$e=new WeakMap,Bt=new WeakMap,hn=new WeakMap;var Yn,et;class G_{constructor(e){w(this,Yn);w(this,et);z(this,Yn,e),z(this,et,u(this,Yn).openSingleton("header"))}async setHeader(e){await u(this,et).set(e.toBuffer())}async getBlockNumber(){const e=await u(this,et).getAsync();if(!e)throw new Error("Trying to get block number with a not-yet-synchronized PXE - this should never happen");return Number(Ps.fromBuffer(e).globalVariables.blockNumber.toBigInt())}async getBlockHeader(){const e=await u(this,et).getAsync();if(!e)throw new Error("Header not set");return Ps.fromBuffer(e)}async getSize(){var e;return((e=await u(this,et).getAsync())==null?void 0:e.length)??0}}Yn=new WeakMap,et=new WeakMap;var tt,Se,nt,st,mt,Fa,qa;class Z_{constructor(e){w(this,mt);w(this,tt);w(this,Se);w(this,nt);w(this,st);z(this,tt,e),z(this,Se,u(this,tt).openMap("address_book")),z(this,nt,u(this,tt).openMap("tagging_secret_indexes_for_senders")),z(this,st,u(this,tt).openMap("tagging_secret_indexes_for_recipients"))}setTaggingSecretsIndexesAsSender(e,t){return v(this,mt,Fa).call(this,e,u(this,nt),t)}setTaggingSecretsIndexesAsRecipient(e,t){return v(this,mt,Fa).call(this,e,u(this,st),t)}getTaggingSecretsIndexesAsRecipient(e,t){return v(this,mt,qa).call(this,e,u(this,st),t)}getTaggingSecretsIndexesAsSender(e,t){return v(this,mt,qa).call(this,e,u(this,nt),t)}resetNoteSyncData(){return u(this,tt).transactionAsync(async()=>{const e=await M(u(this,st).keysAsync());await Promise.all(e.map(s=>u(this,st).delete(s)));const t=await M(u(this,nt).keysAsync());await Promise.all(t.map(s=>u(this,nt).delete(s)))})}async addSenderAddress(e){return await u(this,Se).hasAsync(e.toString())?!1:(await u(this,Se).set(e.toString(),!0),!0)}async getSenderAddresses(){return(await M(u(this,Se).keysAsync())).map(E.fromString)}async removeSenderAddress(e){return await u(this,Se).hasAsync(e.toString())?(await u(this,Se).delete(e.toString()),!0):!1}async getSize(){return 3*(await M(u(this,Se).keysAsync())).length*E.SIZE_IN_BYTES}}tt=new WeakMap,Se=new WeakMap,nt=new WeakMap,st=new WeakMap,mt=new WeakSet,Fa=function(e,t,s){return Promise.all(e.map(a=>t.set(`${a.appTaggingSecret.toString()}_${s.toString()}`,a.index)))},qa=function(e,t,s){return Promise.all(e.map(async a=>await t.getAsync(`${a.toString()}_${s.toString()}`)??0))};class K_{constructor(e,t,s,a,r,i={},o){l(this,"node");l(this,"syncDataProvider");l(this,"noteDataProvider");l(this,"taggingDataProvider");l(this,"l2TipsStore");l(this,"log");l(this,"isSyncing");l(this,"blockStream");this.node=e,this.syncDataProvider=t,this.noteDataProvider=s,this.taggingDataProvider=a,this.l2TipsStore=r,this.log=!o||typeof o=="string"?V(o?`pxe:synchronizer:${o}`:"pxe:synchronizer"):o,this.blockStream=this.createBlockStream(i)}createBlockStream(e){return new jd(this.node,this.l2TipsStore,this,V("pxe:block_stream"),{batchSize:e.l2BlockBatchSize,skipFinalized:!0})}async handleBlockStreamEvent(e){switch(await this.l2TipsStore.handleBlockStreamEvent(e),e.type){case"blocks-added":{const t=e.blocks.at(-1).block;this.log.verbose(`Updated pxe last block to ${t.number}`,{blockHash:t.hash(),archive:t.archive.root.toString(),header:t.header.toInspect()}),await this.syncDataProvider.setHeader(t.header);break}case"chain-pruned":{this.log.warn(`Pruning data after block ${e.block.number} due to reorg`);const t=await this.syncDataProvider.getBlockNumber();await this.noteDataProvider.unnullifyNotesAfter(e.block.number,t),await this.noteDataProvider.removeNotesAfter(e.block.number),await this.taggingDataProvider.resetNoteSyncData();const s=await this.node.getBlockHeader(e.block.number);s?await this.syncDataProvider.setHeader(s):this.log.error(`Block header not found for block number ${e.block.number} during chain prune`);break}}}async sync(){if(this.isSyncing!==void 0){this.log.debug("Waiting for the ongoing sync to finish"),await this.isSyncing;return}this.log.debug("Syncing PXE with the node");const e=this.doSync();this.isSyncing=e;try{await e}finally{this.isSyncing=void 0}}async doSync(){let e;try{e=await this.syncDataProvider.getBlockHeader()}catch{this.log.debug("Header is not set, requesting from the node")}e||await this.syncDataProvider.setHeader(await this.node.getBlockHeader(0)),await this.blockStream.sync()}getSynchedBlockNumber(){return this.syncDataProvider.getBlockNumber()}}async function Wa(n,e,t){const s=new Map;n.getCallStack().forEach(({contractAddress:a,functionSelector:r})=>{s.has(a.toString())||s.set(a.toString(),new Set),r&&s.get(a.toString()).add(r)}),await Promise.all([...s.entries()].map(async([a,r])=>{const i=E.fromString(a),o=await e.getContract(i);if(o){n.enrichWithContractName(i,o.name);const c=new Map;await Promise.all(o.functions.map(async d=>{const _=await De.fromNameAndParameters(d);c.set(_.toString(),d.name)}));for(const d of r)c.has(d.toString())?n.enrichWithFunctionName(i,d,c.get(d.toString())):t.warn(`Could not find function artifact in contract ${o.name} for function '${d}' when enriching error callstack`)}else t.warn(`Could not find contract in database for address: ${i} when enriching error callstack`)}))}async function J_(n,e,t){var d;const s=n.getCallStack(),a=s[s.length-1],r=await e.getPublicFunctionArtifact(a.contractAddress);if(!r)throw new Error(`Artifact not found when enriching public simulation error. Contract address: ${a.contractAddress}.`);const i=qu(n.revertData,r);i&&n.setOriginalMessage(n.getOriginalMessage()+`${i}`);const o=await e.getPublicFunctionDebugMetadata(a.contractAddress),c=n.getNoirCallStack();if(o){if(cd(c))try{const _=To(c,o.debugSymbols,o.files,0);n.setNoirCallStack(_)}catch(_){t.warn(`Could not resolve noir call stack for ${a.contractAddress.toString()}:${((d=a.functionName)==null?void 0:d.toString())??""}: ${_}`)}await Wa(n,e,t)}}var mn,C,rn,on,vl,wl,xl,Al,Pl,ms,kl,zl,gs;const Tr=class Tr{constructor(e,t,s,a,r,i,o,c,d,_,m,h,g,b,N,A,x){w(this,C);l(this,"node");l(this,"synchronizer");l(this,"keyStore");l(this,"contractDataProvider");l(this,"noteDataProvider");l(this,"capsuleDataProvider");l(this,"syncDataProvider");l(this,"taggingDataProvider");l(this,"addressDataProvider");l(this,"privateEventDataProvider");l(this,"simulator");l(this,"packageVersion");l(this,"proverEnabled");l(this,"proofCreator");l(this,"protocolContractsProvider");l(this,"log");l(this,"jobQueue");w(this,mn);this.node=e,this.synchronizer=t,this.keyStore=s,this.contractDataProvider=a,this.noteDataProvider=r,this.capsuleDataProvider=i,this.syncDataProvider=o,this.taggingDataProvider=c,this.addressDataProvider=d,this.privateEventDataProvider=_,this.simulator=m,this.packageVersion=h,this.proverEnabled=g,this.proofCreator=b,this.protocolContractsProvider=N,this.log=A,this.jobQueue=x}static async create(e,t,s,a,r,i,o){var On;const c=!o||typeof o=="string"?V(o?`pxe:service:${o}`:"pxe:service"):o,d=fu().version,_=!!i.proverEnabled,m=new M_(t),h=new Y_(t),g=new V_(t),b=await Ba.create(t),N=new G_(t),A=new Z_(t),x=new R_(t),P=new No(t),F=new Iu(t,"pxe"),T=new K_(e,N,b,A,F,i,o),D=new W_(e,P,g,b,x,N,A,m,h,c),X=new cf(D,a),H=new gu,te=new Tr(e,T,P,g,b,x,N,A,m,h,X,d,_,s,r,c,H);te.jobQueue.start(),await v(On=te,C,vl).call(On);const Ye=await te.getNodeInfo();return c.info(`Started PXE connected to chain ${Ye.l1ChainId} version ${Ye.rollupVersion}`),te}isL1ToL2MessageSynced(e){return this.node.isL1ToL2MessageSynced(e)}getL2ToL1MembershipWitness(e,t){return this.node.getL2ToL1MessageMembershipWitness(e,t)}getTxReceipt(e){return this.node.getTxReceipt(e)}getTxEffect(e){return this.node.getTxEffect(e)}getBlockNumber(){return this.node.getBlockNumber()}getProvenBlockNumber(){return this.node.getProvenBlockNumber()}getPublicLogs(e){return this.node.getPublicLogs(e)}getContractClassLogs(e){return this.node.getContractClassLogs(e)}getPublicStorageAt(e,t){return this.node.getPublicStorageAt("latest",e,t)}async getL1ToL2MembershipWitness(e,t,s){return await po(this.node,e,t,s)}async estimateDbSize(){const e=Object.keys(Pe).length*f.SIZE_IN_BYTES;return[...await Promise.all([this.addressDataProvider.getSize(),this.capsuleDataProvider.getSize(),this.contractDataProvider.getSize(),this.noteDataProvider.getSize(),this.syncDataProvider.getSize(),this.taggingDataProvider.getSize()]),e].reduce((s,a)=>s+a,0)}getContractInstance(e){return this.contractDataProvider.getContractInstance(e)}async getContractClassMetadata(e,t=!1){const s=await this.contractDataProvider.getContractArtifact(e);return s||this.log.warn(`No artifact found for contract class ${e.toString()} when looking for its metadata`),{contractClass:s&&await dn(s),isContractClassPubliclyRegistered:await v(this,C,wl).call(this,e),artifact:t?s:void 0}}async getContractMetadata(e){let t;try{t=await this.contractDataProvider.getContractInstance(e)}catch{this.log.warn(`No instance found for contract ${e.toString()} when looking for its metadata`)}return{contractInstance:t,isContractInitialized:await v(this,C,Al).call(this,e),isContractPubliclyDeployed:await v(this,C,xl).call(this,e)}}async registerAccount(e,t){const s=await this.keyStore.getAccounts(),a=await this.keyStore.addAccount(e,t);return s.includes(a.address)?(this.log.info(`Account:
 "${a.address.toString()}"
 already registered.`),a):(this.log.info(`Registered account ${a.address.toString()}`),this.log.debug(`Registered account
 ${a.toReadableString()}`),await this.addressDataProvider.addCompleteAddress(a),await this.noteDataProvider.addScope(a.address),a)}async registerSender(e){return(await this.keyStore.getAccounts()).includes(e)?(this.log.info(`Sender:
 "${e.toString()}"
 already registered.`),e):(await this.taggingDataProvider.addSenderAddress(e)?this.log.info(`Added sender:
 ${e.toString()}`):this.log.info(`Sender:
 "${e.toString()}"
 already registered.`),e)}getSenders(){return this.taggingDataProvider.getSenderAddresses()}async removeSender(e){await this.taggingDataProvider.removeSenderAddress(e)?this.log.info(`Removed sender:
 ${e.toString()}`):this.log.info(`Sender:
 "${e.toString()}"
 not in address book.`)}async getRegisteredAccounts(){const e=await this.addressDataProvider.getCompleteAddresses(),t=await this.keyStore.getAccounts();return e.filter(s=>t.find(a=>a.equals(s.address)))}async registerContractClass(e){const{id:t}=await dn(e);await this.contractDataProvider.addContractArtifact(t,e),this.log.info(`Added contract class ${e.name} with id ${t}`)}async registerContract(e){const{instance:t}=e;let{artifact:s}=e;if(s){const a=await dn(s),r=a.id;if(!r.equals(t.currentContractClassId))throw new Error(`Artifact does not match expected class id (computed ${r} but instance refers to ${t.currentContractClassId})`);if(!(await uo(t)).equals(t.address))throw new Error("Added a contract in which the address does not match the contract instance.");await this.contractDataProvider.addContractArtifact(a.id,s);const o=s.functions.filter(c=>c.functionType===lt.PUBLIC).map(c=>Vr(c.name,c.parameters));await this.node.registerContractFunctionSignatures(t.address,o)}else if(s=await this.contractDataProvider.getContractArtifact(t.currentContractClassId),!s)throw new Error(`Artifact not found when registering an instance. Contract class: ${t.currentContractClassId}.`);await this.contractDataProvider.addContractInstance(t),this.log.info(`Added contract ${s.name} at ${t.address.toString()} with class ${t.currentContractClassId}`)}updateContract(e,t){return v(this,C,on).call(this,async()=>{const s=await this.contractDataProvider.getContractInstance(e);if(!s)throw new Error(`Instance not found when updating a contract. Contract address: ${e}.`);const a=await dn(t);await this.synchronizer.sync();const r=await this.syncDataProvider.getBlockHeader(),i=await qo(e,s,this.node,r.globalVariables.blockNumber.toNumber());if(!a.id.equals(i))throw new Error("Could not update contract to a class different from the current one.");await this.contractDataProvider.addContractArtifact(a.id,t);const o=t.functions.filter(c=>c.functionType===lt.PUBLIC).map(c=>Vr(c.name,c.parameters));await this.node.registerContractFunctionSignatures(e,o),s.currentContractClassId=a.id,await this.contractDataProvider.addContractInstance(s),this.log.info(`Updated contract ${t.name} at ${e.toString()} to class ${a.id}`)})}getContracts(){return this.contractDataProvider.getContractsAddresses()}async getNotes(e){const s=(await this.noteDataProvider.getNotes(e)).map(async a=>{let r=e.recipient;if(r===void 0){const i=await this.addressDataProvider.getCompleteAddresses(),o=i.findIndex(d=>d.address.equals(a.recipient)),c=i[o];if(c===void 0)throw new Error(`Cannot find complete address for recipient ${a.recipient.toString()}`);r=c.address}return new dd(a.note,r,a.contractAddress,a.storageSlot,a.txHash,a.nonce)});return Promise.all(s)}async getBlock(e){return e<0&&(e=await this.node.getBlockNumber()),await this.node.getBlock(e)}async getCurrentBaseFees(){return await this.node.getCurrentBaseFees()}proveTx(e,t){return v(this,C,on).call(this,async()=>{const s=new U;try{let a;if(!t){const h=new U;await this.synchronizer.sync(),a=h.ms(),t=await v(this,C,ms).call(this,e)}const{publicInputs:r,clientIvcProof:i,executionSteps:o,timings:{proving:c}={}}=await v(this,C,gs).call(this,e,this.proofCreator,t,{simulate:!1,skipFeeEnforcement:!1,profileMode:"none"}),d=s.ms(),_=o.map(({functionName:h,timings:{witgen:g,oracles:b}})=>({functionName:h,time:g,oracles:b})),m={total:d,sync:a,proving:c,perFunction:_,unaccounted:d-((a??0)+(c??0)+_.reduce((h,{time:g})=>h+g,0))};return this.log.info(`Proving completed in ${d}ms`,{timings:m}),new ud(t,r,i,m)}catch(a){throw v(this,C,rn).call(this,a,re.inspect(e),re.inspect(t))}})}profileTx(e,t,s=!0,a){return v(this,C,on).call(this,async()=>{const r=new U;try{const i={origin:e.origin,functionSelector:e.functionSelector,simulatePublic:!1,msgSender:a,chainId:e.txContext.chainId,version:e.txContext.version,authWitnesses:e.authWitnesses.map(A=>A.requestHash)};this.log.info(`Profiling transaction execution request to ${e.functionSelector} at ${e.origin}`,i);const o=new U;await this.synchronizer.sync();const c=o.ms(),d=await v(this,C,ms).call(this,e,a),{executionSteps:_,timings:{proving:m}={}}=await v(this,C,gs).call(this,e,this.proofCreator,d,{simulate:s,skipFeeEnforcement:!1,profileMode:t}),h=r.ms(),g=_.map(({functionName:A,timings:{witgen:x,oracles:P}})=>({functionName:A,time:x,oracles:P})),b=_.reduce((A,{timings:x})=>A+(x.gateCount??0),0)??0,N={total:h-b,sync:c,proving:m,perFunction:g,unaccounted:h-((c??0)+(m??0)+g.reduce((A,{time:x})=>A+x,0)+b)};return new fd(_,N)}catch(i){throw v(this,C,rn).call(this,i,re.inspect(e),`profileMode=${t}`,`msgSender=${(a==null?void 0:a.toString())??"undefined"}`)}})}simulateTx(e,t,s=void 0,a=!1,r=!1,i){return v(this,C,on).call(this,async()=>{try{const o=new U,c={origin:e.origin,functionSelector:e.functionSelector,simulatePublic:t,msgSender:s,chainId:e.txContext.chainId,version:e.txContext.version,authWitnesses:e.authWitnesses.map(H=>H.requestHash)};this.log.info(`Simulating transaction execution request to ${e.functionSelector} at ${e.origin}`,c);const d=new U;await this.synchronizer.sync();const _=d.ms(),m=await v(this,C,ms).call(this,e,s,i),{publicInputs:h,executionSteps:g}=await v(this,C,gs).call(this,e,this.proofCreator,m,{simulate:!0,skipFeeEnforcement:r,profileMode:"none"}),b=new _d(m,h),N=b.toSimulatedTx();let A,x;if(t&&h.forPublic){const H=new U;x=await v(this,C,zl).call(this,N,r),A=H.ms()}let P;if(!a){const H=new U,te=await this.node.isValidTx(N,{isSimulation:!0,skipFeeEnforcement:r});if(P=H.ms(),te.result==="invalid")throw new Error("The simulated transaction is unable to be added to state and is invalid.")}const F=await N.getTxHash(),T=o.ms(),D=g.map(({functionName:H,timings:{witgen:te,oracles:Ye}})=>({functionName:H,time:te,oracles:Ye})),X={total:T,sync:_,publicSimulation:A,validation:P,perFunction:D,unaccounted:T-(_+(A??0)+(P??0)+D.reduce((H,{time:te})=>H+te,0))};return this.log.info(`Simulation completed for ${F.toString()} in ${T}ms`,{txHash:F,...c,...x?{gasUsed:x.gasUsed,revertCode:x.txEffect.revertCode.getCode(),revertReason:x.revertReason}:{},timings:X}),pd.fromPrivateSimulationResultAndPublicOutput(b,x,X)}catch(o){throw v(this,C,rn).call(this,o,re.inspect(e),`simulatePublic=${t}`,`msgSender=${(s==null?void 0:s.toString())??"undefined"}`,`skipTxValidation=${a}`,`scopes=${(i==null?void 0:i.map(c=>c.toString()).join(", "))??"undefined"}`)}})}async sendTx(e){const t=await e.getTxHash();if(await this.node.getTxEffect(t))throw new Error(`A settled tx with equal hash ${t.toString()} exists.`);return this.log.debug(`Sending transaction ${t}`),await this.node.sendTx(e).catch(s=>{throw v(this,C,rn).call(this,s,re.inspect(e))}),this.log.info(`Sent transaction ${t}`),t}simulateUtility(e,t,s,a,r,i){return v(this,C,on).call(this,async()=>{try{const o=new U,c=new U;await this.synchronizer.sync();const d=c.ms(),_=await v(this,C,Pl).call(this,e,t,s),m=new U,h=await v(this,C,kl).call(this,_,a??[],i),g=m.ms(),b=o.ms(),N=[{functionName:e,time:g}],A={total:b,sync:d,perFunction:N,unaccounted:b-(d+N.reduce((x,{time:P})=>x+P,0))};return{result:h,timings:A}}catch(o){const c=t.map(d=>d.toString()).join(", ");throw v(this,C,rn).call(this,o,`simulateUtility ${s}:${e}(${c})`,`scopes=${(i==null?void 0:i.map(d=>d.toString()).join(", "))??"undefined"}`)}})}async getNodeInfo(){if(!u(this,mn)){const[e,t,s,a,r,i]=await Promise.all([this.node.getNodeVersion(),this.node.getVersion(),this.node.getChainId(),this.node.getEncodedEnr(),this.node.getL1ContractAddresses(),this.node.getProtocolContractAddresses()]);z(this,mn,{nodeVersion:e,l1ChainId:s,rollupVersion:t,enr:a,l1ContractAddresses:r,protocolContractAddresses:i})}return u(this,mn)}getPXEInfo(){return Promise.resolve({pxeVersion:this.packageVersion,protocolContractAddresses:{classRegisterer:Ce.ContractClassRegisterer,feeJuice:Ce.FeeJuice,instanceDeployer:Ce.ContractInstanceDeployer,multiCallEntrypoint:Ce.MultiCallEntrypoint}})}async getPrivateEvents(e,t,s,a,r){if(r.length===0)throw new Error("Recipients are required to get private events");return this.log.verbose(`Getting private events for ${e.toString()} from ${s} to ${s+a}`),await this.simulateUtility("sync_private_state",[],e),(await this.privateEventDataProvider.getPrivateEvents(e,s,a,r,t.eventSelector)).map(c=>wa([t.abiType],c))}async getPublicEvents(e,t,s){const{logs:a}=await this.node.getPublicLogs({fromBlock:t,toBlock:t+s});return a.map(i=>{const o=e.fieldNames.length+1;if(i.log.emittedLength!==o)throw new Error(`Something is weird here, we have matching EventSelectors, but the actual payload has mismatched length. Expected ${o}. Got ${i.log.emittedLength}.`);const c=i.log.getEmittedFields();if(ao.fromField(c[c.length-1]).equals(e.eventSelector))return wa([e.abiType],i.log.fields)}).filter(i=>i!==void 0)}async resetNoteSyncData(){return await this.taggingDataProvider.resetNoteSyncData()}};mn=new WeakMap,C=new WeakSet,rn=function(e,...t){let s="";return t.length>0&&(s=`
Context:
${t.join(`
`)}`),e instanceof Sn?e.setAztecContext(s):(this.log.error(e.name,e),this.log.debug(s)),e},on=function(e){return this.jobQueue.length()!=0&&this.log.warn(`PXE is already processing ${this.jobQueue.length()} jobs, concurrent execution is not supported. Will run once those are complete.`),this.jobQueue.put(e)},vl=async function(){const e={};for(const t of Ri){const{address:s,contractClass:a,instance:r,artifact:i}=await this.protocolContractsProvider.getProtocolContractArtifact(t);await this.contractDataProvider.addContractArtifact(a.id,i),await this.contractDataProvider.addContractInstance(r),e[t]=s.toString()}this.log.verbose("Registered protocol contracts in pxe",e)},wl=async function(e){return!!await this.node.getContractClass(e)},xl=async function(e){return!!await this.node.getContract(e)},Al=async function(e){const t=await Pn(e,e.toField());return!!await this.node.getNullifierMembershipWitness("latest",t)},Pl=async function(e,t,s){const a=await this.contractDataProvider.getContract(s);if(!a)throw new Error(`Unknown contract ${s}: add it to PXE Service by calling server.addContracts(...).
See docs for context: https://docs.aztec.network/developers/reference/debugging/aztecnr-errors#unknown-contract-0x0-add-it-to-pxe-by-calling-serveraddcontracts`);const r=a.functions.find(i=>i.name===e);if(!r)throw new Error(`Unknown function ${e} in contract ${a.name}.`);return{name:r.name,args:Yi(r,t),selector:await De.fromNameAndParameters(r.name,r.parameters),type:r.functionType,to:s,isStatic:r.isStatic,returnTypes:r.returnTypes}},ms=async function(e,t,s){const{origin:a,functionSelector:r}=e;try{const i=await this.simulator.run(e,a,r,t,s);return this.log.debug(`Private simulation completed for ${a.toString()}:${r}`),i}catch(i){throw i instanceof Sn&&await Wa(i,this.contractDataProvider,this.log),i}},kl=async function(e,t,s){try{return this.simulator.runUtility(e,t??[],s)}catch(a){throw a instanceof Sn&&await Wa(a,this.contractDataProvider,this.log),a}},zl=async function(e,t){try{const s=await this.node.simulatePublicCalls(e,t);if(s.revertReason)throw s.revertReason;return s}catch(s){if(s instanceof Sn)try{await J_(s,this.contractDataProvider,this.log)}catch(a){this.log.error(`Failed to enrich public simulation error: ${a}`)}throw s}},gs=async function(e,t,s,a){const r=s.getSimulationBlockNumber(),i=new B_(this.contractDataProvider,this.keyStore,this.node,r),o=new I_(i,t,!this.proverEnabled);return this.log.debug(`Executing kernel trace prover (${JSON.stringify(a)})...`),await o.proveWithKernels(e.toTxRequest(),s,a)};let Ma=Tr;function O(n){const{keyAsBytes:e,keyAsFields:t,vkHash:s}=n;return new fe(new ae(t.map(a=>f.fromHexString(a)),f.fromHexString(s)),Buffer.from(e,"hex"))}const Us={PrivateKernelInitArtifact:"private_kernel_init",PrivateKernelInnerArtifact:"private_kernel_inner",PrivateKernelTailArtifact:"private_kernel_tail",PrivateKernelTailToPublicArtifact:"private_kernel_tail_to_public",PrivateKernelResetArtifact_32_4_32_4_4_4_4_4_4:"private_kernel_reset_32_4_32_4_4_4_4_4_4",PrivateKernelResetArtifact_32_4_32_4_4_4_4_4_32:"private_kernel_reset_32_4_32_4_4_4_4_4_32",PrivateKernelResetArtifact_32_4_32_4_4_4_4_64_4:"private_kernel_reset_32_4_32_4_4_4_4_64_4",PrivateKernelResetArtifact_32_4_32_4_4_4_4_64_32:"private_kernel_reset_32_4_32_4_4_4_4_64_32",PrivateKernelResetArtifact_32_4_32_4_4_4_64_4_4:"private_kernel_reset_32_4_32_4_4_4_64_4_4",PrivateKernelResetArtifact_32_4_32_4_4_4_64_4_32:"private_kernel_reset_32_4_32_4_4_4_64_4_32",PrivateKernelResetArtifact_32_4_32_4_4_4_64_64_4:"private_kernel_reset_32_4_32_4_4_4_64_64_4",PrivateKernelResetArtifact_32_4_32_4_4_4_64_64_32:"private_kernel_reset_32_4_32_4_4_4_64_64_32",PrivateKernelResetArtifact_32_4_32_16_4_4_4_4_4:"private_kernel_reset_32_4_32_16_4_4_4_4_4",PrivateKernelResetArtifact_32_4_32_16_4_4_4_4_32:"private_kernel_reset_32_4_32_16_4_4_4_4_32",PrivateKernelResetArtifact_32_4_32_16_4_4_4_64_4:"private_kernel_reset_32_4_32_16_4_4_4_64_4",PrivateKernelResetArtifact_32_4_32_16_4_4_4_64_32:"private_kernel_reset_32_4_32_16_4_4_4_64_32",PrivateKernelResetArtifact_32_4_32_16_4_4_64_4_4:"private_kernel_reset_32_4_32_16_4_4_64_4_4",PrivateKernelResetArtifact_32_4_32_16_4_4_64_4_32:"private_kernel_reset_32_4_32_16_4_4_64_4_32",PrivateKernelResetArtifact_32_4_32_16_4_4_64_64_4:"private_kernel_reset_32_4_32_16_4_4_64_64_4",PrivateKernelResetArtifact_32_4_32_16_4_4_64_64_32:"private_kernel_reset_32_4_32_16_4_4_64_64_32",PrivateKernelResetArtifact_32_16_32_4_4_4_4_4_4:"private_kernel_reset_32_16_32_4_4_4_4_4_4",PrivateKernelResetArtifact_32_16_32_4_4_4_4_4_32:"private_kernel_reset_32_16_32_4_4_4_4_4_32",PrivateKernelResetArtifact_32_16_32_4_4_4_4_64_4:"private_kernel_reset_32_16_32_4_4_4_4_64_4",PrivateKernelResetArtifact_32_16_32_4_4_4_4_64_32:"private_kernel_reset_32_16_32_4_4_4_4_64_32",PrivateKernelResetArtifact_32_16_32_4_4_4_64_4_4:"private_kernel_reset_32_16_32_4_4_4_64_4_4",PrivateKernelResetArtifact_32_16_32_4_4_4_64_4_32:"private_kernel_reset_32_16_32_4_4_4_64_4_32",PrivateKernelResetArtifact_32_16_32_4_4_4_64_64_4:"private_kernel_reset_32_16_32_4_4_4_64_64_4",PrivateKernelResetArtifact_32_16_32_4_4_4_64_64_32:"private_kernel_reset_32_16_32_4_4_4_64_64_32",PrivateKernelResetArtifact_32_16_32_16_4_4_4_4_4:"private_kernel_reset_32_16_32_16_4_4_4_4_4",PrivateKernelResetArtifact_32_16_32_16_4_4_4_4_32:"private_kernel_reset_32_16_32_16_4_4_4_4_32",PrivateKernelResetArtifact_32_16_32_16_4_4_4_64_4:"private_kernel_reset_32_16_32_16_4_4_4_64_4",PrivateKernelResetArtifact_32_16_32_16_4_4_4_64_32:"private_kernel_reset_32_16_32_16_4_4_4_64_32",PrivateKernelResetArtifact_32_16_32_16_4_4_64_4_4:"private_kernel_reset_32_16_32_16_4_4_64_4_4",PrivateKernelResetArtifact_32_16_32_16_4_4_64_4_32:"private_kernel_reset_32_16_32_16_4_4_64_4_32",PrivateKernelResetArtifact_32_16_32_16_4_4_64_64_4:"private_kernel_reset_32_16_32_16_4_4_64_64_4",PrivateKernelResetArtifact_32_16_32_16_4_4_64_64_32:"private_kernel_reset_32_16_32_16_4_4_64_64_32",PrivateKernelResetArtifact_64_0_0_0_0_0_0_0_0:"private_kernel_reset_64_0_0_0_0_0_0_0_0",PrivateKernelResetArtifact_0_64_0_0_0_0_0_0_0:"private_kernel_reset_0_64_0_0_0_0_0_0_0",PrivateKernelResetArtifact_0_0_64_0_0_0_0_0_0:"private_kernel_reset_0_0_64_0_0_0_0_0_0",PrivateKernelResetArtifact_0_0_0_64_0_0_0_0_0:"private_kernel_reset_0_0_0_64_0_0_0_0_0",PrivateKernelResetArtifact_0_0_0_0_64_0_0_0_0:"private_kernel_reset_0_0_0_0_64_0_0_0_0",PrivateKernelResetArtifact_0_0_0_0_0_64_0_0_0:"private_kernel_reset_0_0_0_0_0_64_0_0_0",PrivateKernelResetArtifact_4_4_4_4_4_4_4_4_4:"private_kernel_reset_4_4_4_4_4_4_4_4_4",PrivateKernelResetArtifact_16_16_16_16_16_16_16_16_16:"private_kernel_reset_16_16_16_16_16_16_16_16_16",PrivateKernelResetArtifact_32_32_32_32_32_32_32_32_32:"private_kernel_reset_32_32_32_32_32_32_32_32_32",PrivateKernelResetArtifact_64_64_64_64_64_64_64_64_32:"private_kernel_reset"};async function Ei(n,e){switch(n.includes("private_kernel_reset")?`${e?n.replace("private_kernel_reset","private_kernel_reset_simulated"):n}`:`${n}${e?"_simulated":""}`){case"private_kernel_init":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_init-BvcXUoDb.js");return{default:r}},[]);return{...a,name:"private_kernel_init"}}case"private_kernel_init_simulated":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_init_simulated-DDFfwbGm.js");return{default:r}},[]);return{...a,name:"private_kernel_init_simulated"}}case"private_kernel_inner":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_inner-DR_lB2ng.js");return{default:r}},[]);return{...a,name:"private_kernel_inner"}}case"private_kernel_inner_simulated":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_inner_simulated-D-hqDAxu.js");return{default:r}},[]);return{...a,name:"private_kernel_inner_simulated"}}case"private_kernel_tail":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_tail-qpp5eGK0.js");return{default:r}},[]);return{...a,name:"private_kernel_tail"}}case"private_kernel_tail_simulated":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_tail_simulated-DC_3mNBj.js");return{default:r}},[]);return{...a,name:"private_kernel_tail_simulated"}}case"private_kernel_tail_to_public":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_tail_to_public-Bn5ZzOdk.js");return{default:r}},[]);return{...a,name:"private_kernel_tail_to_public"}}case"private_kernel_tail_to_public_simulated":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_tail_to_public_simulated-D6ON2Odh.js");return{default:r}},[]);return{...a,name:"private_kernel_tail_to_public_simulated"}}case"private_kernel_reset_32_4_32_4_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_4_4_4_4_4_4-BAmSupjE.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_4_4_4_4_4_4"}}case"private_kernel_reset_simulated_32_4_32_4_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_4_4_4_4_4_4-BpZSHK8c.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_4_4_4_4_4_4"}}case"private_kernel_reset_32_4_32_4_4_4_4_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_4_4_4_4_4_32-Ddbyzfm1.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_4_4_4_4_4_32"}}case"private_kernel_reset_simulated_32_4_32_4_4_4_4_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_4_4_4_4_4_32-C8P4D1tx.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_4_4_4_4_4_32"}}case"private_kernel_reset_32_4_32_4_4_4_4_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_4_4_4_4_64_4-U3eXuYB2.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_4_4_4_4_64_4"}}case"private_kernel_reset_simulated_32_4_32_4_4_4_4_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_4_4_4_4_64_4-CvuKx1p2.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_4_4_4_4_64_4"}}case"private_kernel_reset_32_4_32_4_4_4_4_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_4_4_4_4_64_32-xhQbLeEt.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_4_4_4_4_64_32"}}case"private_kernel_reset_simulated_32_4_32_4_4_4_4_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_4_4_4_4_64_32-Cl2tUqe7.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_4_4_4_4_64_32"}}case"private_kernel_reset_32_4_32_4_4_4_64_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_4_4_4_64_4_4-C1jVOCrr.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_4_4_4_64_4_4"}}case"private_kernel_reset_simulated_32_4_32_4_4_4_64_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_4_4_4_64_4_4-DLjjUlvz.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_4_4_4_64_4_4"}}case"private_kernel_reset_32_4_32_4_4_4_64_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_4_4_4_64_4_32-DXHkk_-x.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_4_4_4_64_4_32"}}case"private_kernel_reset_simulated_32_4_32_4_4_4_64_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_4_4_4_64_4_32-DrHiHce1.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_4_4_4_64_4_32"}}case"private_kernel_reset_32_4_32_4_4_4_64_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_4_4_4_64_64_4-4ETvvkez.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_4_4_4_64_64_4"}}case"private_kernel_reset_simulated_32_4_32_4_4_4_64_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_4_4_4_64_64_4-CWVYc2tv.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_4_4_4_64_64_4"}}case"private_kernel_reset_32_4_32_4_4_4_64_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_4_4_4_64_64_32-CYCtzzDU.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_4_4_4_64_64_32"}}case"private_kernel_reset_simulated_32_4_32_4_4_4_64_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_4_4_4_64_64_32-E-8b8SCC.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_4_4_4_64_64_32"}}case"private_kernel_reset_32_4_32_16_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_16_4_4_4_4_4-CvbaIeOa.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_16_4_4_4_4_4"}}case"private_kernel_reset_simulated_32_4_32_16_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_16_4_4_4_4_4-C98K8XHI.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_16_4_4_4_4_4"}}case"private_kernel_reset_32_4_32_16_4_4_4_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_16_4_4_4_4_32-zpe0sVDM.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_16_4_4_4_4_32"}}case"private_kernel_reset_simulated_32_4_32_16_4_4_4_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_16_4_4_4_4_32-CVmNXhxT.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_16_4_4_4_4_32"}}case"private_kernel_reset_32_4_32_16_4_4_4_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_16_4_4_4_64_4-DSMMsIII.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_16_4_4_4_64_4"}}case"private_kernel_reset_simulated_32_4_32_16_4_4_4_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_16_4_4_4_64_4-CFy9v6K2.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_16_4_4_4_64_4"}}case"private_kernel_reset_32_4_32_16_4_4_4_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_16_4_4_4_64_32-Clr1G_ec.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_16_4_4_4_64_32"}}case"private_kernel_reset_simulated_32_4_32_16_4_4_4_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_16_4_4_4_64_32-DiSqoZ4L.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_16_4_4_4_64_32"}}case"private_kernel_reset_32_4_32_16_4_4_64_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_16_4_4_64_4_4-CRJu4qHX.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_16_4_4_64_4_4"}}case"private_kernel_reset_simulated_32_4_32_16_4_4_64_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_16_4_4_64_4_4-BDE0x8ud.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_16_4_4_64_4_4"}}case"private_kernel_reset_32_4_32_16_4_4_64_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_16_4_4_64_4_32-DvNqkSEd.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_16_4_4_64_4_32"}}case"private_kernel_reset_simulated_32_4_32_16_4_4_64_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_16_4_4_64_4_32-AhAdRuIW.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_16_4_4_64_4_32"}}case"private_kernel_reset_32_4_32_16_4_4_64_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_16_4_4_64_64_4-BGCk61jP.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_16_4_4_64_64_4"}}case"private_kernel_reset_simulated_32_4_32_16_4_4_64_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_16_4_4_64_64_4-CTbm6n6u.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_16_4_4_64_64_4"}}case"private_kernel_reset_32_4_32_16_4_4_64_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_4_32_16_4_4_64_64_32-CT-v9Vdn.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_4_32_16_4_4_64_64_32"}}case"private_kernel_reset_simulated_32_4_32_16_4_4_64_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_4_32_16_4_4_64_64_32-CSaqPLrN.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_4_32_16_4_4_64_64_32"}}case"private_kernel_reset_32_16_32_4_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_4_4_4_4_4_4-CNOI9zyg.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_4_4_4_4_4_4"}}case"private_kernel_reset_simulated_32_16_32_4_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_4_4_4_4_4_4-CL-0kjQs.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_4_4_4_4_4_4"}}case"private_kernel_reset_32_16_32_4_4_4_4_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_4_4_4_4_4_32-X-vAhs5H.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_4_4_4_4_4_32"}}case"private_kernel_reset_simulated_32_16_32_4_4_4_4_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_4_4_4_4_4_32-CFw8AIlj.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_4_4_4_4_4_32"}}case"private_kernel_reset_32_16_32_4_4_4_4_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_4_4_4_4_64_4-kfy6lvz5.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_4_4_4_4_64_4"}}case"private_kernel_reset_simulated_32_16_32_4_4_4_4_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_4_4_4_4_64_4-cpqfc3AN.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_4_4_4_4_64_4"}}case"private_kernel_reset_32_16_32_4_4_4_4_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_4_4_4_4_64_32-C32BDU8m.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_4_4_4_4_64_32"}}case"private_kernel_reset_simulated_32_16_32_4_4_4_4_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_4_4_4_4_64_32-D6hXqzE2.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_4_4_4_4_64_32"}}case"private_kernel_reset_32_16_32_4_4_4_64_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_4_4_4_64_4_4-5VBqyVhI.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_4_4_4_64_4_4"}}case"private_kernel_reset_simulated_32_16_32_4_4_4_64_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_4_4_4_64_4_4-CTlAZTbc.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_4_4_4_64_4_4"}}case"private_kernel_reset_32_16_32_4_4_4_64_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_4_4_4_64_4_32-DONglNE6.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_4_4_4_64_4_32"}}case"private_kernel_reset_simulated_32_16_32_4_4_4_64_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_4_4_4_64_4_32-BzY6hJCE.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_4_4_4_64_4_32"}}case"private_kernel_reset_32_16_32_4_4_4_64_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_4_4_4_64_64_4-ySOsUUvK.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_4_4_4_64_64_4"}}case"private_kernel_reset_simulated_32_16_32_4_4_4_64_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_4_4_4_64_64_4-CKRZaZeg.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_4_4_4_64_64_4"}}case"private_kernel_reset_32_16_32_4_4_4_64_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_4_4_4_64_64_32-CnTcokZU.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_4_4_4_64_64_32"}}case"private_kernel_reset_simulated_32_16_32_4_4_4_64_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_4_4_4_64_64_32-CkkJBQQE.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_4_4_4_64_64_32"}}case"private_kernel_reset_32_16_32_16_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_16_4_4_4_4_4-Cay2RbZa.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_16_4_4_4_4_4"}}case"private_kernel_reset_simulated_32_16_32_16_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_16_4_4_4_4_4-BfHKB77V.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_16_4_4_4_4_4"}}case"private_kernel_reset_32_16_32_16_4_4_4_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_16_4_4_4_4_32-BSZnCULO.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_16_4_4_4_4_32"}}case"private_kernel_reset_simulated_32_16_32_16_4_4_4_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_16_4_4_4_4_32-DAILKDcL.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_16_4_4_4_4_32"}}case"private_kernel_reset_32_16_32_16_4_4_4_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_16_4_4_4_64_4-BMwPKcE_.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_16_4_4_4_64_4"}}case"private_kernel_reset_simulated_32_16_32_16_4_4_4_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_16_4_4_4_64_4-DkMe0uBk.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_16_4_4_4_64_4"}}case"private_kernel_reset_32_16_32_16_4_4_4_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_16_4_4_4_64_32-DOkTV9ME.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_16_4_4_4_64_32"}}case"private_kernel_reset_simulated_32_16_32_16_4_4_4_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_16_4_4_4_64_32-CtAPtNHZ.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_16_4_4_4_64_32"}}case"private_kernel_reset_32_16_32_16_4_4_64_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_16_4_4_64_4_4-CeVDuPNj.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_16_4_4_64_4_4"}}case"private_kernel_reset_simulated_32_16_32_16_4_4_64_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_16_4_4_64_4_4-BSpfnx0B.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_16_4_4_64_4_4"}}case"private_kernel_reset_32_16_32_16_4_4_64_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_16_4_4_64_4_32-BfRO6M1e.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_16_4_4_64_4_32"}}case"private_kernel_reset_simulated_32_16_32_16_4_4_64_4_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_16_4_4_64_4_32-BwII3f1R.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_16_4_4_64_4_32"}}case"private_kernel_reset_32_16_32_16_4_4_64_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_16_4_4_64_64_4-BJ9LeDxb.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_16_4_4_64_64_4"}}case"private_kernel_reset_simulated_32_16_32_16_4_4_64_64_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_16_4_4_64_64_4-DFffo3Ds.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_16_4_4_64_64_4"}}case"private_kernel_reset_32_16_32_16_4_4_64_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_16_32_16_4_4_64_64_32-DGkTyhN3.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_16_32_16_4_4_64_64_32"}}case"private_kernel_reset_simulated_32_16_32_16_4_4_64_64_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_16_32_16_4_4_64_64_32-D9q-TTbp.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_16_32_16_4_4_64_64_32"}}case"private_kernel_reset_64_0_0_0_0_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_64_0_0_0_0_0_0_0_0-DcjlyS5W.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_64_0_0_0_0_0_0_0_0"}}case"private_kernel_reset_simulated_64_0_0_0_0_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_64_0_0_0_0_0_0_0_0--9PlBvTb.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_64_0_0_0_0_0_0_0_0"}}case"private_kernel_reset_0_64_0_0_0_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_0_64_0_0_0_0_0_0_0-DU1-jFxI.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_0_64_0_0_0_0_0_0_0"}}case"private_kernel_reset_simulated_0_64_0_0_0_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_0_64_0_0_0_0_0_0_0-DOBvDka7.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_0_64_0_0_0_0_0_0_0"}}case"private_kernel_reset_0_0_64_0_0_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_0_0_64_0_0_0_0_0_0-DgVFF-7C.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_0_0_64_0_0_0_0_0_0"}}case"private_kernel_reset_simulated_0_0_64_0_0_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_0_0_64_0_0_0_0_0_0-iQ28ubb4.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_0_0_64_0_0_0_0_0_0"}}case"private_kernel_reset_0_0_0_64_0_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_0_0_0_64_0_0_0_0_0-N15YyS2z.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_0_0_0_64_0_0_0_0_0"}}case"private_kernel_reset_simulated_0_0_0_64_0_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_0_0_0_64_0_0_0_0_0-Cs2f9Sod.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_0_0_0_64_0_0_0_0_0"}}case"private_kernel_reset_0_0_0_0_64_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_0_0_0_0_64_0_0_0_0-C4rsKvJx.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_0_0_0_0_64_0_0_0_0"}}case"private_kernel_reset_simulated_0_0_0_0_64_0_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_0_0_0_0_64_0_0_0_0-CZcPhWDi.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_0_0_0_0_64_0_0_0_0"}}case"private_kernel_reset_0_0_0_0_0_64_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_0_0_0_0_0_64_0_0_0-BHrY2qm6.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_0_0_0_0_0_64_0_0_0"}}case"private_kernel_reset_simulated_0_0_0_0_0_64_0_0_0":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_0_0_0_0_0_64_0_0_0-CxH58GtN.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_0_0_0_0_0_64_0_0_0"}}case"private_kernel_reset_4_4_4_4_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_4_4_4_4_4_4_4_4_4-B-acXxrB.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_4_4_4_4_4_4_4_4_4"}}case"private_kernel_reset_simulated_4_4_4_4_4_4_4_4_4":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_4_4_4_4_4_4_4_4_4-mVyGzuB2.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_4_4_4_4_4_4_4_4_4"}}case"private_kernel_reset_16_16_16_16_16_16_16_16_16":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_16_16_16_16_16_16_16_16_16-BesaZYBx.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_16_16_16_16_16_16_16_16_16"}}case"private_kernel_reset_simulated_16_16_16_16_16_16_16_16_16":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_16_16_16_16_16_16_16_16_16-O2Nm4w4B.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_16_16_16_16_16_16_16_16_16"}}case"private_kernel_reset_32_32_32_32_32_32_32_32_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_32_32_32_32_32_32_32_32_32-B7P2b3rT.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_32_32_32_32_32_32_32_32_32"}}case"private_kernel_reset_simulated_32_32_32_32_32_32_32_32_32":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated_32_32_32_32_32_32_32_32_32-BDZcjYB3.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated_32_32_32_32_32_32_32_32_32"}}case"private_kernel_reset":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset-B7OIeLjD.js");return{default:r}},[]);return{...a,name:"private_kernel_reset"}}case"private_kernel_reset_simulated":{const{default:a}=await p(async()=>{const{default:r}=await import("./private_kernel_reset_simulated-J4_3kBJb.js");return{default:r}},[]);return{...a,name:"private_kernel_reset_simulated"}}default:throw new Error(`Unknown artifact: ${n}`)}}async function U_(n){switch(n){case"private_kernel_init":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_init.vk.data-CwI3J58s.js");return{default:t}},[]);return O(e)}case"private_kernel_inner":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_inner.vk.data-DnOJb9f7.js");return{default:t}},[]);return O(e)}case"private_kernel_tail":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_tail.vk.data-B_cqdqS8.js");return{default:t}},[]);return O(e)}case"private_kernel_tail_to_public":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_tail_to_public.vk.data-BZ9w3Wl9.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_4_4_4_4_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_4_4_4_4_4_4.vk.data-B85Q42H7.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_4_4_4_4_4_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_4_4_4_4_4_32.vk.data-CPTXd_55.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_4_4_4_4_64_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_4_4_4_4_64_4.vk.data-DQIOQ33U.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_4_4_4_4_64_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_4_4_4_4_64_32.vk.data-B4a5FYZj.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_4_4_4_64_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_4_4_4_64_4_4.vk.data-B26zA_wr.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_4_4_4_64_4_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_4_4_4_64_4_32.vk.data-me3yuCDe.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_4_4_4_64_64_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_4_4_4_64_64_4.vk.data-C7ww4rC-.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_4_4_4_64_64_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_4_4_4_64_64_32.vk.data-CO20sFse.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_16_4_4_4_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_16_4_4_4_4_4.vk.data-iaDsrofO.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_16_4_4_4_4_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_16_4_4_4_4_32.vk.data-q1e-ySkM.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_16_4_4_4_64_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_16_4_4_4_64_4.vk.data-pBiWBf9Q.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_16_4_4_4_64_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_16_4_4_4_64_32.vk.data-6r3EJioI.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_16_4_4_64_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_16_4_4_64_4_4.vk.data--9FowX5Y.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_16_4_4_64_4_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_16_4_4_64_4_32.vk.data-DLTIU_W0.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_16_4_4_64_64_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_16_4_4_64_64_4.vk.data-CWImu3Vd.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_4_32_16_4_4_64_64_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_4_32_16_4_4_64_64_32.vk.data-BWgRIw1o.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_4_4_4_4_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_4_4_4_4_4_4.vk.data-BulOaN-X.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_4_4_4_4_4_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_4_4_4_4_4_32.vk.data-B1mGBLKs.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_4_4_4_4_64_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_4_4_4_4_64_4.vk.data-CVLddtCn.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_4_4_4_4_64_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_4_4_4_4_64_32.vk.data-FNv7UqaC.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_4_4_4_64_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_4_4_4_64_4_4.vk.data-fSldaTKc.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_4_4_4_64_4_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_4_4_4_64_4_32.vk.data-COhR65g5.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_4_4_4_64_64_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_4_4_4_64_64_4.vk.data-Aof0hKJJ.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_4_4_4_64_64_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_4_4_4_64_64_32.vk.data-B10ngPdL.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_16_4_4_4_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_16_4_4_4_4_4.vk.data-CI1dHgx4.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_16_4_4_4_4_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_16_4_4_4_4_32.vk.data-CEGkQJ8L.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_16_4_4_4_64_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_16_4_4_4_64_4.vk.data-CisqjwI8.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_16_4_4_4_64_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_16_4_4_4_64_32.vk.data-CtmIrYc7.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_16_4_4_64_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_16_4_4_64_4_4.vk.data-zCVXz3e1.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_16_4_4_64_4_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_16_4_4_64_4_32.vk.data-BYIbKrfG.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_16_4_4_64_64_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_16_4_4_64_64_4.vk.data-EjvnfEOp.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_16_32_16_4_4_64_64_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_16_32_16_4_4_64_64_32.vk.data-CwCvPDaH.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_64_0_0_0_0_0_0_0_0":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_64_0_0_0_0_0_0_0_0.vk.data-nuhna2CB.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_0_64_0_0_0_0_0_0_0":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_0_64_0_0_0_0_0_0_0.vk.data-CIpTr7Qs.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_0_0_64_0_0_0_0_0_0":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_0_0_64_0_0_0_0_0_0.vk.data-DFG3xDbq.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_0_0_0_64_0_0_0_0_0":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_0_0_0_64_0_0_0_0_0.vk.data-By4cG2zI.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_0_0_0_0_64_0_0_0_0":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_0_0_0_0_64_0_0_0_0.vk.data-C1GGrQZy.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_0_0_0_0_0_64_0_0_0":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_0_0_0_0_0_64_0_0_0.vk.data-BYHw-dWU.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_4_4_4_4_4_4_4_4_4":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_4_4_4_4_4_4_4_4_4.vk.data-36F6cJ6l.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_16_16_16_16_16_16_16_16_16":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_16_16_16_16_16_16_16_16_16.vk.data-BAC2sM6-.js");return{default:t}},[]);return O(e)}case"private_kernel_reset_32_32_32_32_32_32_32_32_32":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset_32_32_32_32_32_32_32_32_32.vk.data-ClSSZ-F6.js");return{default:t}},[]);return O(e)}case"private_kernel_reset":{const{default:e}=await p(async()=>{const{default:t}=await import("./private_kernel_reset.vk.data-hypdqTgy.js");return{default:t}},[]);return O(e)}default:throw new Error(`Unknown artifact: ${n}`)}}class Q_{getClientCircuitArtifactByName(e){return Ei(Us[e],!1)}getSimulatedClientCircuitArtifactByName(e){return Ei(Us[e],!0)}getCircuitVkByName(e){return U_(Us[e])}}function Qs(n){switch(n){case"BaseParityArtifact":return"base-parity";case"RootParityArtifact":return"root-parity";case"PrivateBaseRollupArtifact":return"private-base-rollup";case"PublicBaseRollupArtifact":return"public-base-rollup";case"MergeRollupArtifact":return"merge-rollup";case"BlockRootRollupArtifact":return"block-root-rollup";case"SingleTxBlockRootRollupArtifact":return"single-tx-block-root-rollup";case"EmptyBlockRootRollupArtifact":return"empty-block-root-rollup";case"BlockMergeRollupArtifact":return"block-merge-rollup";case"RootRollupArtifact":return"root-rollup";case"PrivateKernelInitArtifact":return"private-kernel-init";case"PrivateKernelInnerArtifact":return"private-kernel-inner";case"PrivateKernelTailArtifact":return"private-kernel-tail";case"PrivateKernelTailToPublicArtifact":return"private-kernel-tail-to-public";default:{if(n.startsWith("PrivateKernelReset"))return"private-kernel-reset";throw new Error(`Unknown circuit type: ${n}`)}}}class $_{constructor(e,t,s=V("bb-prover")){l(this,"artifactProvider");l(this,"simulationProvider");l(this,"log");this.artifactProvider=e,this.simulationProvider=t,this.log=s}async generateInitOutput(e){return await this.generateCircuitOutput(e,"PrivateKernelInitArtifact",gi,xi)}async simulateInit(e){return await this.simulateCircuitOutput(e,"PrivateKernelInitArtifact",gi,xi)}async generateInnerOutput(e){return await this.generateCircuitOutput(e,"PrivateKernelInnerArtifact",bi,Ai)}async simulateInner(e){return await this.simulateCircuitOutput(e,"PrivateKernelInnerArtifact",bi,Ai)}async generateResetOutput(e){const t=e.trimToSizes(),s=Ni(e.dimensions);return await this.generateCircuitOutput(t,s,yi,Pi)}async simulateReset(e){X_(e);const t=e.trimToSizes(),s=Ni(e.dimensions);return await this.simulateCircuitOutput(t,s,yi,Pi)}async generateTailOutput(e){return e.isForPublic()?await this.generateCircuitOutput(e,"PrivateKernelTailToPublicArtifact",wi,zi):await this.generateCircuitOutput(e,"PrivateKernelTailArtifact",vi,ki)}async simulateTail(e){return e.isForPublic()?await this.simulateCircuitOutput(e,"PrivateKernelTailToPublicArtifact",wi,zi):await this.simulateCircuitOutput(e,"PrivateKernelTailArtifact",vi,ki)}async simulateCircuitOutput(e,t,s,a){const r=await this.artifactProvider.getSimulatedClientCircuitArtifactByName(t),i=s(e,r.abi),o=await this.simulationProvider.executeProtocolCircuit(i,r,Oi).catch(d=>{throw this.log.debug(`Failed to simulate ${t}`,{circuitName:Qs(t),error:d}),d}),c=a(o.witness,r.abi);return this.log.debug(`Simulated ${t}`,{eventName:"circuit-simulation",circuitName:Qs(t),duration:o.duration,inputSize:e.toBuffer().length,outputSize:c.toBuffer().length}),this.makeEmptyKernelSimulateOutput(c,t)}async generateCircuitOutput(e,t,s,a){this.log.debug(`Generating witness for ${t}`);const r=await this.artifactProvider.getClientCircuitArtifactByName(t),i=s(e,r.abi),o=await this.simulationProvider.executeProtocolCircuit(i,r,Oi),c=a(o.witness,r.abi);this.log.debug(`Generated witness for ${t}`,{eventName:"circuit-witness-generation",circuitName:Qs(t),duration:o.duration,inputSize:e.toBuffer().length,outputSize:c.toBuffer().length});const d=await this.artifactProvider.getCircuitVkByName(t),_=Buffer.from(r.bytecode,"base64");return{publicInputs:c,verificationKey:d,outputWitness:o.witness,bytecode:_}}async makeEmptyKernelSimulateOutput(e,t){return{publicInputs:e,verificationKey:await this.artifactProvider.getCircuitVkByName(t),outputWitness:new Map,bytecode:Buffer.from([])}}createClientIvcProof(e){throw new Error("Not implemented")}computeGateCountForCircuit(e,t){throw new Error("Not implemented")}}var Li={};class ep extends $_{constructor(t,s,a=1,r=V("bb-prover:wasm")){super(t,s,r);l(this,"artifactProvider");l(this,"simulationProvider");l(this,"threads");l(this,"log");this.artifactProvider=t,this.simulationProvider=s,this.threads=a,this.log=r}async createClientIvcProof(t){const s=new U;this.log.info("Generating ClientIVC proof...");const a=new Kr(t.map(o=>Ws(o.bytecode)),{threads:this.threads,logger:this.log.verbose,wasmPath:Li.BB_WASM_PATH}),[r,i]=await a.prove(t.map(o=>Ws(Ed(o.witness))),t.map(o=>o.vk));return await a.destroy(),this.log.info("Generated ClientIVC proof",{eventName:"client-ivc-proof-generation",duration:s.ms(),proofSize:r.length}),new co(Buffer.from(r))}async computeGateCountForCircuit(t,s){const a=new Kr([Ws(t)],{threads:this.threads,logger:this.log.verbose,wasmPath:Li.BB_WASM_PATH}),r=await a.gates();return await a.destroy(),r[0]}}class tp extends ep{constructor(e,t=16,s=V("bb-prover:wasm:lazy")){super(new Q_,e,t,s)}}function np(n){return n.syncGetters===!0}async function sp(n,e,t){if(!e)throw new Error("Rollup address is required");const s=n.openSingleton("rollupAddress"),a=e.toString(),r=np(n)?s.get():await s.getAsync();return typeof r<"u"&&r!==a&&(t==null||t.warn("Rollup address mismatch. Clearing entire database...",{expected:a,found:r}),await n.clear()),await s.set(a),n}const Ra=(n,e)=>e.some(t=>n instanceof t);let Si,Hi;function ap(){return Si||(Si=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function rp(){return Hi||(Hi=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const Va=new WeakMap,$s=new WeakMap,Bs=new WeakMap;function ip(n){const e=new Promise((t,s)=>{const a=()=>{n.removeEventListener("success",r),n.removeEventListener("error",i)},r=()=>{t(pt(n.result)),a()},i=()=>{s(n.error),a()};n.addEventListener("success",r),n.addEventListener("error",i)});return Bs.set(e,n),e}function op(n){if(Va.has(n))return;const e=new Promise((t,s)=>{const a=()=>{n.removeEventListener("complete",r),n.removeEventListener("error",i),n.removeEventListener("abort",i)},r=()=>{t(),a()},i=()=>{s(n.error||new DOMException("AbortError","AbortError")),a()};n.addEventListener("complete",r),n.addEventListener("error",i),n.addEventListener("abort",i)});Va.set(n,e)}let Ya={get(n,e,t){if(n instanceof IDBTransaction){if(e==="done")return Va.get(n);if(e==="store")return t.objectStoreNames[1]?void 0:t.objectStore(t.objectStoreNames[0])}return pt(n[e])},set(n,e,t){return n[e]=t,!0},has(n,e){return n instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in n}};function Nl(n){Ya=n(Ya)}function lp(n){return rp().includes(n)?function(...e){return n.apply(Ga(this),e),pt(this.request)}:function(...e){return pt(n.apply(Ga(this),e))}}function cp(n){return typeof n=="function"?lp(n):(n instanceof IDBTransaction&&op(n),Ra(n,ap())?new Proxy(n,Ya):n)}function pt(n){if(n instanceof IDBRequest)return ip(n);if($s.has(n))return $s.get(n);const e=cp(n);return e!==n&&($s.set(n,e),Bs.set(e,n)),e}const Ga=n=>Bs.get(n);function dp(n,e,{blocked:t,upgrade:s,blocking:a,terminated:r}={}){const i=indexedDB.open(n,e),o=pt(i);return s&&i.addEventListener("upgradeneeded",c=>{s(pt(i.result),c.oldVersion,c.newVersion,pt(i.transaction),c)}),t&&i.addEventListener("blocked",c=>t(c.oldVersion,c.newVersion,c)),o.then(c=>{r&&c.addEventListener("close",()=>r()),a&&c.addEventListener("versionchange",d=>a(d.oldVersion,d.newVersion,d))}).catch(()=>{}),o}function up(n,{blocked:e}={}){const t=indexedDB.deleteDatabase(n);return e&&t.addEventListener("blocked",s=>e(s.oldVersion,s)),pt(t).then(()=>{})}const fp=["get","getKey","getAll","getAllKeys","count"],_p=["put","add","delete","clear"],ea=new Map;function Xi(n,e){if(!(n instanceof IDBDatabase&&!(e in n)&&typeof e=="string"))return;if(ea.get(e))return ea.get(e);const t=e.replace(/FromIndex$/,""),s=e!==t,a=_p.includes(t);if(!(t in(s?IDBIndex:IDBObjectStore).prototype)||!(a||fp.includes(t)))return;const r=async function(i,...o){const c=this.transaction(i,a?"readwrite":"readonly");let d=c.store;return s&&(d=d.index(o.shift())),(await Promise.all([d[t](...o),a&&c.done]))[0]};return ea.set(e,r),r}Nl(n=>({...n,get:(e,t,s)=>Xi(e,t)||n.get(e,t,s),has:(e,t)=>!!Xi(e,t)||n.has(e,t)}));const pp=["continue","continuePrimaryKey","advance"],Ci={},Za=new WeakMap,Ol=new WeakMap,hp={get(n,e){if(!pp.includes(e))return n[e];let t=Ci[e];return t||(t=Ci[e]=function(...s){Za.set(this,Ol.get(this)[e](...s))}),t}};async function*mp(...n){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...n)),!e)return;e=e;const t=new Proxy(e,hp);for(Ol.set(t,e),Bs.set(t,Ga(e));e;)yield t,e=await(Za.get(t)||e.continue()),Za.delete(t)}function Di(n,e){return e===Symbol.asyncIterator&&Ra(n,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&Ra(n,[IDBIndex,IDBObjectStore])}Nl(n=>({...n,get(e,t,s){return Di(e,t)?mp:n.get(e,t,s)},has(e,t){return Di(e,t)||n.has(e,t)}}));function gp(n){return typeof n=="string"?`'${n}'`:new bp().serialize(n)}const bp=function(){var e;class n{constructor(){w(this,e,new Map)}compare(s,a){const r=typeof s,i=typeof a;return r==="string"&&i==="string"?s.localeCompare(a):r==="number"&&i==="number"?s-a:String.prototype.localeCompare.call(this.serialize(s,!0),this.serialize(a,!0))}serialize(s,a){if(s===null)return"null";switch(typeof s){case"string":return a?s:`'${s}'`;case"bigint":return`${s}n`;case"object":return this.$object(s);case"function":return this.$function(s)}return String(s)}serializeObject(s){const a=Object.prototype.toString.call(s);if(a!=="[object Object]")return this.serializeBuiltInType(a.length<10?`unknown:${a}`:a.slice(8,-1),s);const r=s.constructor,i=r===Object||r===void 0?"":r.name;if(i!==""&&globalThis[i]===r)return this.serializeBuiltInType(i,s);if(typeof s.toJSON=="function"){const o=s.toJSON();return i+(o!==null&&typeof o=="object"?this.$object(o):`(${this.serialize(o)})`)}return this.serializeObjectEntries(i,Object.entries(s))}serializeBuiltInType(s,a){const r=this["$"+s];if(r)return r.call(this,a);if(typeof(a==null?void 0:a.entries)=="function")return this.serializeObjectEntries(s,a.entries());throw new Error(`Cannot serialize ${s}`)}serializeObjectEntries(s,a){const r=Array.from(a).sort((o,c)=>this.compare(o[0],c[0]));let i=`${s}{`;for(let o=0;o<r.length;o++){const[c,d]=r[o];i+=`${this.serialize(c,!0)}:${this.serialize(d)}`,o<r.length-1&&(i+=",")}return i+"}"}$object(s){let a=u(this,e).get(s);return a===void 0&&(u(this,e).set(s,`#${u(this,e).size}`),a=this.serializeObject(s),u(this,e).set(s,a)),a}$function(s){const a=Function.prototype.toString.call(s);return a.slice(-15)==="[native code] }"?`${s.name||""}()[native]`:`${s.name}(${s.length})${a.replace(/\s*\n\s*/g,"")}`}$Array(s){let a="[";for(let r=0;r<s.length;r++)a+=this.serialize(s[r]),r<s.length-1&&(a+=",");return a+"]"}$Date(s){try{return`Date(${s.toISOString()})`}catch{return"Date(null)"}}$ArrayBuffer(s){return`ArrayBuffer[${new Uint8Array(s).join(",")}]`}$Set(s){return`Set${this.$Array(Array.from(s).sort((a,r)=>this.compare(a,r)))}`}$Map(s){return this.serializeObjectEntries("Map",s.entries())}}e=new WeakMap;for(const t of["Error","RegExp","URL"])n.prototype["$"+t]=function(s){return`${t}(${s})`};for(const t of["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"])n.prototype["$"+t]=function(s){return`${t}[${s.join(",")}]`};for(const t of["BigInt64Array","BigUint64Array"])n.prototype["$"+t]=function(s){return`${t}[${s.join("n,")}${s.length>0?"n":""}]`};return n}(),yp=[1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225],vp=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998],wp="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bt=[];let xp=class{constructor(){l(this,"_data",new un);l(this,"_hash",new un([...yp]));l(this,"_nDataBytes",0);l(this,"_minBufferSize",0)}finalize(e){e&&this._append(e);const t=this._nDataBytes*8,s=this._data.sigBytes*8;return this._data.words[s>>>5]|=128<<24-s%32,this._data.words[(s+64>>>9<<4)+14]=Math.floor(t/4294967296),this._data.words[(s+64>>>9<<4)+15]=t,this._data.sigBytes=this._data.words.length*4,this._process(),this._hash}_doProcessBlock(e,t){const s=this._hash.words;let a=s[0],r=s[1],i=s[2],o=s[3],c=s[4],d=s[5],_=s[6],m=s[7];for(let h=0;h<64;h++){if(h<16)bt[h]=e[t+h]|0;else{const F=bt[h-15],T=(F<<25|F>>>7)^(F<<14|F>>>18)^F>>>3,D=bt[h-2],X=(D<<15|D>>>17)^(D<<13|D>>>19)^D>>>10;bt[h]=T+bt[h-7]+X+bt[h-16]}const g=c&d^~c&_,b=a&r^a&i^r&i,N=(a<<30|a>>>2)^(a<<19|a>>>13)^(a<<10|a>>>22),A=(c<<26|c>>>6)^(c<<21|c>>>11)^(c<<7|c>>>25),x=m+A+g+vp[h]+bt[h],P=N+b;m=_,_=d,d=c,c=o+x|0,o=i,i=r,r=a,a=x+P|0}s[0]=s[0]+a|0,s[1]=s[1]+r|0,s[2]=s[2]+i|0,s[3]=s[3]+o|0,s[4]=s[4]+c|0,s[5]=s[5]+d|0,s[6]=s[6]+_|0,s[7]=s[7]+m|0}_append(e){typeof e=="string"&&(e=un.fromUtf8(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes}_process(e){let t,s=this._data.sigBytes/64;e?s=Math.ceil(s):s=Math.max((s|0)-this._minBufferSize,0);const a=s*16,r=Math.min(a*4,this._data.sigBytes);if(a){for(let i=0;i<a;i+=16)this._doProcessBlock(this._data.words,i);t=this._data.words.splice(0,a),this._data.sigBytes-=r}return new un(t,r)}};class un{constructor(e,t){l(this,"words");l(this,"sigBytes");e=this.words=e||[],this.sigBytes=t===void 0?e.length*4:t}static fromUtf8(e){const t=unescape(encodeURIComponent(e)),s=t.length,a=[];for(let r=0;r<s;r++)a[r>>>2]|=(t.charCodeAt(r)&255)<<24-r%4*8;return new un(a,s)}toBase64(){const e=[];for(let t=0;t<this.sigBytes;t+=3){const s=this.words[t>>>2]>>>24-t%4*8&255,a=this.words[t+1>>>2]>>>24-(t+1)%4*8&255,r=this.words[t+2>>>2]>>>24-(t+2)%4*8&255,i=s<<16|a<<8|r;for(let o=0;o<4&&t*8+o*6<this.sigBytes*8;o++)e.push(wp.charAt(i>>>6*(3-o)&63))}return e.join("")}concat(e){if(this.words[this.sigBytes>>>2]&=4294967295<<32-this.sigBytes%4*8,this.words.length=Math.ceil(this.sigBytes/4),this.sigBytes%4)for(let t=0;t<e.sigBytes;t++){const s=e.words[t>>>2]>>>24-t%4*8&255;this.words[this.sigBytes+t>>>2]|=s<<24-(this.sigBytes+t)%4*8}else for(let t=0;t<e.sigBytes;t+=4)this.words[this.sigBytes+t>>>2]=e.words[t>>>2];this.sigBytes+=e.sigBytes}}function Ap(n){return new xp().finalize(n).toBase64()}function Re(n){return Ap(gp(n))}var gn,Gn,He,be,Ft,jn;class Pp{constructor(e,t){w(this,Ft);w(this,gn);w(this,Gn);w(this,He);w(this,be);z(this,Gn,e),z(this,be,t),z(this,He,`array:${u(this,be)}`)}set db(e){z(this,gn,e)}get db(){return u(this,gn)?u(this,gn):u(this,Gn).transaction("data","readwrite").store}async lengthAsync(){return await this.db.index("key").count(IDBKeyRange.bound([u(this,He),u(this,be)],[u(this,He),u(this,be)]))??0}async push(...e){let t=await this.lengthAsync();for(const s of e)await this.db.put({value:s,hash:Re(s),container:u(this,He),key:u(this,be),keyCount:t+1,slot:v(this,Ft,jn).call(this,t)}),t+=1;return t}async pop(){const e=await this.lengthAsync();if(e===0)return;const t=v(this,Ft,jn).call(this,e-1),s=await this.db.get(t);return await this.db.delete(t),s==null?void 0:s.value}async atAsync(e){const t=await this.lengthAsync();e<0&&(e=t+e);const s=await this.db.get(v(this,Ft,jn).call(this,e));return s==null?void 0:s.value}async setAt(e,t){const s=await this.lengthAsync();return e<0&&(e=s+e),e<0||e>=s?Promise.resolve(!1):(await this.db.put({value:t,hash:Re(t),container:u(this,He),key:u(this,be),keyCount:e+1,slot:v(this,Ft,jn).call(this,e)}),!0)}async*entriesAsync(){const e=this.db.index("key"),t=IDBKeyRange.bound([u(this,He),u(this,be)],[u(this,He),u(this,be)]);for await(const s of e.iterate(t))yield[s.value.keyCount-1,s.value.value]}async*valuesAsync(){for await(const[e,t]of this.entriesAsync())yield t}[Symbol.asyncIterator](){return this.valuesAsync()}}gn=new WeakMap,Gn=new WeakMap,He=new WeakMap,be=new WeakMap,Ft=new WeakSet,jn=function(e){return`array:${u(this,be)}:slot:${e}`};var bn,Zn,Cs,Tl;class zr{constructor(e,t){w(this,Cs);l(this,"name");l(this,"container");w(this,bn);w(this,Zn);this.name=t,this.container=`map:${t}`,z(this,Zn,e)}set db(e){z(this,bn,e)}get db(){return u(this,bn)?u(this,bn):u(this,Zn).transaction("data","readwrite").store}async getAsync(e){const t=await this.db.get(this.slot(e));return t==null?void 0:t.value}async hasAsync(e){return await this.getAsync(e)!==void 0}async set(e,t){await this.db.put({value:t,hash:Re(t),container:this.container,key:this.normalizeKey(e),keyCount:1,slot:this.slot(e)})}swap(e,t){throw new Error("Not implemented")}async setIfNotExists(e,t){return await this.hasAsync(e)?!1:(await this.set(e,t),!0)}async delete(e){await this.db.delete(this.slot(e))}async*entriesAsync(e={}){const t=this.db.index("key"),s=IDBKeyRange.bound([this.container,e.start??""],[this.container,e.end??"￿"],!!e.reverse,!e.reverse);let a=0;for await(const r of t.iterate(s,e.reverse?"prev":"next")){if(e.limit&&a>=e.limit)return;yield[r.value.key,r.value.value],a++}}async*valuesAsync(e={}){for await(const[t,s]of this.entriesAsync(e))yield s}async*keysAsync(e={}){for await(const[t,s]of this.entriesAsync(e))yield v(this,Cs,Tl).call(this,t)}normalizeKey(e){return(Array.isArray(e)?e:[e]).join(",")}slot(e,t=0){return`map:${this.name}:slot:${this.normalizeKey(e)}:${t}`}}bn=new WeakMap,Zn=new WeakMap,Cs=new WeakSet,Tl=function(e){const t=e.split(",").map(s=>isNaN(parseInt(s))?s:parseInt(s));return t.length>1?t:e};class kp extends zr{async set(e,t){var c;if(!!await this.db.index("hash").get(IDBKeyRange.bound([this.container,this.normalizeKey(e),Re(t)],[this.container,this.normalizeKey(e),Re(t)])))return;const a=this.db.index("keyCount"),r=IDBKeyRange.upperBound([this.container,this.normalizeKey(e),Number.MAX_SAFE_INTEGER]),i=(await a.iterate(r,"prevunique").next()).value,o=((c=i==null?void 0:i.value)==null?void 0:c.keyCount)??0;await this.db.put({value:t,hash:Re(t),container:this.container,key:this.normalizeKey(e),keyCount:o+1,slot:this.slot(e,o)})}async*getValuesAsync(e){const t=this.db.index("keyCount"),s=IDBKeyRange.bound([this.container,this.normalizeKey(e),0],[this.container,this.normalizeKey(e),Number.MAX_SAFE_INTEGER],!1,!1);for await(const a of t.iterate(s))yield a.value.value}async deleteValue(e,t){const s=await this.db.index("hash").getKey(IDBKeyRange.bound([this.container,this.normalizeKey(e),Re(t)],[this.container,this.normalizeKey(e),Re(t)]));s&&await this.db.delete(s)}}class zp{constructor(e,t){l(this,"map");this.map=new zr(e,t)}set db(e){this.map.db=e}hasAsync(e){return this.map.hasAsync(e)}add(e){return this.map.set(e,!0)}delete(e){return this.map.delete(e)}async*entriesAsync(e={}){yield*this.map.keysAsync(e)}}var yn,Kn,Jn,at;class Np{constructor(e,t){w(this,yn);w(this,Kn);w(this,Jn);w(this,at);z(this,Kn,e),z(this,Jn,`singleton:${t}`),z(this,at,`singleton:${t}:value`)}set db(e){z(this,yn,e)}get db(){return u(this,yn)?u(this,yn):u(this,Kn).transaction("data","readwrite").store}async getAsync(){const e=await this.db.get(u(this,at));return e==null?void 0:e.value}async set(e){return await this.db.put({container:u(this,Jn),slot:u(this,at),key:u(this,at),keyCount:1,value:e,hash:Re(e)})!==void 0}async delete(){return await this.db.delete(u(this,at)),!0}}yn=new WeakMap,Kn=new WeakMap,Jn=new WeakMap,at=new WeakMap;var ye,Un,ve;const Er=class Er{constructor(e,t,s){l(this,"isEphemeral");w(this,ye);w(this,Un);w(this,ve);this.isEphemeral=t,z(this,ve,new Set),z(this,ye,e),z(this,Un,s)}static async open(e,t,s=!1){t=t&&!s?t:globalThis.crypto.getRandomValues(new Uint8Array(16)).join(""),e.debug(`Opening IndexedDB ${s?"temp ":""}database with name ${t}`);const a=await dp(t,1,{upgrade(i){const o=i.createObjectStore("data",{keyPath:"slot"});o.createIndex("key",["container","key"],{unique:!1}),o.createIndex("keyCount",["container","key","keyCount"],{unique:!0}),o.createIndex("hash",["container","key","hash"],{unique:!0})}});return new Er(a,s,t)}openMap(e){const t=new zr(u(this,ye),e);return u(this,ve).add(t),t}openSet(e){const t=new zp(u(this,ye),e);return u(this,ve).add(t),t}openMultiMap(e){const t=new kp(u(this,ye),e);return u(this,ve).add(t),t}openCounter(e){throw new Error("Method not implemented.")}openArray(e){const t=new Pp(u(this,ye),e);return u(this,ve).add(t),t}openSingleton(e){const t=new Np(u(this,ye),e);return u(this,ve).add(t),t}async transactionAsync(e){const t=u(this,ye).transaction("data","readwrite");for(const a of u(this,ve))a.db=t.store;const s=e();await t.done;for(const a of u(this,ve))a.db=void 0;return await s}async clear(){await u(this,ye).transaction("data","readwrite").store.clear()}delete(){return u(this,ve).clear(),u(this,ye).close(),up(u(this,Un))}estimateSize(){return Promise.resolve({mappingSize:0,physicalFileSize:0,actualSize:0,numItems:0})}close(){return Promise.resolve()}backupTo(e,t){throw new Error("Method not implemented.")}};ye=new WeakMap,Un=new WeakMap,ve=new WeakMap;let Ka=Er;async function Op(n,e,t=V("kv-store")){var r;let{dataDirectory:s}=e;typeof s<"u"&&(s=`${s}/${n}`),t.info(s?`Creating ${n} data store at directory ${s} with map size ${e.dataStoreMapSizeKB} KB`:`Creating ${n} ephemeral data store with map size ${e.dataStoreMapSizeKB} KB`);const a=await Ka.open(V("kv-store:indexeddb"),s??"",!1);return(r=e.l1Contracts)!=null&&r.rollupAddress?sp(a,e.l1Contracts.rollupAddress,t):a}async function Nn(n,e){const t=Ce[n],s=hd[n],a=await dn(e);return{instance:{...await xa(e,{salt:s}),address:t},contractClass:a,artifact:e,address:t}}let ta,na;async function Tp(){if(!na){const{default:n}=await p(async()=>{const{default:e}=await import("./AuthRegistry-Bu2fqBlU.js");return{default:e}},[]);na=Be(n)}return na}async function Ep(){if(!ta){const n=await Tp();ta=await Nn("AuthRegistry",n)}return ta}let sa,aa;async function Lp(){if(!aa){const{default:n}=await p(async()=>{const{default:e}=await import("./ContractClassRegisterer-cTYT4Kor.js");return{default:e}},[]);aa=Be(n)}return aa}async function Sp(){if(!sa){const n=await Lp();sa=await Nn("ContractClassRegisterer",n)}return sa}let ra,ia;async function Hp(){if(!ia){const{default:n}=await p(async()=>{const{default:e}=await import("./FeeJuice-CDfi_hKJ.js");return{default:e}},[]);ia=Be(n)}return ia}async function Xp(){if(!ra){const n=await Hp();ra=await Nn("FeeJuice",n)}return ra}let oa,la;async function Cp(){if(!la){const{default:n}=await p(async()=>{const{default:e}=await import("./ContractInstanceDeployer-B8aXJBbQ.js");return{default:e}},[]);la=Be(n)}return la}async function Dp(){if(!oa){const n=await Cp();oa=await Nn("ContractInstanceDeployer",n)}return oa}let ca,da;async function jp(){if(!da){const{default:n}=await p(async()=>{const{default:e}=await import("./MultiCallEntrypoint-DmLVp2vH.js");return{default:e}},[]);da=Be(n)}return da}async function Ip(){if(!ca){const n=await jp();ca=await Nn("MultiCallEntrypoint",n)}return ca}let ua,fa;async function Bp(){if(!fa){const{default:n}=await p(async()=>{const{default:e}=await import("./Router-X3L0RGHm.js");return{default:e}},[]);fa=Be(n)}return fa}async function Fp(){if(!ua){const n=await Bp();ua=await Nn("Router",n)}return ua}class qp{getProtocolContractArtifact(e){switch(e){case"AuthRegistry":return Ep();case"ContractInstanceDeployer":return Dp();case"ContractClassRegisterer":return Sp();case"MultiCallEntrypoint":return Ip();case"FeeJuice":return Xp();case"Router":return Fp();default:throw new Error(`Unknown protocol contract name: ${e}`)}}}async function Wp(n,e,t={loggers:{}}){const s=typeof t.useLogSuffix=="boolean"?t.useLogSuffix?ys(3).toString("hex"):void 0:t.useLogSuffix,a=await n.getL1ContractAddresses(),r={...e,l1Contracts:a},i=t.loggers??{},o=i.store?i.store:V("pxe:data:idb"+(s?`:${s}`:"")),c=t.store??await Op("pxe_data",r,o),d=new ff,_=i.prover?i.prover:V("pxe:bb:wasm:bundle"+(s?`:${s}`:"")),m=t.prover??new tp(d,16,_),h=new qp,g=i.pxe?i.pxe:V("pxe:service"+(s?`:${s}`:""));return await Ma.create(n,c,m,d,h,e,g)}const El=!0,Ll="1.0.0-beta.5+0000000000000000000000000000000000000000",Sl="SchnorrAccount",Hl=[{name:"constructor",is_unconstrained:!1,custom_attributes:["private","initializer"],abi:{parameters:[{name:"inputs",type:{kind:"struct",path:"aztec::context::inputs::private_context_inputs::PrivateContextInputs",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"historical_header",type:{kind:"struct",path:"authwit::aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"authwit::aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"authwit::aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]},visibility:"private"},{name:"signing_pub_key_x",type:{kind:"field"},visibility:"private"},{name:"signing_pub_key_y",type:{kind:"field"},visibility:"private"}],return_type:{abi_type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"min_revertible_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"is_fee_payer",type:{kind:"boolean"}},{name:"max_block_number",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",fields:[{name:"_opt",type:{kind:"struct",path:"std::option::Option",fields:[{name:"_is_some",type:{kind:"boolean"}},{name:"_value",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}},{name:"note_hash_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifier_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"key_validation_requests_and_generators",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",fields:[{name:"request",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",fields:[{name:"pk_m",type:{kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint",fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}]}},{name:"sk_app",type:{kind:"field"}}]}},{name:"sk_app_generator",type:{kind:"field"}}]}}},{name:"note_hashes",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::note_hash::NoteHash",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifiers",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::nullifier::Nullifier",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"note_hash",type:{kind:"field"}}]}}},{name:"private_call_requests",type:{kind:"array",length:5,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_call_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_teardown_call_request",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"l2_to_l1_msgs",type:{kind:"array",length:2,type:{kind:"struct",path:"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",fields:[{name:"recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"content",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"private_logs",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_log::PrivateLogData",fields:[{name:"log",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::log::Log",fields:[{name:"fields",type:{kind:"array",length:18,type:{kind:"field"}}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"note_hash_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"contract_class_logs_hashes",type:{kind:"array",length:1,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::log_hash::LogHash",fields:[{name:"value",type:{kind:"field"}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"historical_header",type:{kind:"struct",path:"authwit::aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"authwit::aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"authwit::aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}}]},visibility:"databus"},error_types:{"576755928210959028":{error_kind:"string",string:"0 has a square root; you cannot claim it is not square"},"2233873454491509486":{error_kind:"string",string:"Initializer address is not the contract deployer"},"2709101749560550278":{error_kind:"string",string:"Cannot serialize point at infinity as bytes."},"2896122431943215824":{error_kind:"fmtstring",length:144,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"2920182694213909827":{error_kind:"string",string:"attempt to subtract with overflow"},"3305101268118424981":{error_kind:"string",string:"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{error_kind:"fmtstring",length:58,item_types:[{kind:"field"}]},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"5727012404371710682":{error_kind:"string",string:"push out of bounds"},"5870202753060865374":{error_kind:"fmtstring",length:61,item_types:[{kind:"field"},{kind:"field"}]},"6336853191198150230":{error_kind:"fmtstring",length:77,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"6485997221020871071":{error_kind:"string",string:"call to assert_max_bit_size"},"6753155520859132764":{error_kind:"string",string:"Failed to deliver note"},"7233212735005103307":{error_kind:"string",string:"attempt to multiply with overflow"},"8270195893599566439":{error_kind:"string",string:"Invalid public keys hint for address"},"8830323656616886390":{error_kind:"string",string:"Got a public log emitted by a different contract"},"12822839658937144934":{error_kind:"fmtstring",length:75,item_types:[]},"13649294680379557736":{error_kind:"string",string:"extend_from_bounded_vec out of bounds"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"14514982005979867414":{error_kind:"string",string:"attempt to bit-shift with overflow"},"14657895983200220173":{error_kind:"string",string:"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{error_kind:"fmtstring",length:48,item_types:[{kind:"field"},{kind:"field"}]},"16218014537381711836":{error_kind:"string",string:"Value does not fit in field"},"16446004518090376065":{error_kind:"string",string:"Input length must be a multiple of 32"},"16954218183513903507":{error_kind:"string",string:"Attempted to read past end of BoundedVec"},"17618083556256589634":{error_kind:"string",string:"Initialization hash does not match"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"},"17879506016437779469":{error_kind:"fmtstring",length:128,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"18194595712952743247":{error_kind:"fmtstring",length:98,item_types:[{kind:"integer",sign:"unsigned",width:32},{kind:"integer",sign:"unsigned",width:32},{kind:"field"}]}}},bytecode:"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",debug_symbols:"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b3/OcAVLY21sjb3xbLzAp19dHLpHjQqf9e3Jp26c++lXGsdz+tXF1tgbz8YLfPrVxdR4NObGoXvUw/BZ355sjb3xbLzAp19dTI1HY27cdLXpatPVpqtNV5uuNV1rutZ0rela07Wma03Xmq41XWu63nS96XrT9abrTdebrjddb7redL3pzqY7m+5surPpzqY7m+5surPpzqY7m+5quqvpnn5lHhy6Hvl1+pVH3z796mJr7I1n41V81rcnU+PRmBtLY21sjb3xbNx0qelS06WmS02Xmi41XWq61HSp6Z5+NQ9POOvbk6nxaMyNpbE2tsbeeDZuutx0uely0+Wmy02Xmy43XW663HS56UrTlaYrTVearjRdabrSdKXpStOVpqtNV5uuNl1tutp0telq09Wmq01Xm641XWu61nSt6VrTtaZrTdearjVda7redL3petP1putN15uuN11vut50venOpjub7my6s+nOpjub7my6s+nOpjub7mq6q+muprua7mq6q+muprua7mq6C7pnfXsyNR6NubE01sbW2BvPxk2Xmi41XWq61HSp6VLTpaZLTZeabvMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMrbn7Fza+4+RU3v+LmV9z8iptfcfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v5LmV9L8SppfSfMraX4lza+k+ZU0v9LmV9r8SptfafMrbX6lza+0+dVZ367HvBuf9e26ODh0j/k1Puvbkw9dezyCR/AI5pP/9uc//V//+G9/+cf//td//j9/+m//+fzP//kf//JP//6Xf/2X6z///f/+3/n//Pd/+8tf//qX//UP//vf/vWf/vl//Me//fM//PVf/+n4//70OP7nkP275yiV8t8/f5nqR0P+PNbxo4Ef+Z95HD/i66//zp6z6H+253Ty38ef/p0bPf7sNubfxy/9nT9nHf7szymA4/8PIXtO5j7/J/4g/uL4sur5P3bElZJ6TpUMOn6kx4+OUM+BSZ4V5hkkDs5+/wvHj9afhxw/mnm8x9YAz5er6+ie87heIccR4BnhOq7nq+7zP/3461V//ZzIfT7GX3/9HHmzR/31c555nP8Zf230/M+zRR/558+RuT8/R6iuP3+OS/75OUaYAZ5DhM//nBngOdL35+eoXgSgnwYYOIHnOS7PP1nzz8+R2Drm538+Xy7iLxht6M9m+Pu//e1vf/+3/wc=",brillig_names:["get_contract_instance_internal","decompose_hint","lte_hint","discover_new_messages","notify_created_nullifier_oracle_wrapper","notify_created_note_oracle_wrapper","random","field_less_than","build_msg_block","attach_len_to_msg_block","get_random_bytes","get_random_bytes","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","directive_invert","directive_to_radix","directive_integer_quotient"],verification_key:"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"},{name:"entrypoint",is_unconstrained:!1,custom_attributes:["private","noinitcheck"],abi:{parameters:[{name:"inputs",type:{kind:"struct",path:"aztec::context::inputs::private_context_inputs::PrivateContextInputs",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"historical_header",type:{kind:"struct",path:"authwit::aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"authwit::aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"authwit::aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]},visibility:"private"},{name:"app_payload",type:{kind:"struct",path:"authwit::entrypoint::app::AppPayload",fields:[{name:"function_calls",type:{kind:"array",length:4,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}}]},visibility:"private"},{name:"fee_payload",type:{kind:"struct",path:"authwit::entrypoint::fee::FeePayload",fields:[{name:"function_calls",type:{kind:"array",length:2,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}},{name:"is_fee_payer",type:{kind:"boolean"}}]},visibility:"private"},{name:"cancellable",type:{kind:"boolean"},visibility:"private"}],return_type:{abi_type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"min_revertible_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"is_fee_payer",type:{kind:"boolean"}},{name:"max_block_number",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",fields:[{name:"_opt",type:{kind:"struct",path:"std::option::Option",fields:[{name:"_is_some",type:{kind:"boolean"}},{name:"_value",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}},{name:"note_hash_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifier_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"key_validation_requests_and_generators",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",fields:[{name:"request",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",fields:[{name:"pk_m",type:{kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint",fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}]}},{name:"sk_app",type:{kind:"field"}}]}},{name:"sk_app_generator",type:{kind:"field"}}]}}},{name:"note_hashes",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::note_hash::NoteHash",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifiers",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::nullifier::Nullifier",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"note_hash",type:{kind:"field"}}]}}},{name:"private_call_requests",type:{kind:"array",length:5,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_call_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_teardown_call_request",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"l2_to_l1_msgs",type:{kind:"array",length:2,type:{kind:"struct",path:"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",fields:[{name:"recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"content",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"private_logs",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_log::PrivateLogData",fields:[{name:"log",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::log::Log",fields:[{name:"fields",type:{kind:"array",length:18,type:{kind:"field"}}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"note_hash_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"contract_class_logs_hashes",type:{kind:"array",length:1,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::log_hash::LogHash",fields:[{name:"value",type:{kind:"field"}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"historical_header",type:{kind:"struct",path:"authwit::aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"authwit::aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"authwit::aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}}]},visibility:"databus"},error_types:{"576755928210959028":{error_kind:"string",string:"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{error_kind:"string",string:"Cannot serialize point at infinity as bytes."},"2896122431943215824":{error_kind:"fmtstring",length:144,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"2920182694213909827":{error_kind:"string",string:"attempt to subtract with overflow"},"3305101268118424981":{error_kind:"string",string:"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{error_kind:"fmtstring",length:58,item_types:[{kind:"field"}]},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"5727012404371710682":{error_kind:"string",string:"push out of bounds"},"5870202753060865374":{error_kind:"fmtstring",length:61,item_types:[{kind:"field"},{kind:"field"}]},"6336853191198150230":{error_kind:"fmtstring",length:77,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"6485997221020871071":{error_kind:"string",string:"call to assert_max_bit_size"},"6753155520859132764":{error_kind:"string",string:"Failed to deliver note"},"7233212735005103307":{error_kind:"string",string:"attempt to multiply with overflow"},"8270195893599566439":{error_kind:"string",string:"Invalid public keys hint for address"},"8830323656616886390":{error_kind:"string",string:"Got a public log emitted by a different contract"},"11091894166229312484":{error_kind:"fmtstring",length:20,item_types:[]},"12822839658937144934":{error_kind:"fmtstring",length:75,item_types:[]},"13649294680379557736":{error_kind:"string",string:"extend_from_bounded_vec out of bounds"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"14514982005979867414":{error_kind:"string",string:"attempt to bit-shift with overflow"},"14657895983200220173":{error_kind:"string",string:"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{error_kind:"fmtstring",length:48,item_types:[{kind:"field"},{kind:"field"}]},"16218014537381711836":{error_kind:"string",string:"Value does not fit in field"},"16446004518090376065":{error_kind:"string",string:"Input length must be a multiple of 32"},"16954218183513903507":{error_kind:"string",string:"Attempted to read past end of BoundedVec"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"},"17879506016437779469":{error_kind:"fmtstring",length:128,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"18194595712952743247":{error_kind:"fmtstring",length:98,item_types:[{kind:"integer",sign:"unsigned",width:32},{kind:"integer",sign:"unsigned",width:32},{kind:"field"}]},"18313900523101689315":{error_kind:"string",string:"Note contract address mismatch."}}},bytecode:"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",debug_symbols:"vf3druRMdp0L30sf90FGzN/wrRiGIWtrGwIakiHLBj4YuvcvOcmYY9QqL1auXKv3iepR9VvzSTI5RzKCQfL//OX/+af/9r/++3/953/5f//1f/7lP/3n//OX//Zv//y3v/3zf/+vf/vXf/yHf//nf/2X59/+n788jv8zpv7lP42/Pv+060+//ozrz7z+XOef8rj+HNef8/pTrj+venLVk6ueXPXkqidXPb3q6VVPr3p61dOrnl719KqnVz296ulVz656dtWzq55d9eyqZ1c9u+rZVc+uenbV86ueX/X8qudXPb/q+VXPr3p+1fOrnl/14qoXV7246sVVL656cdWLq15c9eKqF1e9vOrlVS+vennVy6teXvXyWW8ef8b1Z15/rvPP9bj+HNefz3p2/PmsF8efev1p159+/RnXn3n9uerP+Xhcf47rz3n9Kdefx+ebB9gG3xAbcsO6YDw2jA1zg2zYlceuPHblsSuPXXnsynNXnrvy3JXnrjx35bkrz1157spzV567suzKsitX79gBskE32AbfEBtyw7qgeqhgbNiVdVfWXVl3Zd2VdVfWXVl3ZduVbVe2Xdl2ZduVbVe2Xdl2ZduVbVf2Xdl3Zd+VfVf2Xdl3Zd+VfVf2Xdl35diVY1eOXTl25diVY1eOXTl25diVY1fOXTl35dyVc1fOXTl35dyVc1fOXTl35bUrr1356LuRB8gG3WAbfENsyA3rBDn674SxYW6QDbrBNhwpMQ+IDblhXXD04Aljw9wgG3SDbdiVx648duWxKx89OO2AsWFukA26wTb4htiQG9YFsivLriy7suzKRw/OdYBt8A2xITesC44ePGFsmBtkw66su7Luyror666su7LtyrYr265su7LtyrYr265su7LtyrYr+67su7Lvyr4r+67su7Lvyr4r+67su3LsyrErx64cu3LsyrErx64cu3LsyrEr566cu3Luyrkr566cu3Luyrkr566cu/LaldeuvHbltSuvXXntymtXXrvy2pXXVVkfjw1jw9wgG3SDbfANsSE37MpjVx678tiVx648duWxK49deezKY1ceu/LcleeuPHfluSvPXXnuynNXnrvy3JXnriy7suzKsivLrrx7UHcP6u5BPXpQxgG5YV1w9OAJY8PcIBt0g23wDbuy7sq6K9uubLuy7cq2K9uubLuy7cq2K9uubLuy78q+K/uu7Luy78q+K/uu7Luy78q+K8euHLty7MqxK8euHLty7MqxK8euHLty7sq5K+eunLty7sq5K+eunLty7sq5K69dee3Ka1deu/LaldeuvHbltSuvXXldle3x2DA2zA2yQTfYBt8QG3LDrjx25bErj1157MpjVx678tiVx648duWxK89dee7Kc1eeu/LcleeuPHfluSvPXXnuyrIry64su7LsyrIry64su/LuQds9aLsHbfeg7R603YO2e9B2D9ruQds9aLsHbfeg7R603YO2e9B2D9ruQds9aLsHbfeg7R603YO2e9B2D9ruQds9aLsHrXrQDrANviE25IZ1QfVgwdgwN8iGXTl25diVY1c+elDnAeuCowdPGBvmBtmgG2yDb4gNu3LuymtXXrvy2pXXrrx25bUrr1157cprV15XZT96UPWAsWFukA26wTb4htiQG9YFY1ceu/LYlceufPSg2gG2wTfEhtywLjh68ISxYW6QDbvy3JXnrjx35aMHNQ9YFxw9eMKzsj0OmBtkg26wDb4hNuSGdcHRgyfsyror666su/LRgyYH+IbYkBvWBUcPnjA2zA2yQTfsyrYr265su/LRg3Z8O0cPnjA2zA2yQTfYBt8QG3LDrhy7cuzKsSvHrhy7cuzKsSvHrhy7cuzKuSvnrpy7cu7KuSvnrpy7cu7KuSvnrrx25bUrr1157cprV1678tqV1668duV1VY7HY8PYMDfIBt1gG3xDbMgNu/LYlceuPHblsSuPXXnsymNXHrvy2JXHrjx35bkrz1157spzV5678tyV5648d+W5K8uuLLuy7MqyK8uuLLuy7MqyK8uuLLuy7sq6K+uurLuy7sq6K+uurLuy7sq6K9uubLuy7crVg36AbrANviE25IZ1QfVgwdgwN+zKviv7ruy7su/Kviv7rhy7cuzKsSvHrhy7cuzKsSvHrhy7cuzKuSvnrpy7cu7KuSvnrpy7cu7KuSvnrrx25bUrr1157cprV1678tqV1668duV1Vc7HY8PYMDfIBt1gG3xDbMgNu/LYlceuPHblsSuPXXnsymNXHrvy2JXHrjx35bkrz1157spzV5678tyV5648d+W5K8uuLLuy7MqyK8uuLLuy7MqyK8uuLLuy7sq6K+uurLuy7sq6K+uurLuy7sq6K9uubLuy7cq7B3P3YO4ezN2DuXswdw/m7sHc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",brillig_names:["discover_new_messages","get_note_internal","get_auth_witness","__get_quotient","__gt","decompose_hint","notify_enqueued_public_function_call_wrapper","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","notify_created_nullifier_oracle_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"],verification_key:"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"},{name:"lookup_validity",is_unconstrained:!0,custom_attributes:["utility"],abi:{parameters:[{name:"consumer",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]},visibility:"private"},{name:"inner_hash",type:{kind:"field"},visibility:"private"}],return_type:{abi_type:{kind:"boolean"},visibility:"public"},error_types:{"576755928210959028":{error_kind:"string",string:"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{error_kind:"string",string:"Cannot serialize point at infinity as bytes."},"2896122431943215824":{error_kind:"fmtstring",length:144,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"2920182694213909827":{error_kind:"string",string:"attempt to subtract with overflow"},"3305101268118424981":{error_kind:"string",string:"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{error_kind:"fmtstring",length:58,item_types:[{kind:"field"}]},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"5672954975036048158":{error_kind:"string",string:"Collapse hint vec length mismatch"},"5727012404371710682":{error_kind:"string",string:"push out of bounds"},"5870202753060865374":{error_kind:"fmtstring",length:61,item_types:[{kind:"field"},{kind:"field"}]},"6336853191198150230":{error_kind:"fmtstring",length:77,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"6485997221020871071":{error_kind:"string",string:"call to assert_max_bit_size"},"6753155520859132764":{error_kind:"string",string:"Failed to deliver note"},"7233212735005103307":{error_kind:"string",string:"attempt to multiply with overflow"},"7506220854563469239":{error_kind:"string",string:"Dirty collapsed vec storage"},"8270195893599566439":{error_kind:"string",string:"Invalid public keys hint for address"},"8830323656616886390":{error_kind:"string",string:"Got a public log emitted by a different contract"},"10583567252049806039":{error_kind:"string",string:"Wrong collapsed vec order"},"11499495063250795588":{error_kind:"string",string:"Wrong collapsed vec content"},"11553125913047385813":{error_kind:"string",string:"Wrong collapsed vec length"},"12822839658937144934":{error_kind:"fmtstring",length:75,item_types:[]},"13649294680379557736":{error_kind:"string",string:"extend_from_bounded_vec out of bounds"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"14514982005979867414":{error_kind:"string",string:"attempt to bit-shift with overflow"},"14657895983200220173":{error_kind:"string",string:"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{error_kind:"fmtstring",length:48,item_types:[{kind:"field"},{kind:"field"}]},"15431201120282223247":{error_kind:"string",string:"Out of bounds index hint"},"16218014537381711836":{error_kind:"string",string:"Value does not fit in field"},"16446004518090376065":{error_kind:"string",string:"Input length must be a multiple of 32"},"16954218183513903507":{error_kind:"string",string:"Attempted to read past end of BoundedVec"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"},"17879506016437779469":{error_kind:"fmtstring",length:128,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"18194595712952743247":{error_kind:"fmtstring",length:98,item_types:[{kind:"integer",sign:"unsigned",width:32},{kind:"integer",sign:"unsigned",width:32},{kind:"field"}]}}},bytecode:"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",debug_symbols:"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",brillig_names:["lookup_validity"]},{name:"sync_private_state",is_unconstrained:!0,custom_attributes:["utility"],abi:{parameters:[],return_type:null,error_types:{"576755928210959028":{error_kind:"string",string:"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{error_kind:"string",string:"Cannot serialize point at infinity as bytes."},"2896122431943215824":{error_kind:"fmtstring",length:144,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"2920182694213909827":{error_kind:"string",string:"attempt to subtract with overflow"},"3305101268118424981":{error_kind:"string",string:"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{error_kind:"fmtstring",length:58,item_types:[{kind:"field"}]},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"5727012404371710682":{error_kind:"string",string:"push out of bounds"},"5870202753060865374":{error_kind:"fmtstring",length:61,item_types:[{kind:"field"},{kind:"field"}]},"6336853191198150230":{error_kind:"fmtstring",length:77,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"6485997221020871071":{error_kind:"string",string:"call to assert_max_bit_size"},"6753155520859132764":{error_kind:"string",string:"Failed to deliver note"},"7233212735005103307":{error_kind:"string",string:"attempt to multiply with overflow"},"8270195893599566439":{error_kind:"string",string:"Invalid public keys hint for address"},"8830323656616886390":{error_kind:"string",string:"Got a public log emitted by a different contract"},"12822839658937144934":{error_kind:"fmtstring",length:75,item_types:[]},"13649294680379557736":{error_kind:"string",string:"extend_from_bounded_vec out of bounds"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"14514982005979867414":{error_kind:"string",string:"attempt to bit-shift with overflow"},"14657895983200220173":{error_kind:"string",string:"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{error_kind:"fmtstring",length:48,item_types:[{kind:"field"},{kind:"field"}]},"16218014537381711836":{error_kind:"string",string:"Value does not fit in field"},"16446004518090376065":{error_kind:"string",string:"Input length must be a multiple of 32"},"16954218183513903507":{error_kind:"string",string:"Attempted to read past end of BoundedVec"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"},"17879506016437779469":{error_kind:"fmtstring",length:128,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"18194595712952743247":{error_kind:"fmtstring",length:98,item_types:[{kind:"integer",sign:"unsigned",width:32},{kind:"integer",sign:"unsigned",width:32},{kind:"field"}]}}},bytecode:"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",debug_symbols:"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RjmOPJ8taBatpCPPL5KiVqRFvciKvKgcsxyzHKscqxyrHKscqxyrHKscqxyrHCsdManoIilqRVrUi6zIi0bRLCqHlEPKIeWQckg5pBxSDimHlEPK0crRytHK0crRytHK0crRytHK0cqh5dByaDm0HFoOLYeWQ8uh5dBy9HL0cvRy9HL0cvRy9HL0cvRy9HJYOawcVg4rh5XDymHlsHJYOawcXg4vh5fDy+Hl8HJ4ObwckecatJIiz0+SolakRb3IirxoFJVjlGOWY5ZjlmOWY5ZjlmOWY5ZjlmOWY5VjlWOVY5VjlWOVY5VjlWOVY6UjJi5dJEWtSIt6kRV50SiaReWQckg5pBxSDimHlEPKIeWQckg5WjlaOVo5WjlaOVo5WjlaOVo5Wjm0HFoOLYeWQ8uh5dByaDm0HFqOXo5ejl6OyPMR1Ius6O5Yt6BRNItW0pHnF0lRK9KiXmRF5bByWDmsHF4OL4eXw8vh5fByeDm8HF4OL8coxyjHKMcoxyjHKMcoxyjHKMcoxyzHLMcsxyzHLMcsxyzHLMcsxyzHKscqxyrHKscqxyrHKscqxyrHSkdMjrpIilqRFvUiK/KiUTSLyiHlkHJIOaQcUg4ph5RDyiHlkHK0crRytHK0crRytHK0crRytHK0cmg5tBxaDi2HlkPLoeXQcmg5tBy9HL0cvRy9HL0cvRyV51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V5155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",brillig_names:["sync_private_state"]},{name:"verify_private_authwit",is_unconstrained:!1,custom_attributes:["private","noinitcheck","view"],abi:{parameters:[{name:"inputs",type:{kind:"struct",path:"aztec::context::inputs::private_context_inputs::PrivateContextInputs",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"historical_header",type:{kind:"struct",path:"authwit::aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"authwit::aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"authwit::aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]},visibility:"private"},{name:"inner_hash",type:{kind:"field"},visibility:"private"}],return_type:{abi_type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"min_revertible_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"is_fee_payer",type:{kind:"boolean"}},{name:"max_block_number",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",fields:[{name:"_opt",type:{kind:"struct",path:"std::option::Option",fields:[{name:"_is_some",type:{kind:"boolean"}},{name:"_value",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}},{name:"note_hash_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifier_read_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::read_request::ReadRequest",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"key_validation_requests_and_generators",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",fields:[{name:"request",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",fields:[{name:"pk_m",type:{kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint",fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}]}},{name:"sk_app",type:{kind:"field"}}]}},{name:"sk_app_generator",type:{kind:"field"}}]}}},{name:"note_hashes",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::note_hash::NoteHash",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"nullifiers",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::nullifier::Nullifier",fields:[{name:"value",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"note_hash",type:{kind:"field"}}]}}},{name:"private_call_requests",type:{kind:"array",length:5,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",fields:[{name:"call_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::call_context::CallContext",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"is_static_call",type:{kind:"boolean"}}]}},{name:"args_hash",type:{kind:"field"}},{name:"returns_hash",type:{kind:"field"}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_call_requests",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"public_teardown_call_request",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",fields:[{name:"msg_sender",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"contract_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_static_call",type:{kind:"boolean"}},{name:"calldata_hash",type:{kind:"field"}}]}},{name:"l2_to_l1_msgs",type:{kind:"array",length:2,type:{kind:"struct",path:"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",fields:[{name:"recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"content",type:{kind:"field"}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"private_logs",type:{kind:"array",length:16,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::private_log::PrivateLogData",fields:[{name:"log",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::log::Log",fields:[{name:"fields",type:{kind:"array",length:18,type:{kind:"field"}}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"note_hash_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"contract_class_logs_hashes",type:{kind:"array",length:1,type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::side_effect::counted::Counted",fields:[{name:"inner",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::log_hash::LogHash",fields:[{name:"value",type:{kind:"field"}},{name:"length",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"counter",type:{kind:"integer",sign:"unsigned",width:32}}]}}},{name:"start_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"end_side_effect_counter",type:{kind:"integer",sign:"unsigned",width:32}},{name:"historical_header",type:{kind:"struct",path:"authwit::aztec::protocol_types::block_header::BlockHeader",fields:[{name:"last_archive",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"content_commitment",type:{kind:"struct",path:"authwit::aztec::protocol_types::content_commitment::ContentCommitment",fields:[{name:"num_txs",type:{kind:"field"}},{name:"blobs_hash",type:{kind:"field"}},{name:"in_hash",type:{kind:"field"}},{name:"out_hash",type:{kind:"field"}}]}},{name:"state",type:{kind:"struct",path:"authwit::aztec::protocol_types::state_reference::StateReference",fields:[{name:"l1_to_l2_message_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"partial",type:{kind:"struct",path:"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",fields:[{name:"note_hash_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"nullifier_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"public_data_tree",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",fields:[{name:"root",type:{kind:"field"}},{name:"next_available_leaf_index",type:{kind:"integer",sign:"unsigned",width:32}}]}}]}}]}},{name:"global_variables",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"block_number",type:{kind:"field"}},{name:"slot_number",type:{kind:"field"}},{name:"timestamp",type:{kind:"integer",sign:"unsigned",width:64}},{name:"coinbase",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::eth_address::EthAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"fee_recipient",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"gas_fees",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}},{name:"total_fees",type:{kind:"field"}},{name:"total_mana_used",type:{kind:"field"}}]}},{name:"tx_context",type:{kind:"struct",path:"authwit::aztec::protocol_types::transaction::tx_context::TxContext",fields:[{name:"chain_id",type:{kind:"field"}},{name:"version",type:{kind:"field"}},{name:"gas_settings",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_settings::GasSettings",fields:[{name:"gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"teardown_gas_limits",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas::Gas",fields:[{name:"da_gas",type:{kind:"integer",sign:"unsigned",width:32}},{name:"l2_gas",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"max_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}},{name:"max_priority_fees_per_gas",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::gas_fees::GasFees",fields:[{name:"fee_per_da_gas",type:{kind:"field"}},{name:"fee_per_l2_gas",type:{kind:"field"}}]}}]}}]}}]},visibility:"databus"},error_types:{"19458536156181958":{error_kind:"string",string:"Function verify_private_authwit can only be called statically"},"576755928210959028":{error_kind:"string",string:"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{error_kind:"string",string:"Cannot serialize point at infinity as bytes."},"2896122431943215824":{error_kind:"fmtstring",length:144,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"2920182694213909827":{error_kind:"string",string:"attempt to subtract with overflow"},"3305101268118424981":{error_kind:"string",string:"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{error_kind:"fmtstring",length:58,item_types:[{kind:"field"}]},"4939791462094160055":{error_kind:"string",string:"Message not authorized by account"},"5019202896831570965":{error_kind:"string",string:"attempt to add with overflow"},"5727012404371710682":{error_kind:"string",string:"push out of bounds"},"5870202753060865374":{error_kind:"fmtstring",length:61,item_types:[{kind:"field"},{kind:"field"}]},"6336853191198150230":{error_kind:"fmtstring",length:77,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"6485997221020871071":{error_kind:"string",string:"call to assert_max_bit_size"},"6753155520859132764":{error_kind:"string",string:"Failed to deliver note"},"7233212735005103307":{error_kind:"string",string:"attempt to multiply with overflow"},"8270195893599566439":{error_kind:"string",string:"Invalid public keys hint for address"},"8830323656616886390":{error_kind:"string",string:"Got a public log emitted by a different contract"},"11091894166229312484":{error_kind:"fmtstring",length:20,item_types:[]},"12822839658937144934":{error_kind:"fmtstring",length:75,item_types:[]},"13649294680379557736":{error_kind:"string",string:"extend_from_bounded_vec out of bounds"},"14225679739041873922":{error_kind:"string",string:"Index out of bounds"},"14514982005979867414":{error_kind:"string",string:"attempt to bit-shift with overflow"},"14657895983200220173":{error_kind:"string",string:"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{error_kind:"fmtstring",length:48,item_types:[{kind:"field"},{kind:"field"}]},"16218014537381711836":{error_kind:"string",string:"Value does not fit in field"},"16446004518090376065":{error_kind:"string",string:"Input length must be a multiple of 32"},"16954218183513903507":{error_kind:"string",string:"Attempted to read past end of BoundedVec"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"},"17879506016437779469":{error_kind:"fmtstring",length:128,item_types:[{kind:"integer",sign:"unsigned",width:32}]},"18194595712952743247":{error_kind:"fmtstring",length:98,item_types:[{kind:"integer",sign:"unsigned",width:32},{kind:"integer",sign:"unsigned",width:32},{kind:"field"}]},"18313900523101689315":{error_kind:"string",string:"Note contract address mismatch."}}},bytecode:"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",debug_symbols:"vf3fruTOcaYL34uOdVCR8SczfCuDgaHxaA8ECPJAtjfwwfC9f8UgI95Yq13ZXLWW9on78U/d8RRZjLfIZDL5n3/433/+X//xf/75L3/7f/713/7wT//jP//wv/7+l7/+9S//55//+q//8qd//8u//u35X//zD4/j/9CgP/wT/fH557j+5OtPuf7U60+7/pzXn+v6088/+XH9edXjqx5f9fiqx1c9vurxVY+venzVk6ueXPXkqidXPbnqyVVPrnpy1ZOrnlz19KqnVz296ulVT696etXTq55e9fSqp1c9u+rZVc+uenbVs6ueXfXsqmdXPbvq2VVvXvXmVW9e9eZVb1715lVvXvXmVW9e9eZVb1311lVvXfXWs944/pTrT73+tOvPef25rj+f9fT5pz/rzeNPuv4c1598/SnXn3r9adef8/pzXX96/Dkej+vP4/ONA0YCJ0iCJljCTFgJfgE9ErIyZWXKypSVKStTVqasTFmZsvLIyiMrj6w8svLIyiMrj6w8svLIytE7z507onkCKGEkcIIkaIIlzISVkJUlK0tWlqwsWVmysmRlycqSlSUrS1bWrKxZWbOyZmXNypqVNStrVtasrFnZsrJlZcvKlpUtK1tWtqxsWdmysmXlmZVnVp5ZeWblmZVnVp5ZeWblmZVnVl5ZeWXllZVXVl5ZeWXllZVXVl5Z+eg7Wk84Gu8EShgJnCAJmmAJM2ElXJX58UighJFwpMQ4QBI0wRJmwkrwC44ePIESRkJWpqxMWZmy8tGDQw9YCX7B0YMnUMJI4ARJ0ARLyMojK4+szFn56MHhB4wETpAETbCEmbAS/IKjB0/IypKVJStLVpasLFlZsrJkZcnKmpU1K2tW1qysWVmzsmZlzcqalTUrW1a2rGxZ2bKyZWXLypaVLStbVrasPLPyzMozK8+sPLPyzMozK8+sPLPyzMorK6+svLLyysorK6+svLLyysorK6+s7FnZs7JnZc/KnpU9K3tW9qzsWdmvyvJ4JFDCSOAESdAES5gJKyErU1amrExZmbIyZWXKypSVKStTVqasPLLyyMojK4+sPLLyyMojK4+sPLLyyMqclbMHJXtQsgfl6EGmAzTBEmbCSvALjh48gRJGAidkZcnKkpUlK0tWlqysWVmzsmZlzcqalTUra1bWrKxZWbOyZWXLypaVLStbVrasbFnZsrJlZcvK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ytr5lbXrQWvXg9auB61dD1q7HrR2PWgtr6zllbW8spZXs10PznZ+Ndv51WznV7OdX812PTjb9eBs14OzXQ/Odj042/XgbHk1W17Nllez5dVs14OznV/Ndn412/nVbOdXs10PznY9ONv14GzXg7NdD852PThbXs2WV7Pl1Wx5Ndv14GznV7OdX812fjXb+dVs14OzXQ/Odj042/XgbNeDs10PzpZXs+XVbHk1W17Ndj042/nVbOdXs51fzXZ+Ndv14GzXg7NdD852PTjb9eBs14Oz5dVseTVbXs2WV7NdD852fjXb+dVs51eznV/Ndj042/XgbNeDs10PznY9ONv14Gx5NVtezZZXs+XVbNeDs51fzXZ+Ndv51WznV7NdD852PTjb9eBs14OzXQ/Odj04W17Ndn412/nVbOdXs10PzpZXs+XVbHk12/nVbOdXs+XVbHk1r7yawV68rrzy4PAeC8DSOTU8mRtL4/AerzSjc3p4/vfZeDV28JlX57+l5qXmpeal5qXmpeal5qXmpeYdzTuadzTvaN7RvKN5R/OO5h3NO5qXm5ebl5uXm5ebl5uXm5ebl5uXm1eaV5pXmleaV5pXmleaV5pXmleaV5tXm1ebV5tXm1ebV5tXm1ebV5vXmtea15rXmtea15rXmtea15rXmnc272ze2byzeWfzzuadzTubdzbvbN7VvKt5V/Ou5l3Nu5p3Ne9q3tW8q3m9eb15vXm9eb15vXm9eb15vXkd3nPy+flvveWVt7zyllfe8spbXnnLK2955S2vvOWVt7zyllfe8spbXnnLK2955S2vvOWVt7zyllfe8spbXnnLK2955S2vvOWVt7zyllfe8spbXnnLK2955S2vvOWVt7zyllfe8spbXnnLK2955S2vvOWVt7zyllfe8spbXnnLK2955S2vvOWVt7zyllfe8spbXnnLK2955S2vvOWVt7zyllfe8sqvvDr59EowN5bGp/dY+vf//dPf//Kn//XXP//bH/7pP481eP/jb/+S6+0+/99////93/xf/tff//LXv/7l//zz//37v/7Ln//3f/z9z8favMf/9ofH9X/+x/P6avzxeTHF//Mpef7/83gj/PPkcj3/fz7+/+Nlws+LmMfxvx//4DkoLn98/h8//kP8i4fR828YHwsAU9Z93pv64/MezVXleUftj8+7W1njeaPuj88bblnheX3+x+e1+PHvx/Hvj3/xPElhL+fjj6LH/8yxpPDxnyb/ca7jP0n9J/I/Djn+k9Z/ep4+DT/+k2Xd5xchI+sq/VHtf/7XsXbx/x8=",brillig_names:["discover_new_messages","get_note_internal","get_auth_witness","__get_quotient","__gt","decompose_hint","store_in_execution_cache_oracle_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"],verification_key:"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"},{name:"public_dispatch",is_unconstrained:!0,custom_attributes:["public"],abi:{parameters:[{name:"selector",type:{kind:"field"},visibility:"private"}],return_type:null,error_types:{"1752556835457866331":{error_kind:"string",string:"No public functions"}}},bytecode:"JwAABAEqAAABBRhSVSgKJhpbPAAAAQ==",debug_symbols:"XY1bCoAgEEX3Mt+toK1EiI9RBkRl0iDEvWeRIH3ee+6jgkFVnKBg4wHrVkExeU9O+Khlphi6W9sCQ4rMiN2CiW97D0hN/C+dkkkqj5+0JeiJ5isNMk4TR42mMD5LL2t7uwE=",brillig_names:["public_dispatch"]}],Xl={globals:{notes:[{fields:[{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000000"},{kind:"string",value:"PublicKeyNote"},{fields:[{name:"x",value:{fields:[{name:"index",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000000"}},{name:"nullable",value:{kind:"boolean",value:!1}}],kind:"struct"}},{name:"y",value:{fields:[{name:"index",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000001"}},{name:"nullable",value:{kind:"boolean",value:!1}}],kind:"struct"}},{name:"owner",value:{fields:[{name:"index",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000002"}},{name:"nullable",value:{kind:"boolean",value:!1}}],kind:"struct"}}],kind:"struct"}],kind:"tuple"}],storage:[{fields:[{name:"contract_name",value:{kind:"string",value:"SchnorrAccount"}},{name:"fields",value:{fields:[{name:"signing_public_key",value:{fields:[{name:"slot",value:{kind:"integer",sign:!1,value:"0000000000000000000000000000000000000000000000000000000000000001"}}],kind:"struct"}}],kind:"struct"}}],kind:"struct"}]},structs:{functions:[{fields:[{name:"parameters",type:{fields:[{name:"signing_pub_key_x",type:{kind:"field"}},{name:"signing_pub_key_y",type:{kind:"field"}}],kind:"struct",path:"SchnorrAccount::constructor_parameters"}}],kind:"struct",path:"SchnorrAccount::constructor_abi"},{fields:[{name:"parameters",type:{fields:[{name:"app_payload",type:{fields:[{name:"function_calls",type:{kind:"array",length:4,type:{fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}],kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{name:"target_address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}],kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall"}}},{name:"nonce",type:{kind:"field"}}],kind:"struct",path:"authwit::entrypoint::app::AppPayload"}},{name:"fee_payload",type:{fields:[{name:"function_calls",type:{kind:"array",length:2,type:{fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}],kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{name:"target_address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}],kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall"}}},{name:"nonce",type:{kind:"field"}},{name:"is_fee_payer",type:{kind:"boolean"}}],kind:"struct",path:"authwit::entrypoint::fee::FeePayload"}},{name:"cancellable",type:{kind:"boolean"}}],kind:"struct",path:"SchnorrAccount::entrypoint_parameters"}}],kind:"struct",path:"SchnorrAccount::entrypoint_abi"},{fields:[{name:"parameters",type:{fields:[{name:"consumer",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{name:"inner_hash",type:{kind:"field"}}],kind:"struct",path:"SchnorrAccount::lookup_validity_parameters"}},{name:"return_type",type:{kind:"boolean"}}],kind:"struct",path:"SchnorrAccount::lookup_validity_abi"},{fields:[{name:"parameters",type:{fields:[],kind:"struct",path:"SchnorrAccount::sync_private_state_parameters"}}],kind:"struct",path:"SchnorrAccount::sync_private_state_abi"},{fields:[{name:"parameters",type:{fields:[{name:"inner_hash",type:{kind:"field"}}],kind:"struct",path:"SchnorrAccount::verify_private_authwit_parameters"}},{name:"return_type",type:{kind:"field"}}],kind:"struct",path:"SchnorrAccount::verify_private_authwit_abi"}]}},Cl={5:{path:"std/cmp.nr",source:`use crate::meta::derive_via;

#[derive_via(derive_eq)]
// docs:start:eq-trait
pub trait Eq {
    fn eq(self, other: Self) -> bool;
}
// docs:end:eq-trait

// docs:start:derive_eq
comptime fn derive_eq(s: TypeDefinition) -> Quoted {
    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };
    let for_each_field = |name| quote { (_self.$name == _other.$name) };
    let body = |fields| {
        if s.fields_as_written().len() == 0 {
            quote { true }
        } else {
            fields
        }
    };
    crate::meta::make_trait_impl(
        s,
        quote { Eq },
        signature,
        for_each_field,
        quote { & },
        body,
    )
}
// docs:end:derive_eq

impl Eq for Field {
    fn eq(self, other: Field) -> bool {
        self == other
    }
}

impl Eq for u128 {
    fn eq(self, other: u128) -> bool {
        self == other
    }
}
impl Eq for u64 {
    fn eq(self, other: u64) -> bool {
        self == other
    }
}
impl Eq for u32 {
    fn eq(self, other: u32) -> bool {
        self == other
    }
}
impl Eq for u16 {
    fn eq(self, other: u16) -> bool {
        self == other
    }
}
impl Eq for u8 {
    fn eq(self, other: u8) -> bool {
        self == other
    }
}
impl Eq for u1 {
    fn eq(self, other: u1) -> bool {
        self == other
    }
}

impl Eq for i8 {
    fn eq(self, other: i8) -> bool {
        self == other
    }
}
impl Eq for i16 {
    fn eq(self, other: i16) -> bool {
        self == other
    }
}
impl Eq for i32 {
    fn eq(self, other: i32) -> bool {
        self == other
    }
}
impl Eq for i64 {
    fn eq(self, other: i64) -> bool {
        self == other
    }
}

impl Eq for () {
    fn eq(_self: Self, _other: ()) -> bool {
        true
    }
}
impl Eq for bool {
    fn eq(self, other: bool) -> bool {
        self == other
    }
}

impl<T, let N: u32> Eq for [T; N]
where
    T: Eq,
{
    fn eq(self, other: [T; N]) -> bool {
        let mut result = true;
        for i in 0..self.len() {
            result &= self[i].eq(other[i]);
        }
        result
    }
}

impl<T> Eq for [T]
where
    T: Eq,
{
    fn eq(self, other: [T]) -> bool {
        let mut result = self.len() == other.len();
        for i in 0..self.len() {
            result &= self[i].eq(other[i]);
        }
        result
    }
}

impl<let N: u32> Eq for str<N> {
    fn eq(self, other: str<N>) -> bool {
        let self_bytes = self.as_bytes();
        let other_bytes = other.as_bytes();
        self_bytes == other_bytes
    }
}

impl<A, B> Eq for (A, B)
where
    A: Eq,
    B: Eq,
{
    fn eq(self, other: (A, B)) -> bool {
        self.0.eq(other.0) & self.1.eq(other.1)
    }
}

impl<A, B, C> Eq for (A, B, C)
where
    A: Eq,
    B: Eq,
    C: Eq,
{
    fn eq(self, other: (A, B, C)) -> bool {
        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)
    }
}

impl<A, B, C, D> Eq for (A, B, C, D)
where
    A: Eq,
    B: Eq,
    C: Eq,
    D: Eq,
{
    fn eq(self, other: (A, B, C, D)) -> bool {
        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)
    }
}

impl<A, B, C, D, E> Eq for (A, B, C, D, E)
where
    A: Eq,
    B: Eq,
    C: Eq,
    D: Eq,
    E: Eq,
{
    fn eq(self, other: (A, B, C, D, E)) -> bool {
        self.0.eq(other.0)
            & self.1.eq(other.1)
            & self.2.eq(other.2)
            & self.3.eq(other.3)
            & self.4.eq(other.4)
    }
}

impl Eq for Ordering {
    fn eq(self, other: Ordering) -> bool {
        self.result == other.result
    }
}

// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct
// that has 3 public functions for constructing the struct.
pub struct Ordering {
    result: Field,
}

impl Ordering {
    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built
    // into the compiler, do not change these without also updating
    // the compiler itself!
    pub fn less() -> Ordering {
        Ordering { result: 0 }
    }

    pub fn equal() -> Ordering {
        Ordering { result: 1 }
    }

    pub fn greater() -> Ordering {
        Ordering { result: 2 }
    }
}

#[derive_via(derive_ord)]
// docs:start:ord-trait
pub trait Ord {
    fn cmp(self, other: Self) -> Ordering;
}
// docs:end:ord-trait

// docs:start:derive_ord
comptime fn derive_ord(s: TypeDefinition) -> Quoted {
    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };
    let for_each_field = |name| quote {
        if result == std::cmp::Ordering::equal() {
            result = _self.$name.cmp(_other.$name);
        }
    };
    let body = |fields| quote {
        let mut result = std::cmp::Ordering::equal();
        $fields
        result
    };
    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)
}
// docs:end:derive_ord

// Note: Field deliberately does not implement Ord

impl Ord for u128 {
    fn cmp(self, other: u128) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}
impl Ord for u64 {
    fn cmp(self, other: u64) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}

impl Ord for u32 {
    fn cmp(self, other: u32) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}

impl Ord for u16 {
    fn cmp(self, other: u16) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}

impl Ord for u8 {
    fn cmp(self, other: u8) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}

impl Ord for i8 {
    fn cmp(self, other: i8) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}

impl Ord for i16 {
    fn cmp(self, other: i16) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}

impl Ord for i32 {
    fn cmp(self, other: i32) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}

impl Ord for i64 {
    fn cmp(self, other: i64) -> Ordering {
        if self < other {
            Ordering::less()
        } else if self > other {
            Ordering::greater()
        } else {
            Ordering::equal()
        }
    }
}

impl Ord for () {
    fn cmp(_self: Self, _other: ()) -> Ordering {
        Ordering::equal()
    }
}

impl Ord for bool {
    fn cmp(self, other: bool) -> Ordering {
        if self {
            if other {
                Ordering::equal()
            } else {
                Ordering::greater()
            }
        } else if other {
            Ordering::less()
        } else {
            Ordering::equal()
        }
    }
}

impl<T, let N: u32> Ord for [T; N]
where
    T: Ord,
{
    // The first non-equal element of both arrays determines
    // the ordering for the whole array.
    fn cmp(self, other: [T; N]) -> Ordering {
        let mut result = Ordering::equal();
        for i in 0..self.len() {
            if result == Ordering::equal() {
                result = self[i].cmp(other[i]);
            }
        }
        result
    }
}

impl<T> Ord for [T]
where
    T: Ord,
{
    // The first non-equal element of both arrays determines
    // the ordering for the whole array.
    fn cmp(self, other: [T]) -> Ordering {
        let mut result = self.len().cmp(other.len());
        for i in 0..self.len() {
            if result == Ordering::equal() {
                result = self[i].cmp(other[i]);
            }
        }
        result
    }
}

impl<A, B> Ord for (A, B)
where
    A: Ord,
    B: Ord,
{
    fn cmp(self, other: (A, B)) -> Ordering {
        let result = self.0.cmp(other.0);

        if result != Ordering::equal() {
            result
        } else {
            self.1.cmp(other.1)
        }
    }
}

impl<A, B, C> Ord for (A, B, C)
where
    A: Ord,
    B: Ord,
    C: Ord,
{
    fn cmp(self, other: (A, B, C)) -> Ordering {
        let mut result = self.0.cmp(other.0);

        if result == Ordering::equal() {
            result = self.1.cmp(other.1);
        }

        if result == Ordering::equal() {
            result = self.2.cmp(other.2);
        }

        result
    }
}

impl<A, B, C, D> Ord for (A, B, C, D)
where
    A: Ord,
    B: Ord,
    C: Ord,
    D: Ord,
{
    fn cmp(self, other: (A, B, C, D)) -> Ordering {
        let mut result = self.0.cmp(other.0);

        if result == Ordering::equal() {
            result = self.1.cmp(other.1);
        }

        if result == Ordering::equal() {
            result = self.2.cmp(other.2);
        }

        if result == Ordering::equal() {
            result = self.3.cmp(other.3);
        }

        result
    }
}

impl<A, B, C, D, E> Ord for (A, B, C, D, E)
where
    A: Ord,
    B: Ord,
    C: Ord,
    D: Ord,
    E: Ord,
{
    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {
        let mut result = self.0.cmp(other.0);

        if result == Ordering::equal() {
            result = self.1.cmp(other.1);
        }

        if result == Ordering::equal() {
            result = self.2.cmp(other.2);
        }

        if result == Ordering::equal() {
            result = self.3.cmp(other.3);
        }

        if result == Ordering::equal() {
            result = self.4.cmp(other.4);
        }

        result
    }
}

// Compares and returns the maximum of two values.
//
// Returns the second argument if the comparison determines them to be equal.
//
// # Examples
//
// \`\`\`
// use std::cmp;
//
// assert_eq(cmp::max(1, 2), 2);
// assert_eq(cmp::max(2, 2), 2);
// \`\`\`
pub fn max<T>(v1: T, v2: T) -> T
where
    T: Ord,
{
    if v1 > v2 {
        v1
    } else {
        v2
    }
}

// Compares and returns the minimum of two values.
//
// Returns the first argument if the comparison determines them to be equal.
//
// # Examples
//
// \`\`\`
// use std::cmp;
//
// assert_eq(cmp::min(1, 2), 1);
// assert_eq(cmp::min(2, 2), 2);
// \`\`\`
pub fn min<T>(v1: T, v2: T) -> T
where
    T: Ord,
{
    if v1 > v2 {
        v2
    } else {
        v1
    }
}

mod cmp_tests {
    use crate::cmp::{max, min};

    #[test]
    fn sanity_check_min() {
        assert_eq(min(0 as u64, 1 as u64), 0);
        assert_eq(min(0 as u64, 0 as u64), 0);
        assert_eq(min(1 as u64, 1 as u64), 1);
        assert_eq(min(255 as u8, 0 as u8), 0);
    }

    #[test]
    fn sanity_check_max() {
        assert_eq(max(0 as u64, 1 as u64), 1);
        assert_eq(max(0 as u64, 0 as u64), 0);
        assert_eq(max(1 as u64, 1 as u64), 1);
        assert_eq(max(255 as u8, 0 as u8), 255);
    }
}
`},6:{path:"std/collections/bounded_vec.nr",source:`use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};

/// A \`BoundedVec<T, MaxLen>\` is a growable storage similar to a \`Vec<T>\` except that it
/// is bounded with a maximum possible length. Unlike \`Vec\`, \`BoundedVec\` is not implemented
/// via slices and thus is not subject to the same restrictions slices are (notably, nested
/// slices - and thus nested vectors as well - are disallowed).
///
/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by
/// pushing an additional element is also more efficient - the length only needs to be increased
/// by one.
///
/// For these reasons \`BoundedVec<T, N>\` should generally be preferred over \`Vec<T>\` when there
/// is a reasonable maximum bound that can be placed on the vector.
///
/// Example:
///
/// \`\`\`noir
/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();
/// for i in 0..5 {
///     vector.push(i);
/// }
/// assert(vector.len() == 5);
/// assert(vector.max_len() == 10);
/// \`\`\`
pub struct BoundedVec<T, let MaxLen: u32> {
    storage: [T; MaxLen],
    len: u32,
}

impl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {
    /// Creates a new, empty vector of length zero.
    ///
    /// Since this container is backed by an array internally, it still needs an initial value
    /// to give each element. To resolve this, each element is zeroed internally. This value
    /// is guaranteed to be inaccessible unless \`get_unchecked\` is used.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();
    /// assert(empty_vector.len() == 0);
    /// \`\`\`
    ///
    /// Note that whenever calling \`new\` the maximum length of the vector should always be specified
    /// via a type signature:
    ///
    /// \`\`\`noir
    /// fn good() -> BoundedVec<Field, 10> {
    ///     // Ok! MaxLen is specified with a type annotation
    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();
    ///     let v2 = BoundedVec::new();
    ///
    ///     // Ok! MaxLen is known from the type of \`good\`'s return value
    ///     v2
    /// }
    ///
    /// fn bad() {
    ///     // Error: Type annotation needed
    ///     // The compiler can't infer \`MaxLen\` from the following code:
    ///     let mut v3 = BoundedVec::new();
    ///     v3.push(5);
    /// }
    /// \`\`\`
    ///
    /// This defaulting of \`MaxLen\` (and numeric generics in general) to zero may change in future noir versions
    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a
    /// constraint failure at runtime when the vec is pushed to.
    pub fn new() -> Self {
        let zeroed = crate::mem::zeroed();
        BoundedVec { storage: [zeroed; MaxLen], len: 0 }
    }

    /// Retrieves an element from the vector at the given index, starting from zero.
    ///
    /// If the given index is equal to or greater than the length of the vector, this
    /// will issue a constraint failure.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {
    ///     let first = v.get(0);
    ///     let last = v.get(v.len() - 1);
    ///     assert(first != last);
    /// }
    /// \`\`\`
    pub fn get(self, index: u32) -> T {
        assert(index < self.len, "Attempted to read past end of BoundedVec");
        self.get_unchecked(index)
    }

    /// Retrieves an element from the vector at the given index, starting from zero, without
    /// performing a bounds check.
    ///
    /// Since this function does not perform a bounds check on length before accessing the element,
    /// it is unsafe! Use at your own risk!
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {
    ///     // Always ensure the length is larger than the largest
    ///     // index passed to get_unchecked
    ///     assert(v.len() > 2);
    ///     let first = v.get_unchecked(0);
    ///     let second = v.get_unchecked(1);
    ///     let third = v.get_unchecked(2);
    ///     first + second + third
    /// }
    /// \`\`\`
    pub fn get_unchecked(self, index: u32) -> T {
        self.storage[index]
    }

    /// Writes an element to the vector at the given index, starting from zero.
    ///
    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {
    ///     let first = v.get(0);
    ///     assert(first != 42);
    ///     v.set(0, 42);
    ///     let new_first = v.get(0);
    ///     assert(new_first == 42);
    /// }
    /// \`\`\`
    pub fn set(&mut self, index: u32, value: T) {
        assert(index < self.len, "Attempted to write past end of BoundedVec");
        self.set_unchecked(index, value)
    }

    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.
    ///
    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// fn set_unchecked_example() {
    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();
    ///     vec.extend_from_array([1, 2]);
    ///
    ///     // Here we're safely writing within the valid range of \`vec\`
    ///     // \`vec\` now has the value [42, 2]
    ///     vec.set_unchecked(0, 42);
    ///
    ///     // We can then safely read this value back out of \`vec\`.
    ///     // Notice that we use the checked version of \`get\` which would prevent reading unsafe values.
    ///     assert_eq(vec.get(0), 42);
    ///
    ///     // We've now written past the end of \`vec\`.
    ///     // As this index is still within the maximum potential length of \`v\`,
    ///     // it won't cause a constraint failure.
    ///     vec.set_unchecked(2, 42);
    ///     println(vec);
    ///
    ///     // This will write past the end of the maximum potential length of \`vec\`,
    ///     // it will then trigger a constraint failure.
    ///     vec.set_unchecked(5, 42);
    ///     println(vec);
    /// }
    /// \`\`\`
    pub fn set_unchecked(&mut self, index: u32, value: T) {
        self.storage[index] = value;
    }

    /// Pushes an element to the end of the vector. This increases the length
    /// of the vector by one.
    ///
    /// Panics if the new length of the vector will be greater than the max length.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();
    ///
    /// v.push(1);
    /// v.push(2);
    ///
    /// // Panics with failed assertion "push out of bounds"
    /// v.push(3);
    /// \`\`\`
    pub fn push(&mut self, elem: T) {
        assert(self.len < MaxLen, "push out of bounds");

        self.storage[self.len] = elem;
        self.len += 1;
    }

    /// Returns the current length of this vector
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();
    /// assert(v.len() == 0);
    ///
    /// v.push(100);
    /// assert(v.len() == 1);
    ///
    /// v.push(200);
    /// v.push(300);
    /// v.push(400);
    /// assert(v.len() == 4);
    ///
    /// let _ = v.pop();
    /// let _ = v.pop();
    /// assert(v.len() == 2);
    /// \`\`\`
    pub fn len(self) -> u32 {
        self.len
    }

    /// Returns the maximum length of this vector. This is always
    /// equal to the \`MaxLen\` parameter this vector was initialized with.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();
    ///
    /// assert(v.max_len() == 5);
    /// v.push(10);
    /// assert(v.max_len() == 5);
    /// \`\`\`
    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {
        MaxLen
    }

    /// Returns the internal array within this vector.
    ///
    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate
    /// the storage held internally by this vector.
    ///
    /// Note that uninitialized elements may be zeroed out!
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();
    ///
    /// assert(v.storage() == [0, 0, 0, 0, 0]);
    ///
    /// v.push(57);
    /// assert(v.storage() == [57, 0, 0, 0, 0]);
    /// \`\`\`
    pub fn storage(self) -> [T; MaxLen] {
        self.storage
    }

    /// Pushes each element from the given array to this vector.
    ///
    /// Panics if pushing each element would cause the length of this vector
    /// to exceed the maximum length.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();
    /// vec.extend_from_array([2, 4]);
    ///
    /// assert(vec.len == 2);
    /// assert(vec.get(0) == 2);
    /// assert(vec.get(1) == 4);
    /// \`\`\`
    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {
        let new_len = self.len + array.len();
        assert(new_len <= MaxLen, "extend_from_array out of bounds");
        for i in 0..array.len() {
            self.storage[self.len + i] = array[i];
        }
        self.len = new_len;
    }

    /// Pushes each element from the given slice to this vector.
    ///
    /// Panics if pushing each element would cause the length of this vector
    /// to exceed the maximum length.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();
    /// vec.extend_from_slice(&[2, 4]);
    ///
    /// assert(vec.len == 2);
    /// assert(vec.get(0) == 2);
    /// assert(vec.get(1) == 4);
    /// \`\`\`
    pub fn extend_from_slice(&mut self, slice: [T]) {
        let new_len = self.len + slice.len();
        assert(new_len <= MaxLen, "extend_from_slice out of bounds");
        for i in 0..slice.len() {
            self.storage[self.len + i] = slice[i];
        }
        self.len = new_len;
    }

    /// Pushes each element from the other vector to this vector. The length of
    /// the other vector is left unchanged.
    ///
    /// Panics if pushing each element would cause the length of this vector
    /// to exceed the maximum length.
    ///
    /// \`\`\`noir
    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();
    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();
    ///
    /// v2.extend_from_array([1, 2, 3]);
    /// v1.extend_from_bounded_vec(v2);
    ///
    /// assert(v1.storage() == [1, 2, 3, 0, 0]);
    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);
    /// \`\`\`
    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {
        let append_len = vec.len();
        let new_len = self.len + append_len;
        assert(new_len <= MaxLen, "extend_from_bounded_vec out of bounds");

        if is_unconstrained() {
            for i in 0..append_len {
                self.storage[self.len + i] = vec.get_unchecked(i);
            }
        } else {
            let mut exceeded_len = false;
            for i in 0..Len {
                exceeded_len |= i == append_len;
                if !exceeded_len {
                    self.storage[self.len + i] = vec.get_unchecked(i);
                }
            }
        }
        self.len = new_len;
    }

    /// Creates a new vector, populating it with values derived from an array input.
    /// The maximum length of the vector is determined based on the type signature.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])
    /// \`\`\`
    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {
        static_assert(Len <= MaxLen, "from array out of bounds");
        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();
        vec.extend_from_array(array);
        vec
    }

    /// Pops the element at the end of the vector. This will decrease the length
    /// of the vector by one.
    ///
    /// Panics if the vector is empty.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();
    /// v.push(1);
    /// v.push(2);
    ///
    /// let two = v.pop();
    /// let one = v.pop();
    ///
    /// assert(two == 2);
    /// assert(one == 1);
    ///
    /// // error: cannot pop from an empty vector
    /// let _ = v.pop();
    /// \`\`\`
    pub fn pop(&mut self) -> T {
        assert(self.len > 0);
        self.len -= 1;

        let elem = self.storage[self.len];
        self.storage[self.len] = crate::mem::zeroed();
        elem
    }

    /// Returns true if the given predicate returns true for any element
    /// in this vector.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();
    /// v.extend_from_array([2, 4, 6]);
    ///
    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);
    /// assert(all_even);
    /// \`\`\`
    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {
        let mut ret = false;
        if is_unconstrained() {
            for i in 0..self.len {
                ret |= predicate(self.storage[i]);
            }
        } else {
            let mut ret = false;
            let mut exceeded_len = false;
            for i in 0..MaxLen {
                exceeded_len |= i == self.len;
                if !exceeded_len {
                    ret |= predicate(self.storage[i]);
                }
            }
        }
        ret
    }

    /// Creates a new vector of equal size by calling a closure on each element in this vector.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
    /// let result = vec.map(|value| value * 2);
    ///
    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);
    /// assert_eq(result, expected);
    /// \`\`\`
    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {
        let mut ret = BoundedVec::new();
        ret.len = self.len();

        if is_unconstrained() {
            for i in 0..self.len() {
                ret.storage[i] = f(self.get_unchecked(i));
            }
        } else {
            for i in 0..MaxLen {
                if i < self.len() {
                    ret.storage[i] = f(self.get_unchecked(i));
                }
            }
        }

        ret
    }

    /// Creates a new vector of equal size by calling a closure on each element
    /// in this vector, along with its index.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
    /// let result = vec.mapi(|i, value| i + value * 2);
    ///
    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);
    /// assert_eq(result, expected);
    /// \`\`\`
    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {
        let mut ret = BoundedVec::new();
        ret.len = self.len();

        if is_unconstrained() {
            for i in 0..self.len() {
                ret.storage[i] = f(i, self.get_unchecked(i));
            }
        } else {
            for i in 0..MaxLen {
                if i < self.len() {
                    ret.storage[i] = f(i, self.get_unchecked(i));
                }
            }
        }

        ret
    }

    /// Calls a closure on each element in this vector.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
    /// let mut result = BoundedVec::<u32, 4>::new();
    /// vec.for_each(|value| result.push(value * 2));
    ///
    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);
    /// assert_eq(result, expected);
    /// \`\`\`
    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {
        if is_unconstrained() {
            for i in 0..self.len() {
                f(self.get_unchecked(i));
            }
        } else {
            for i in 0..MaxLen {
                if i < self.len() {
                    f(self.get_unchecked(i));
                }
            }
        }
    }

    /// Calls a closure on each element in this vector, along with its index.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
    /// let mut result = BoundedVec::<u32, 4>::new();
    /// vec.for_eachi(|i, value| result.push(i + value * 2));
    ///
    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);
    /// assert_eq(result, expected);
    /// \`\`\`
    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {
        if is_unconstrained() {
            for i in 0..self.len() {
                f(i, self.get_unchecked(i));
            }
        } else {
            for i in 0..MaxLen {
                if i < self.len() {
                    f(i, self.get_unchecked(i));
                }
            }
        }
    }

    /// Creates a new BoundedVec from the given array and length.
    /// The given length must be less than or equal to the length of the array.
    ///
    /// This function will zero out any elements at or past index \`len\` of \`array\`.
    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is
    /// zeroed after that index, you can use \`from_parts_unchecked\` to remove the extra loop.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);
    /// assert_eq(vec.len(), 3);
    /// \`\`\`
    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {
        assert(len <= MaxLen);
        let zeroed = crate::mem::zeroed();

        if is_unconstrained() {
            for i in len..MaxLen {
                array[i] = zeroed;
            }
        } else {
            for i in 0..MaxLen {
                if i >= len {
                    array[i] = zeroed;
                }
            }
        }

        BoundedVec { storage: array, len }
    }

    /// Creates a new BoundedVec from the given array and length.
    /// The given length must be less than or equal to the length of the array.
    ///
    /// This function is unsafe because it expects all elements past the \`len\` index
    /// of \`array\` to be zeroed, but does not check for this internally. Use \`from_parts\`
    /// for a safe version of this function which does zero out any indices past the
    /// given length. Invalidating this assumption can notably cause \`BoundedVec::eq\`
    /// to give incorrect results since it will check even elements past \`len\`.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);
    /// assert_eq(vec.len(), 3);
    ///
    /// // invalid use!
    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);
    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);
    ///
    /// // both vecs have length 3 so we'd expect them to be equal, but this
    /// // fails because elements past the length are still checked in eq
    /// assert_eq(vec1, vec2); // fails
    /// \`\`\`
    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {
        assert(len <= MaxLen);
        BoundedVec { storage: array, len }
    }
}

impl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>
where
    T: Eq,
{
    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {
        // TODO: https://github.com/noir-lang/noir/issues/4837
        //
        // We make the assumption that the user has used the proper interface for working with \`BoundedVec\`s
        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.
        if self.len == other.len {
            self.storage == other.storage
        } else {
            false
        }
    }
}

impl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {
    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {
        BoundedVec::from_array(array)
    }
}

mod bounded_vec_tests {

    mod get {
        use crate::collections::bounded_vec::BoundedVec;

        #[test(should_fail_with = "Attempted to read past end of BoundedVec")]
        fn panics_when_reading_elements_past_end_of_vec() {
            let vec: BoundedVec<Field, 5> = BoundedVec::new();

            crate::println(vec.get(0));
        }
    }

    mod set {
        use crate::collections::bounded_vec::BoundedVec;

        #[test]
        fn set_updates_values_properly() {
            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);

            vec.set(0, 42);
            assert_eq(vec.storage, [42, 0, 0, 0, 0]);

            vec.set(1, 43);
            assert_eq(vec.storage, [42, 43, 0, 0, 0]);

            vec.set(2, 44);
            assert_eq(vec.storage, [42, 43, 44, 0, 0]);

            vec.set(1, 10);
            assert_eq(vec.storage, [42, 10, 44, 0, 0]);

            vec.set(0, 0);
            assert_eq(vec.storage, [0, 10, 44, 0, 0]);
        }

        #[test(should_fail_with = "Attempted to write past end of BoundedVec")]
        fn panics_when_writing_elements_past_end_of_vec() {
            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();
            vec.set(0, 42);

            // Need to use println to avoid DIE removing the write operation.
            crate::println(vec.get(0));
        }
    }

    mod map {
        use crate::collections::bounded_vec::BoundedVec;

        #[test]
        fn applies_function_correctly() {
            // docs:start:bounded-vec-map-example
            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
            let result = vec.map(|value| value * 2);
            // docs:end:bounded-vec-map-example
            let expected = BoundedVec::from_array([2, 4, 6, 8]);

            assert_eq(result, expected);
        }

        #[test]
        fn applies_function_that_changes_return_type() {
            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
            let result = vec.map(|value| (value * 2) as Field);
            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);

            assert_eq(result, expected);
        }

        #[test]
        fn does_not_apply_function_past_len() {
            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);
            let result = vec.map(|value| if value == 0 { 5 } else { value });
            let expected = BoundedVec::from_array([5, 1]);

            assert_eq(result, expected);
            assert_eq(result.get_unchecked(2), 0);
        }
    }

    mod mapi {
        use crate::collections::bounded_vec::BoundedVec;

        #[test]
        fn applies_function_correctly() {
            // docs:start:bounded-vec-mapi-example
            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
            let result = vec.mapi(|i, value| i + value * 2);
            // docs:end:bounded-vec-mapi-example
            let expected = BoundedVec::from_array([2, 5, 8, 11]);

            assert_eq(result, expected);
        }

        #[test]
        fn applies_function_that_changes_return_type() {
            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
            let result = vec.mapi(|i, value| (i + value * 2) as Field);
            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);

            assert_eq(result, expected);
        }

        #[test]
        fn does_not_apply_function_past_len() {
            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);
            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });
            let expected = BoundedVec::from_array([5, 1]);

            assert_eq(result, expected);
            assert_eq(result.get_unchecked(2), 0);
        }
    }

    mod for_each {
        use crate::collections::bounded_vec::BoundedVec;

        // map in terms of for_each
        fn for_each_map<T, U, Env, let MaxLen: u32>(
            input: BoundedVec<T, MaxLen>,
            f: fn[Env](T) -> U,
        ) -> BoundedVec<U, MaxLen> {
            let mut output = BoundedVec::<U, MaxLen>::new();
            let output_ref = &mut output;
            input.for_each(|x| output_ref.push(f(x)));
            output
        }

        #[test]
        fn smoke_test() {
            let mut acc = 0;
            let acc_ref = &mut acc;
            // docs:start:bounded-vec-for-each-example
            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);
            vec.for_each(|value| { *acc_ref += value; });
            // docs:end:bounded-vec-for-each-example
            assert_eq(acc, 6);
        }

        #[test]
        fn applies_function_correctly() {
            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
            let result = for_each_map(vec, |value| value * 2);
            let expected = BoundedVec::from_array([2, 4, 6, 8]);

            assert_eq(result, expected);
        }

        #[test]
        fn applies_function_that_changes_return_type() {
            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
            let result = for_each_map(vec, |value| (value * 2) as Field);
            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);

            assert_eq(result, expected);
        }

        #[test]
        fn does_not_apply_function_past_len() {
            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);
            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });
            let expected = BoundedVec::from_array([5, 1]);

            assert_eq(result, expected);
            assert_eq(result.get_unchecked(2), 0);
        }
    }

    mod for_eachi {
        use crate::collections::bounded_vec::BoundedVec;

        // mapi in terms of for_eachi
        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(
            input: BoundedVec<T, MaxLen>,
            f: fn[Env](u32, T) -> U,
        ) -> BoundedVec<U, MaxLen> {
            let mut output = BoundedVec::<U, MaxLen>::new();
            let output_ref = &mut output;
            input.for_eachi(|i, x| output_ref.push(f(i, x)));
            output
        }

        #[test]
        fn smoke_test() {
            let mut acc = 0;
            let acc_ref = &mut acc;
            // docs:start:bounded-vec-for-eachi-example
            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);
            vec.for_eachi(|i, value| { *acc_ref += i * value; });
            // docs:end:bounded-vec-for-eachi-example

            // 0 * 1 + 1 * 2 + 2 * 3
            assert_eq(acc, 8);
        }

        #[test]
        fn applies_function_correctly() {
            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
            let result = for_eachi_mapi(vec, |i, value| i + value * 2);
            let expected = BoundedVec::from_array([2, 5, 8, 11]);

            assert_eq(result, expected);
        }

        #[test]
        fn applies_function_that_changes_return_type() {
            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);
            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);
            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);

            assert_eq(result, expected);
        }

        #[test]
        fn does_not_apply_function_past_len() {
            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);
            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });
            let expected = BoundedVec::from_array([5, 1]);

            assert_eq(result, expected);
            assert_eq(result.get_unchecked(2), 0);
        }
    }

    mod from_array {
        use crate::collections::bounded_vec::BoundedVec;

        #[test]
        fn empty() {
            let empty_array: [Field; 0] = [];
            let bounded_vec = BoundedVec::from_array([]);

            assert_eq(bounded_vec.max_len(), 0);
            assert_eq(bounded_vec.len(), 0);
            assert_eq(bounded_vec.storage(), empty_array);
        }

        #[test]
        fn equal_len() {
            let array = [1, 2, 3];
            let bounded_vec = BoundedVec::from_array(array);

            assert_eq(bounded_vec.max_len(), 3);
            assert_eq(bounded_vec.len(), 3);
            assert_eq(bounded_vec.storage(), array);
        }

        #[test]
        fn max_len_greater_then_array_len() {
            let array = [1, 2, 3];
            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);

            assert_eq(bounded_vec.max_len(), 10);
            assert_eq(bounded_vec.len(), 3);
            assert_eq(bounded_vec.get(0), 1);
            assert_eq(bounded_vec.get(1), 2);
            assert_eq(bounded_vec.get(2), 3);
        }

        #[test(should_fail_with = "from array out of bounds")]
        fn max_len_lower_then_array_len() {
            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);
        }
    }

    mod trait_from {
        use crate::collections::bounded_vec::BoundedVec;
        use crate::convert::From;

        #[test]
        fn simple() {
            let array = [1, 2];
            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);

            assert_eq(bounded_vec.max_len(), 10);
            assert_eq(bounded_vec.len(), 2);
            assert_eq(bounded_vec.get(0), 1);
            assert_eq(bounded_vec.get(1), 2);
        }
    }

    mod trait_eq {
        use crate::collections::bounded_vec::BoundedVec;

        #[test]
        fn empty_equality() {
            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();
            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();

            assert_eq(bounded_vec1, bounded_vec2);
        }

        #[test]
        fn inequality() {
            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();
            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();
            bounded_vec1.push(1);
            bounded_vec2.push(2);

            assert(bounded_vec1 != bounded_vec2);
        }
    }

    mod from_parts {
        use crate::collections::bounded_vec::BoundedVec;

        #[test]
        fn from_parts() {
            // docs:start:from-parts
            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);
            assert_eq(vec.len(), 3);

            // Any elements past the given length are zeroed out, so these
            // two BoundedVecs will be completely equal
            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);
            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);
            assert_eq(vec1, vec2);
            // docs:end:from-parts
        }

        #[test]
        fn from_parts_unchecked() {
            // docs:start:from-parts-unchecked
            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);
            assert_eq(vec.len(), 3);

            // invalid use!
            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);
            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);

            // both vecs have length 3 so we'd expect them to be equal, but this
            // fails because elements past the length are still checked in eq
            assert(vec1 != vec2);
            // docs:end:from-parts-unchecked
        }
    }
}
`},12:{path:"std/convert.nr",source:`// docs:start:from-trait
pub trait From<T> {
    fn from(input: T) -> Self;
}
// docs:end:from-trait

impl<T> From<T> for T {
    fn from(input: T) -> T {
        input
    }
}

// docs:start:into-trait
pub trait Into<T> {
    fn into(self) -> T;
}

impl<T, U> Into<T> for U
where
    T: From<U>,
{
    fn into(self) -> T {
        T::from(self)
    }
}
// docs:end:into-trait

// docs:start:from-impls
// Unsigned integers

impl From<u8> for u32 {
    fn from(value: u8) -> u32 {
        value as u32
    }
}

impl From<u8> for u64 {
    fn from(value: u8) -> u64 {
        value as u64
    }
}
impl From<u32> for u64 {
    fn from(value: u32) -> u64 {
        value as u64
    }
}

impl From<u8> for u128 {
    fn from(value: u8) -> u128 {
        value as u128
    }
}
impl From<u32> for u128 {
    fn from(value: u32) -> u128 {
        value as u128
    }
}
impl From<u64> for u128 {
    fn from(value: u64) -> u128 {
        value as u128
    }
}

impl From<u8> for Field {
    fn from(value: u8) -> Field {
        value as Field
    }
}
impl From<u32> for Field {
    fn from(value: u32) -> Field {
        value as Field
    }
}
impl From<u64> for Field {
    fn from(value: u64) -> Field {
        value as Field
    }
}

impl From<u128> for Field {
    fn from(value: u128) -> Field {
        value as Field
    }
}

// Signed integers

impl From<i8> for i32 {
    fn from(value: i8) -> i32 {
        value as i32
    }
}

impl From<i8> for i64 {
    fn from(value: i8) -> i64 {
        value as i64
    }
}
impl From<i32> for i64 {
    fn from(value: i32) -> i64 {
        value as i64
    }
}

// Booleans
impl From<bool> for u8 {
    fn from(value: bool) -> u8 {
        value as u8
    }
}
impl From<bool> for u32 {
    fn from(value: bool) -> u32 {
        value as u32
    }
}
impl From<bool> for u64 {
    fn from(value: bool) -> u64 {
        value as u64
    }
}
impl From<bool> for i8 {
    fn from(value: bool) -> i8 {
        value as i8
    }
}
impl From<bool> for i32 {
    fn from(value: bool) -> i32 {
        value as i32
    }
}
impl From<bool> for i64 {
    fn from(value: bool) -> i64 {
        value as i64
    }
}
impl From<bool> for Field {
    fn from(value: bool) -> Field {
        value as Field
    }
}
// docs:end:from-impls

/// A generic interface for casting between primitive types,
/// equivalent of using the \`as\` keyword between values.
///
/// # Example
///
/// \`\`\`
/// let x: Field = 1234567890;
/// let y: u8 = x as u8;
/// let z: u8 = x.as_();
/// assert_eq(y, z);
/// \`\`\`
pub trait AsPrimitive<T> {
    /// The equivalent of doing \`self as T\`.
    fn as_(self) -> T;
}

#[generate_as_primitive_impls]
comptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {
    let types = [
        quote { bool },
        quote { u8 },
        quote { u16 },
        quote { u32 },
        quote { u64 },
        quote { u128 },
        quote { i8 },
        quote { i16 },
        quote { i32 },
        quote { i64 },
        quote { Field },
    ];

    let mut impls = &[];
    for type1 in types {
        for type2 in types {
            impls = impls.push_back(
                quote {
                impl AsPrimitive<$type1> for $type2 {
                    fn as_(self) -> $type1 {
                        self as $type1
                    }
                }
            },
            );
        }
    }
    impls.join(quote {})
}
`},16:{path:"std/embedded_curve_ops.nr",source:`use crate::cmp::Eq;
use crate::hash::Hash;
use crate::ops::arith::{Add, Neg, Sub};

/// A point on the embedded elliptic curve
/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.
/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.
pub struct EmbeddedCurvePoint {
    pub x: Field,
    pub y: Field,
    pub is_infinite: bool,
}

impl EmbeddedCurvePoint {
    /// Elliptic curve point doubling operation
    /// returns the doubled point of a point P, i.e P+P
    pub fn double(self) -> EmbeddedCurvePoint {
        embedded_curve_add(self, self)
    }

    /// Returns the null element of the curve; 'the point at infinity'
    pub fn point_at_infinity() -> EmbeddedCurvePoint {
        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }
    }

    /// Returns the curve's generator point.
    pub fn generator() -> EmbeddedCurvePoint {
        // Generator point for the grumpkin curve (y^2 = x^3 - 17)
        EmbeddedCurvePoint {
            x: 1,
            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)
            is_infinite: false,
        }
    }
}

impl Add for EmbeddedCurvePoint {
    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity
    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {
        embedded_curve_add(self, other)
    }
}

impl Sub for EmbeddedCurvePoint {
    /// Points subtraction operation, using addition and negation
    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {
        self + other.neg()
    }
}

impl Neg for EmbeddedCurvePoint {
    /// Negates a point P, i.e returns -P, by negating the y coordinate.
    /// If the point is at infinity, then the result is also at infinity.
    fn neg(self) -> EmbeddedCurvePoint {
        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }
    }
}

impl Eq for EmbeddedCurvePoint {
    /// Checks whether two points are equal
    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {
        (self.is_infinite & b.is_infinite)
            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))
    }
}

impl Hash for EmbeddedCurvePoint {
    fn hash<H>(self, state: &mut H)
    where
        H: crate::hash::Hasher,
    {
        if self.is_infinite {
            self.is_infinite.hash(state);
        } else {
            self.x.hash(state);
            self.y.hash(state);
        }
    }
}

/// Scalar for the embedded curve represented as low and high limbs
/// By definition, the scalar field of the embedded curve is base field of the proving system curve.
/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.
pub struct EmbeddedCurveScalar {
    pub lo: Field,
    pub hi: Field,
}

impl EmbeddedCurveScalar {
    pub fn new(lo: Field, hi: Field) -> Self {
        EmbeddedCurveScalar { lo, hi }
    }

    #[field(bn254)]
    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {
        let (a, b) = crate::field::bn254::decompose(scalar);
        EmbeddedCurveScalar { lo: a, hi: b }
    }

    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value
    #[field(bn254)]
    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {
        let mut v = 1;
        let mut lo = 0 as Field;
        let mut hi = 0 as Field;
        for i in 0..16 {
            lo = lo + (bytes[offset + 31 - i] as Field) * v;
            hi = hi + (bytes[offset + 15 - i] as Field) * v;
            v = v * 256;
        }
        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };
        sig_s
    }
}

impl Eq for EmbeddedCurveScalar {
    fn eq(self, other: Self) -> bool {
        (other.hi == self.hi) & (other.lo == self.lo)
    }
}

impl Hash for EmbeddedCurveScalar {
    fn hash<H>(self, state: &mut H)
    where
        H: crate::hash::Hasher,
    {
        self.hi.hash(state);
        self.lo.hash(state);
    }
}

// Computes a multi scalar multiplication over the embedded curve.
// For bn254, We have Grumpkin and Baby JubJub.
// For bls12-381, we have JubJub and Bandersnatch.
//
// The embedded curve being used is decided by the
// underlying proof system.
// docs:start:multi_scalar_mul
pub fn multi_scalar_mul<let N: u32>(
    points: [EmbeddedCurvePoint; N],
    scalars: [EmbeddedCurveScalar; N],
) -> EmbeddedCurvePoint
// docs:end:multi_scalar_mul
{
    multi_scalar_mul_array_return(points, scalars)[0]
}

#[foreign(multi_scalar_mul)]
pub(crate) fn multi_scalar_mul_array_return<let N: u32>(
    points: [EmbeddedCurvePoint; N],
    scalars: [EmbeddedCurveScalar; N],
) -> [EmbeddedCurvePoint; 1] {}

// docs:start:fixed_base_scalar_mul
pub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint
// docs:end:fixed_base_scalar_mul
{
    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])
}

/// This function only assumes that the points are on the curve
/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe
// docs:start:embedded_curve_add
pub fn embedded_curve_add(
    point1: EmbeddedCurvePoint,
    point2: EmbeddedCurvePoint,
) -> EmbeddedCurvePoint {
    // docs:end:embedded_curve_add
    if crate::runtime::is_unconstrained() {
        // \`embedded_curve_add_unsafe\` requires the inputs not to be the infinity point, so we check it here.
        // This is because \`embedded_curve_add_unsafe\` uses the \`embedded_curve_add\` opcode.
        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point
        // so that it can apply the ec addition formula directly.
        if point1.is_infinite {
            point2
        } else if point2.is_infinite {
            point1
        } else {
            embedded_curve_add_unsafe(point1, point2)
        }
    } else {
        // In a constrained context, we also need to check the inputs are not the infinity point because we also use \`embedded_curve_add_unsafe\`
        // However we also need to identify the case where the two inputs are the same, because then
        // the addition formula does not work and we need to use the doubling formula instead.
        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.

        // x_coordinates_match is true if both abscissae are the same
        let x_coordinates_match = point1.x == point2.x;
        // y_coordinates_match is true if both ordinates are the same
        let y_coordinates_match = point1.y == point2.y;
        // double_predicate is true if both abscissae and ordinates are the same
        let double_predicate = (x_coordinates_match & y_coordinates_match);
        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other
        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);
        let point1_1 = EmbeddedCurvePoint {
            x: point1.x + (x_coordinates_match as Field),
            y: point1.y,
            is_infinite: false,
        };
        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };
        // point1_1 is guaranteed to have a different abscissa than point2:
        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0
        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case
        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use \`embedded_curve_add_unsafe\`
        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.
        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);

        // \`embedded_curve_add_unsafe\` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.
        let double = embedded_curve_add_unsafe(point1, point1);
        // \`embedded_curve_add_unsafe\` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)
        // However we did this logic when we computed \`double_predicate\`, so we set the result to 2*point1 if point1 and point2 are the same
        result = if double_predicate { double } else { result };

        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point
        if point1.is_infinite {
            result = point2;
        }
        if point2.is_infinite {
            result = point1;
        }

        // Finally, we set the is_infinity flag of the result:
        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful
        // so we should not use the fact that the inputs are opposite in this case:
        let mut result_is_infinity =
            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);
        // However, if both of them are at infinity, then the result is also at infinity
        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);
        result
    }
}

#[foreign(embedded_curve_add)]
fn embedded_curve_add_array_return(
    _point1: EmbeddedCurvePoint,
    _point2: EmbeddedCurvePoint,
) -> [EmbeddedCurvePoint; 1] {}

/// This function assumes that:
/// The points are on the curve, and
/// The points don't share an x-coordinate, and
/// Neither point is the infinity point.
/// If it is used with correct input, the function ensures the correct non-zero result is returned.
/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.
pub fn embedded_curve_add_not_nul(
    point1: EmbeddedCurvePoint,
    point2: EmbeddedCurvePoint,
) -> EmbeddedCurvePoint {
    assert(point1.x != point2.x);
    assert(!point1.is_infinite);
    assert(!point2.is_infinite);
    embedded_curve_add_unsafe(point1, point2)
}

/// Unsafe ec addition
/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.
/// If they have the same value but are different variables, the result will be incorrect because in this case
/// it assumes (but does not check) that the points' x-coordinates are not equal.
/// It also assumes neither point is the infinity point.
pub fn embedded_curve_add_unsafe(
    point1: EmbeddedCurvePoint,
    point2: EmbeddedCurvePoint,
) -> EmbeddedCurvePoint {
    embedded_curve_add_array_return(point1, point2)[0]
}
`},17:{path:"std/field/bn254.nr",source:`use crate::field::field_less_than;
use crate::runtime::is_unconstrained;

// The low and high decomposition of the field modulus
global PLO: Field = 53438638232309528389504892708671455233;
global PHI: Field = 64323764613183177041862057485226039389;

pub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;

// Decomposes a single field into two 16 byte fields.
fn compute_decomposition(x: Field) -> (Field, Field) {
    // Here's we're taking advantage of truncating 128 bit limbs from the input field
    // and then subtracting them from the input such the field division is equivalent to integer division.
    let low = (x as u128) as Field;
    let high = (x - low) / TWO_POW_128;

    (low, high)
}

pub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {
    compute_decomposition(x)
}

unconstrained fn lte_hint(x: Field, y: Field) -> bool {
    if x == y {
        true
    } else {
        field_less_than(x, y)
    }
}

// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)
fn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {
    let (alo, ahi) = a;
    let (blo, bhi) = b;
    // Safety: borrow is enforced to be boolean due to its type.
    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)
    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)
    unsafe {
        let borrow = lte_hint(alo, blo);

        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;
        let rhi = ahi - bhi - (borrow as Field);

        rlo.assert_max_bit_size::<128>();
        rhi.assert_max_bit_size::<128>();
    }
}

/// Decompose a single field into two 16 byte fields.
pub fn decompose(x: Field) -> (Field, Field) {
    if is_unconstrained() {
        compute_decomposition(x)
    } else {
        // Safety: decomposition is properly checked below
        unsafe {
            // Take hints of the decomposition
            let (xlo, xhi) = decompose_hint(x);

            // Range check the limbs
            xlo.assert_max_bit_size::<128>();
            xhi.assert_max_bit_size::<128>();

            // Check that the decomposition is correct
            assert_eq(x, xlo + TWO_POW_128 * xhi);

            // Assert that the decomposition of P is greater than the decomposition of x
            assert_gt_limbs((PLO, PHI), (xlo, xhi));
            (xlo, xhi)
        }
    }
}

pub fn assert_gt(a: Field, b: Field) {
    if is_unconstrained() {
        assert(
            // Safety: already unconstrained
            unsafe { field_less_than(b, a) },
        );
    } else {
        // Decompose a and b
        let a_limbs = decompose(a);
        let b_limbs = decompose(b);

        // Assert that a_limbs is greater than b_limbs
        assert_gt_limbs(a_limbs, b_limbs)
    }
}

pub fn assert_lt(a: Field, b: Field) {
    assert_gt(b, a);
}

pub fn gt(a: Field, b: Field) -> bool {
    if is_unconstrained() {
        // Safety: unsafe in unconstrained
        unsafe {
            field_less_than(b, a)
        }
    } else if a == b {
        false
    } else {
        // Safety: Take a hint of the comparison and verify it
        unsafe {
            if field_less_than(a, b) {
                assert_gt(b, a);
                false
            } else {
                assert_gt(a, b);
                true
            }
        }
    }
}

pub fn lt(a: Field, b: Field) -> bool {
    gt(b, a)
}

mod tests {
    // TODO: Allow imports from "super"
    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};

    #[test]
    fn check_decompose() {
        assert_eq(decompose(TWO_POW_128), (0, 1));
        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));
        assert_eq(decompose(0x1234567890), (0x1234567890, 0));
    }

    #[test]
    unconstrained fn check_decompose_unconstrained() {
        assert_eq(decompose(TWO_POW_128), (0, 1));
        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));
        assert_eq(decompose(0x1234567890), (0x1234567890, 0));
    }

    #[test]
    unconstrained fn check_lte_hint() {
        assert(lte_hint(0, 1));
        assert(lte_hint(0, 0x100));
        assert(lte_hint(0x100, TWO_POW_128 - 1));
        assert(!lte_hint(0 - 1, 0));

        assert(lte_hint(0, 0));
        assert(lte_hint(0x100, 0x100));
        assert(lte_hint(0 - 1, 0 - 1));
    }

    #[test]
    fn check_assert_gt() {
        assert_gt(1, 0);
        assert_gt(0x100, 0);
        assert_gt((0 - 1), (0 - 2));
        assert_gt(TWO_POW_128, 0);
        assert_gt(0 - 1, 0);
    }

    #[test]
    unconstrained fn check_assert_gt_unconstrained() {
        assert_gt(1, 0);
        assert_gt(0x100, 0);
        assert_gt((0 - 1), (0 - 2));
        assert_gt(TWO_POW_128, 0);
        assert_gt(0 - 1, 0);
    }

    #[test]
    fn check_gt() {
        assert(gt(1, 0));
        assert(gt(0x100, 0));
        assert(gt((0 - 1), (0 - 2)));
        assert(gt(TWO_POW_128, 0));
        assert(!gt(0, 0));
        assert(!gt(0, 0x100));
        assert(gt(0 - 1, 0 - 2));
        assert(!gt(0 - 2, 0 - 1));
    }

    #[test]
    unconstrained fn check_gt_unconstrained() {
        assert(gt(1, 0));
        assert(gt(0x100, 0));
        assert(gt((0 - 1), (0 - 2)));
        assert(gt(TWO_POW_128, 0));
        assert(!gt(0, 0));
        assert(!gt(0, 0x100));
        assert(gt(0 - 1, 0 - 2));
        assert(!gt(0 - 2, 0 - 1));
    }

    #[test]
    fn check_plo_phi() {
        assert_eq(PLO + PHI * TWO_POW_128, 0);
        let p_bytes = crate::field::modulus_le_bytes();
        let mut p_low: Field = 0;
        let mut p_high: Field = 0;

        let mut offset = 1;
        for i in 0..16 {
            p_low += (p_bytes[i] as Field) * offset;
            p_high += (p_bytes[i + 16] as Field) * offset;
            offset *= 256;
        }
        assert_eq(p_low, PLO);
        assert_eq(p_high, PHI);
    }
}
`},18:{path:"std/field/mod.nr",source:`pub mod bn254;
use crate::{runtime::is_unconstrained, static_assert};
use bn254::lt as bn254_lt;

impl Field {
    /// Asserts that \`self\` can be represented in \`bit_size\` bits.
    ///
    /// # Failures
    /// Causes a constraint failure for \`Field\` values exceeding \`2^{bit_size}\`.
    // docs:start:assert_max_bit_size
    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {
        // docs:end:assert_max_bit_size
        static_assert(
            BIT_SIZE < modulus_num_bits() as u32,
            "BIT_SIZE must be less than modulus_num_bits",
        );
        self.__assert_max_bit_size(BIT_SIZE);
    }

    #[builtin(apply_range_constraint)]
    fn __assert_max_bit_size(self, bit_size: u32) {}

    /// Decomposes \`self\` into its little endian bit decomposition as a \`[u1; N]\` array.
    /// This slice will be zero padded should not all bits be necessary to represent \`self\`.
    ///
    /// # Failures
    /// Causes a constraint failure for \`Field\` values exceeding \`2^N\` as the resulting slice will not
    /// be able to represent the original \`Field\`.
    ///
    /// # Safety
    /// Values of \`N\` equal to or greater than the number of bits necessary to represent the \`Field\` modulus
    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the \`Field\` will
    /// wrap around due to overflow when verifying the decomposition.
    #[builtin(to_le_bits)]
    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}

    /// Decomposes \`self\` into its big endian bit decomposition as a \`[u1; N]\` array.
    /// This array will be zero padded should not all bits be necessary to represent \`self\`.
    ///
    /// # Failures
    /// Causes a constraint failure for \`Field\` values exceeding \`2^N\` as the resulting slice will not
    /// be able to represent the original \`Field\`.
    ///
    /// # Safety
    /// Values of \`N\` equal to or greater than the number of bits necessary to represent the \`Field\` modulus
    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the \`Field\` will
    /// wrap around due to overflow when verifying the decomposition.
    #[builtin(to_be_bits)]
    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}

    /// Decomposes \`self\` into its little endian bit decomposition as a \`[u1; N]\` array.
    /// This slice will be zero padded should not all bits be necessary to represent \`self\`.
    ///
    /// # Failures
    /// Causes a constraint failure for \`Field\` values exceeding \`2^N\` as the resulting slice will not
    /// be able to represent the original \`Field\`.
    ///
    /// # Safety
    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.
    // docs:start:to_le_bits
    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {
        // docs:end:to_le_bits
        let bits = self._to_le_bits();

        if !is_unconstrained() {
            // Ensure that the byte decomposition does not overflow the modulus
            let p = modulus_le_bits();
            assert(bits.len() <= p.len());
            let mut ok = bits.len() != p.len();
            for i in 0..N {
                if !ok {
                    if (bits[N - 1 - i] != p[N - 1 - i]) {
                        assert(p[N - 1 - i] == 1);
                        ok = true;
                    }
                }
            }
            assert(ok);
        }
        bits
    }

    /// Decomposes \`self\` into its big endian bit decomposition as a \`[u1; N]\` array.
    /// This array will be zero padded should not all bits be necessary to represent \`self\`.
    ///
    /// # Failures
    /// Causes a constraint failure for \`Field\` values exceeding \`2^N\` as the resulting slice will not
    /// be able to represent the original \`Field\`.
    ///
    /// # Safety
    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.
    // docs:start:to_be_bits
    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {
        // docs:end:to_be_bits
        let bits = self._to_be_bits();

        if !is_unconstrained() {
            // Ensure that the decomposition does not overflow the modulus
            let p = modulus_be_bits();
            assert(bits.len() <= p.len());
            let mut ok = bits.len() != p.len();
            for i in 0..N {
                if !ok {
                    if (bits[i] != p[i]) {
                        assert(p[i] == 1);
                        ok = true;
                    }
                }
            }
            assert(ok);
        }
        bits
    }

    /// Decomposes \`self\` into its little endian byte decomposition as a \`[u8;N]\` array
    /// This array will be zero padded should not all bytes be necessary to represent \`self\`.
    ///
    /// # Failures
    ///  The length N of the array must be big enough to contain all the bytes of the 'self',
    ///  and no more than the number of bytes required to represent the field modulus
    ///
    /// # Safety
    /// The result is ensured to be the canonical decomposition of the field element
    // docs:start:to_le_bytes
    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {
        // docs:end:to_le_bytes
        static_assert(
            N <= modulus_le_bytes().len(),
            "N must be less than or equal to modulus_le_bytes().len()",
        );
        // Compute the byte decomposition
        let bytes = self.to_le_radix(256);

        if !is_unconstrained() {
            // Ensure that the byte decomposition does not overflow the modulus
            let p = modulus_le_bytes();
            assert(bytes.len() <= p.len());
            let mut ok = bytes.len() != p.len();
            for i in 0..N {
                if !ok {
                    if (bytes[N - 1 - i] != p[N - 1 - i]) {
                        assert(bytes[N - 1 - i] < p[N - 1 - i]);
                        ok = true;
                    }
                }
            }
            assert(ok);
        }
        bytes
    }

    /// Decomposes \`self\` into its big endian byte decomposition as a \`[u8;N]\` array of length required to represent the field modulus
    /// This array will be zero padded should not all bytes be necessary to represent \`self\`.
    ///
    /// # Failures
    ///  The length N of the array must be big enough to contain all the bytes of the 'self',
    ///  and no more than the number of bytes required to represent the field modulus
    ///
    /// # Safety
    /// The result is ensured to be the canonical decomposition of the field element
    // docs:start:to_be_bytes
    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {
        // docs:end:to_be_bytes
        static_assert(
            N <= modulus_le_bytes().len(),
            "N must be less than or equal to modulus_le_bytes().len()",
        );
        // Compute the byte decomposition
        let bytes = self.to_be_radix(256);

        if !is_unconstrained() {
            // Ensure that the byte decomposition does not overflow the modulus
            let p = modulus_be_bytes();
            assert(bytes.len() <= p.len());
            let mut ok = bytes.len() != p.len();
            for i in 0..N {
                if !ok {
                    if (bytes[i] != p[i]) {
                        assert(bytes[i] < p[i]);
                        ok = true;
                    }
                }
            }
            assert(ok);
        }
        bytes
    }

    // docs:start:to_le_radix
    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {
        // Brillig does not need an immediate radix
        if !crate::runtime::is_unconstrained() {
            static_assert(1 < radix, "radix must be greater than 1");
            static_assert(radix <= 256, "radix must be less than or equal to 256");
            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");
        }
        self.__to_le_radix(radix)
    }
    // docs:end:to_le_radix

    // docs:start:to_be_radix
    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {
        // Brillig does not need an immediate radix
        if !crate::runtime::is_unconstrained() {
            crate::assert_constant(radix);
        }
        self.__to_be_radix(radix)
    }
    // docs:end:to_be_radix

    // \`_radix\` must be less than 256
    #[builtin(to_le_radix)]
    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}

    // \`_radix\` must be less than 256
    #[builtin(to_be_radix)]
    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}

    // Returns self to the power of the given exponent value.
    // Caution: we assume the exponent fits into 32 bits
    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits
    pub fn pow_32(self, exponent: Field) -> Field {
        let mut r: Field = 1;
        let b: [u1; 32] = exponent.to_le_bits();

        for i in 1..33 {
            r *= r;
            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;
        }
        r
    }

    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x \`elem\` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.
    pub fn sgn0(self) -> u1 {
        self as u1
    }

    pub fn lt(self, another: Field) -> bool {
        if crate::compat::is_bn254() {
            bn254_lt(self, another)
        } else {
            lt_fallback(self, another)
        }
    }

    /// Convert a little endian byte array to a field element.
    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.
    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {
        static_assert(
            N <= modulus_le_bytes().len(),
            "N must be less than or equal to modulus_le_bytes().len()",
        );
        let mut v = 1;
        let mut result = 0;

        for i in 0..N {
            result += (bytes[i] as Field) * v;
            v = v * 256;
        }
        result
    }

    /// Convert a big endian byte array to a field element.
    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.
    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {
        let mut v = 1;
        let mut result = 0;

        for i in 0..N {
            result += (bytes[N - 1 - i] as Field) * v;
            v = v * 256;
        }
        result
    }
}

#[builtin(modulus_num_bits)]
pub comptime fn modulus_num_bits() -> u64 {}

#[builtin(modulus_be_bits)]
pub comptime fn modulus_be_bits() -> [u1] {}

#[builtin(modulus_le_bits)]
pub comptime fn modulus_le_bits() -> [u1] {}

#[builtin(modulus_be_bytes)]
pub comptime fn modulus_be_bytes() -> [u8] {}

#[builtin(modulus_le_bytes)]
pub comptime fn modulus_le_bytes() -> [u8] {}

/// An unconstrained only built in to efficiently compare fields.
#[builtin(field_less_than)]
unconstrained fn __field_less_than(x: Field, y: Field) -> bool {}

pub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {
    __field_less_than(x, y)
}

// Convert a 32 byte array to a field element by modding
pub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {
    // Convert it to a field element
    let mut v = 1;
    let mut high = 0 as Field;
    let mut low = 0 as Field;

    for i in 0..16 {
        high = high + (bytes32[15 - i] as Field) * v;
        low = low + (bytes32[16 + 15 - i] as Field) * v;
        v = v * 256;
    }
    // Abuse that a % p + b % p = (a + b) % p and that low < p
    low + high * v
}

fn lt_fallback(x: Field, y: Field) -> bool {
    if is_unconstrained() {
        // Safety: unconstrained context
        unsafe {
            field_less_than(x, y)
        }
    } else {
        let x_bytes: [u8; 32] = x.to_le_bytes();
        let y_bytes: [u8; 32] = y.to_le_bytes();
        let mut x_is_lt = false;
        let mut done = false;
        for i in 0..32 {
            if (!done) {
                let x_byte = x_bytes[32 - 1 - i] as u8;
                let y_byte = y_bytes[32 - 1 - i] as u8;
                let bytes_match = x_byte == y_byte;
                if !bytes_match {
                    x_is_lt = x_byte < y_byte;
                    done = true;
                }
            }
        }
        x_is_lt
    }
}

mod tests {
    use crate::{panic::panic, runtime};
    use super::field_less_than;

    #[test]
    // docs:start:to_be_bits_example
    fn test_to_be_bits() {
        let field = 2;
        let bits: [u1; 8] = field.to_be_bits();
        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);
    }
    // docs:end:to_be_bits_example

    #[test]
    // docs:start:to_le_bits_example
    fn test_to_le_bits() {
        let field = 2;
        let bits: [u1; 8] = field.to_le_bits();
        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);
    }
    // docs:end:to_le_bits_example

    #[test]
    // docs:start:to_be_bytes_example
    fn test_to_be_bytes() {
        let field = 2;
        let bytes: [u8; 8] = field.to_be_bytes();
        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);
        assert_eq(Field::from_be_bytes::<8>(bytes), field);
    }
    // docs:end:to_be_bytes_example

    #[test]
    // docs:start:to_le_bytes_example
    fn test_to_le_bytes() {
        let field = 2;
        let bytes: [u8; 8] = field.to_le_bytes();
        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq(Field::from_le_bytes::<8>(bytes), field);
    }
    // docs:end:to_le_bytes_example

    #[test]
    // docs:start:to_be_radix_example
    fn test_to_be_radix() {
        // 259, in base 256, big endian, is [1, 3].
        // i.e. 3 * 256^0 + 1 * 256^1
        let field = 259;

        // The radix (in this example, 256) must be a power of 2.
        // The length of the returned byte array can be specified to be
        // >= the amount of space needed.
        let bytes: [u8; 8] = field.to_be_radix(256);
        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);
        assert_eq(Field::from_be_bytes::<8>(bytes), field);
    }
    // docs:end:to_be_radix_example

    #[test]
    // docs:start:to_le_radix_example
    fn test_to_le_radix() {
        // 259, in base 256, little endian, is [3, 1].
        // i.e. 3 * 256^0 + 1 * 256^1
        let field = 259;

        // The radix (in this example, 256) must be a power of 2.
        // The length of the returned byte array can be specified to be
        // >= the amount of space needed.
        let bytes: [u8; 8] = field.to_le_radix(256);
        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);
        assert_eq(Field::from_le_bytes::<8>(bytes), field);
    }
    // docs:end:to_le_radix_example

    #[test(should_fail_with = "radix must be greater than 1")]
    fn test_to_le_radix_1() {
        // this test should only fail in constrained mode
        if !runtime::is_unconstrained() {
            let field = 2;
            let _: [u8; 8] = field.to_le_radix(1);
        } else {
            panic(f"radix must be greater than 1");
        }
    }

    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2
    //#[test]
    //fn test_to_le_radix_brillig_1() {
    //    // this test should only fail in constrained mode
    //    if runtime::is_unconstrained() {
    //        let field = 1;
    //        let out: [u8; 8] = field.to_le_radix(1);
    //        crate::println(out);
    //        let expected = [0; 8];
    //        assert(out == expected, "unexpected result");
    //    }
    //}

    #[test(should_fail_with = "radix must be a power of 2")]
    fn test_to_le_radix_3() {
        // this test should only fail in constrained mode
        if !runtime::is_unconstrained() {
            let field = 2;
            let _: [u8; 8] = field.to_le_radix(3);
        } else {
            panic(f"radix must be a power of 2");
        }
    }

    #[test]
    fn test_to_le_radix_brillig_3() {
        // this test should only fail in constrained mode
        if runtime::is_unconstrained() {
            let field = 1;
            let out: [u8; 8] = field.to_le_radix(3);
            let mut expected = [0; 8];
            expected[0] = 1;
            assert(out == expected, "unexpected result");
        }
    }

    #[test(should_fail_with = "radix must be less than or equal to 256")]
    fn test_to_le_radix_512() {
        // this test should only fail in constrained mode
        if !runtime::is_unconstrained() {
            let field = 2;
            let _: [u8; 8] = field.to_le_radix(512);
        } else {
            panic(f"radix must be less than or equal to 256")
        }
    }

    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512
    //#[test]
    //fn test_to_le_radix_brillig_512() {
    //    // this test should only fail in constrained mode
    //    if runtime::is_unconstrained() {
    //        let field = 1;
    //        let out: [u8; 8] = field.to_le_radix(512);
    //        let mut expected = [0; 8];
    //        expected[0] = 1;
    //        assert(out == expected, "unexpected result");
    //    }
    //}

    #[test]
    unconstrained fn test_field_less_than() {
        assert(field_less_than(0, 1));
        assert(field_less_than(0, 0x100));
        assert(field_less_than(0x100, 0 - 1));
        assert(!field_less_than(0 - 1, 0));
    }
}
`},19:{path:"std/hash/mod.nr",source:`// Exposed only for usage in \`std::meta\`
pub(crate) mod poseidon2;

use crate::default::Default;
use crate::embedded_curve_ops::{
    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,
};
use crate::meta::derive_via;

#[foreign(sha256_compression)]
// docs:start:sha256_compression
pub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}
// docs:end:sha256_compression

#[foreign(keccakf1600)]
// docs:start:keccakf1600
pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}
// docs:end:keccakf1600

pub mod keccak {
    #[deprecated("This function has been moved to std::hash::keccakf1600")]
    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {
        super::keccakf1600(input)
    }
}

#[foreign(blake2s)]
// docs:start:blake2s
pub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]
// docs:end:blake2s
{}

#[foreign(blake3)]
// docs:start:blake3
pub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]
// docs:end:blake3
{}

// docs:start:pedersen_commitment
pub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {
    // docs:end:pedersen_commitment
    pedersen_commitment_with_separator(input, 0)
}

#[inline_always]
pub fn pedersen_commitment_with_separator<let N: u32>(
    input: [Field; N],
    separator: u32,
) -> EmbeddedCurvePoint {
    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];
    for i in 0..N {
        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.
        points[i] = from_field_unsafe(input[i]);
    }
    let generators = derive_generators("DEFAULT_DOMAIN_SEPARATOR".as_bytes(), separator);
    multi_scalar_mul(generators, points)
}

// docs:start:pedersen_hash
pub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field
// docs:end:pedersen_hash
{
    pedersen_hash_with_separator(input, 0)
}

#[no_predicates]
pub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {
    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];
    let mut generators: [EmbeddedCurvePoint; N + 1] =
        [EmbeddedCurvePoint::point_at_infinity(); N + 1];
    let domain_generators: [EmbeddedCurvePoint; N] =
        derive_generators("DEFAULT_DOMAIN_SEPARATOR".as_bytes(), separator);

    for i in 0..N {
        scalars[i] = from_field_unsafe(input[i]);
        generators[i] = domain_generators[i];
    }
    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };

    let length_generator: [EmbeddedCurvePoint; 1] =
        derive_generators("pedersen_hash_length".as_bytes(), 0);
    generators[N] = length_generator[0];
    multi_scalar_mul_array_return(generators, scalars)[0].x
}

#[field(bn254)]
#[inline_always]
pub fn derive_generators<let N: u32, let M: u32>(
    domain_separator_bytes: [u8; M],
    starting_index: u32,
) -> [EmbeddedCurvePoint; N] {
    crate::assert_constant(domain_separator_bytes);
    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index
    __derive_generators(domain_separator_bytes, starting_index)
}

#[builtin(derive_pedersen_generators)]
#[field(bn254)]
fn __derive_generators<let N: u32, let M: u32>(
    domain_separator_bytes: [u8; M],
    starting_index: u32,
) -> [EmbeddedCurvePoint; N] {}

#[field(bn254)]
// Same as from_field but:
// does not assert the limbs are 128 bits
// does not assert the decomposition does not overflow the EmbeddedCurveScalar
fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {
    // Safety: xlo and xhi decomposition is checked below
    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };
    // Check that the decomposition is correct
    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);
    EmbeddedCurveScalar { lo: xlo, hi: xhi }
}

pub fn hash_to_field(inputs: [Field]) -> Field {
    let mut sum = 0;

    for input in inputs {
        let input_bytes: [u8; 32] = input.to_le_bytes();
        sum += crate::field::bytes32_to_field(blake2s(input_bytes));
    }

    sum
}

#[foreign(poseidon2_permutation)]
pub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}

// Generic hashing support.
// Partially ported and impacted by rust.

// Hash trait shall be implemented per type.
#[derive_via(derive_hash)]
pub trait Hash {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher;
}

// docs:start:derive_hash
comptime fn derive_hash(s: TypeDefinition) -> Quoted {
    let name = quote { Hash };
    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };
    let for_each_field = |name| quote { _self.$name.hash(_state); };
    crate::meta::make_trait_impl(
        s,
        name,
        signature,
        for_each_field,
        quote {},
        |fields| fields,
    )
}
// docs:end:derive_hash

// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.
// TODO: consider making the types generic here ([u8], [Field], etc.)
pub trait Hasher {
    fn finish(self) -> Field;

    fn write(&mut self, input: Field);
}

// BuildHasher is a factory trait, responsible for production of specific Hasher.
pub trait BuildHasher<H>
where
    H: Hasher,
{
    fn build_hasher(self) -> H;
}

pub struct BuildHasherDefault<H>;

impl<H> BuildHasher<H> for BuildHasherDefault<H>
where
    H: Hasher + Default,
{
    fn build_hasher(_self: Self) -> H {
        H::default()
    }
}

impl<H> Default for BuildHasherDefault<H>
where
    H: Hasher + Default,
{
    fn default() -> Self {
        BuildHasherDefault {}
    }
}

impl Hash for Field {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self);
    }
}

impl Hash for u1 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u8 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u16 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u32 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u64 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u128 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for i8 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for i16 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for i32 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for i64 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for bool {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for () {
    fn hash<H>(_self: Self, _state: &mut H)
    where
        H: Hasher,
    {}
}

impl<T, let N: u32> Hash for [T; N]
where
    T: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        for elem in self {
            elem.hash(state);
        }
    }
}

impl<T> Hash for [T]
where
    T: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.len().hash(state);
        for elem in self {
            elem.hash(state);
        }
    }
}

impl<A, B> Hash for (A, B)
where
    A: Hash,
    B: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.hash(state);
        self.1.hash(state);
    }
}

impl<A, B, C> Hash for (A, B, C)
where
    A: Hash,
    B: Hash,
    C: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.hash(state);
        self.1.hash(state);
        self.2.hash(state);
    }
}

impl<A, B, C, D> Hash for (A, B, C, D)
where
    A: Hash,
    B: Hash,
    C: Hash,
    D: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.hash(state);
        self.1.hash(state);
        self.2.hash(state);
        self.3.hash(state);
    }
}

impl<A, B, C, D, E> Hash for (A, B, C, D, E)
where
    A: Hash,
    B: Hash,
    C: Hash,
    D: Hash,
    E: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.hash(state);
        self.1.hash(state);
        self.2.hash(state);
        self.3.hash(state);
        self.4.hash(state);
    }
}

// Some test vectors for Pedersen hash and Pedersen Commitment.
// They have been generated using the same functions so the tests are for now useless
// but they will be useful when we switch to Noir implementation.
#[test]
fn assert_pedersen() {
    assert_eq(
        pedersen_hash_with_separator([1], 1),
        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,
    );
    assert_eq(
        pedersen_commitment_with_separator([1], 1),
        EmbeddedCurvePoint {
            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,
            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,
            is_infinite: false,
        },
    );

    assert_eq(
        pedersen_hash_with_separator([1, 2], 2),
        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2], 2),
        EmbeddedCurvePoint {
            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,
            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3], 3),
        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3], 3),
        EmbeddedCurvePoint {
            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,
            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4], 4),
        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4], 4),
        EmbeddedCurvePoint {
            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,
            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),
        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),
        EmbeddedCurvePoint {
            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,
            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),
        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),
        EmbeddedCurvePoint {
            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,
            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),
        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),
        EmbeddedCurvePoint {
            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,
            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),
        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),
        EmbeddedCurvePoint {
            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,
            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),
        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),
        EmbeddedCurvePoint {
            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,
            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),
        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),
        EmbeddedCurvePoint {
            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,
            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,
            is_infinite: false,
        },
    );
}
`},25:{path:"std/meta/expr.nr",source:`//! Contains methods on the built-in \`Expr\` type for quoted, syntactically valid expressions.

use crate::meta::op::BinaryOp;
use crate::meta::op::UnaryOp;
use crate::option::Option;

impl Expr {
    /// If this expression is an array literal \`[elem1, ..., elemN]\`, this returns a slice of each element in the array.
    #[builtin(expr_as_array)]
    // docs:start:as_array
    pub comptime fn as_array(self) -> Option<[Expr]> {}
    // docs:end:as_array

    /// If this expression is an assert, this returns the assert expression and the optional message.
    #[builtin(expr_as_assert)]
    // docs:start:as_assert
    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}
    // docs:end:as_assert

    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side
    /// expressions, together with the optional message.
    #[builtin(expr_as_assert_eq)]
    // docs:start:as_assert_eq
    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}
    // docs:end:as_assert_eq

    /// If this expression is an assignment, this returns a tuple with the left hand side
    /// and right hand side in order.
    #[builtin(expr_as_assign)]
    // docs:start:as_assign
    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}
    // docs:end:as_assign

    /// If this expression is a binary operator operation \`<lhs> <op> <rhs>\`,
    /// return the left-hand side, operator, and the right-hand side of the operation.
    #[builtin(expr_as_binary_op)]
    // docs:start:as_binary_op
    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}
    // docs:end:as_binary_op

    /// If this expression is a block \`{ stmt1; stmt2; ...; stmtN }\`, return
    /// a slice containing each statement.
    #[builtin(expr_as_block)]
    // docs:start:as_block
    pub comptime fn as_block(self) -> Option<[Expr]> {}
    // docs:end:as_block

    /// If this expression is a boolean literal, return that literal.
    #[builtin(expr_as_bool)]
    // docs:start:as_bool
    pub comptime fn as_bool(self) -> Option<bool> {}
    // docs:end:as_bool

    /// If this expression is a cast expression \`expr as type\`, returns the casted
    /// expression and the type to cast to.
    // docs:start:as_cast
    #[builtin(expr_as_cast)]
    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}
    // docs:end:as_cast

    /// If this expression is a \`comptime { stmt1; stmt2; ...; stmtN }\` block,
    /// return each statement in the block.
    #[builtin(expr_as_comptime)]
    // docs:start:as_comptime
    pub comptime fn as_comptime(self) -> Option<[Expr]> {}
    // docs:end:as_comptime

    /// If this expression is a constructor \`Type { field1: expr1, ..., fieldN: exprN }\`,
    /// return the type and the fields.
    #[builtin(expr_as_constructor)]
    // docs:start:as_constructor
    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}
    // docs:end:as_constructor

    /// If this expression is a for statement over a single expression, return the identifier,
    /// the expression and the for loop body.
    #[builtin(expr_as_for)]
    // docs:start:as_for
    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}
    // docs:end:as_for

    /// If this expression is a for statement over a range, return the identifier,
    /// the range start, the range end and the for loop body.
    #[builtin(expr_as_for_range)]
    // docs:start:as_for_range
    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}
    // docs:end:as_for_range

    /// If this expression is a function call \`foo(arg1, ..., argN)\`, return
    /// the function and a slice of each argument.
    #[builtin(expr_as_function_call)]
    // docs:start:as_function_call
    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}
    // docs:end:as_function_call

    /// If this expression is an \`if condition { then_branch } else { else_branch }\`,
    /// return the condition, then branch, and else branch. If there is no else branch,
    /// \`None\` is returned for that branch instead.
    #[builtin(expr_as_if)]
    // docs:start:as_if
    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}
    // docs:end:as_if

    /// If this expression is an index into an array \`array[index]\`, return the
    /// array and the index.
    #[builtin(expr_as_index)]
    // docs:start:as_index
    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}
    // docs:end:as_index

    /// If this expression is an integer literal, return the integer as a field
    /// as well as whether the integer is negative (true) or not (false).
    #[builtin(expr_as_integer)]
    // docs:start:as_integer
    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}
    // docs:end:as_integer

    /// If this expression is a lambda, returns the parameters, return type and body.
    #[builtin(expr_as_lambda)]
    // docs:start:as_lambda
    pub comptime fn as_lambda(
        self,
    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}
    // docs:end:as_lambda

    /// If this expression is a let statement, returns the let pattern as an \`Expr\`,
    /// the optional type annotation, and the assigned expression.
    #[builtin(expr_as_let)]
    // docs:start:as_let
    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}
    // docs:end:as_let

    /// If this expression is a member access \`foo.bar\`, return the struct/tuple
    /// expression and the field. The field will be represented as a quoted value.
    #[builtin(expr_as_member_access)]
    // docs:start:as_member_access
    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}
    // docs:end:as_member_access

    /// If this expression is a method call \`foo.bar::<generic1, ..., genericM>(arg1, ..., argN)\`, return
    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.
    #[builtin(expr_as_method_call)]
    // docs:start:as_method_call
    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}
    // docs:end:as_method_call

    /// If this expression is a repeated element array \`[elem; length]\`, return
    /// the repeated element and the length expressions.
    #[builtin(expr_as_repeated_element_array)]
    // docs:start:as_repeated_element_array
    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}
    // docs:end:as_repeated_element_array

    /// If this expression is a repeated element slice \`[elem; length]\`, return
    /// the repeated element and the length expressions.
    #[builtin(expr_as_repeated_element_slice)]
    // docs:start:as_repeated_element_slice
    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}
    // docs:end:as_repeated_element_slice

    /// If this expression is a slice literal \`&[elem1, ..., elemN]\`,
    /// return each element of the slice.
    #[builtin(expr_as_slice)]
    // docs:start:as_slice
    pub comptime fn as_slice(self) -> Option<[Expr]> {}
    // docs:end:as_slice

    /// If this expression is a tuple \`(field1, ..., fieldN)\`,
    /// return each element of the tuple.
    #[builtin(expr_as_tuple)]
    // docs:start:as_tuple
    pub comptime fn as_tuple(self) -> Option<[Expr]> {}
    // docs:end:as_tuple

    /// If this expression is a unary operation \`<op> <rhs>\`,
    /// return the unary operator as well as the right-hand side expression.
    #[builtin(expr_as_unary_op)]
    // docs:start:as_unary_op
    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}
    // docs:end:as_unary_op

    /// If this expression is an \`unsafe { stmt1; ...; stmtN }\` block,
    /// return each statement inside in a slice.
    #[builtin(expr_as_unsafe)]
    // docs:start:as_unsafe
    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}
    // docs:end:as_unsafe

    /// Returns \`true\` if this expression is trailed by a semicolon.
    ///
    /// Example:
    ///
    /// \`\`\`noir
    /// comptime {
    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();
    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();
    ///
    ///     assert(expr1.as_binary_op().is_some());
    ///     assert(expr2.as_binary_op().is_some());
    ///
    ///     assert(!expr1.has_semicolon());
    ///     assert(expr2.has_semicolon());
    /// }
    /// \`\`\`
    #[builtin(expr_has_semicolon)]
    // docs:start:has_semicolon
    pub comptime fn has_semicolon(self) -> bool {}
    // docs:end:has_semicolon

    /// Returns \`true\` if this expression is \`break\`.
    #[builtin(expr_is_break)]
    // docs:start:is_break
    pub comptime fn is_break(self) -> bool {}
    // docs:end:is_break

    /// Returns \`true\` if this expression is \`continue\`.
    #[builtin(expr_is_continue)]
    // docs:start:is_continue
    pub comptime fn is_continue(self) -> bool {}
    // docs:end:is_continue

    /// Applies a mapping function to this expression and to all of its sub-expressions.
    /// \`f\` will be applied to each sub-expression first, then applied to the expression itself.
    ///
    /// This happens recursively for every expression within \`self\`.
    ///
    /// For example, calling \`modify\` on \`(&[1], &[2, 3])\` with an \`f\` that returns \`Option::some\`
    /// for expressions that are integers, doubling them, would return \`(&[2], &[4, 6])\`.
    // docs:start:modify
    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {
        // docs:end:modify
        let result = modify_array(self, f);
        let result = result.or_else(|| modify_assert(self, f));
        let result = result.or_else(|| modify_assert_eq(self, f));
        let result = result.or_else(|| modify_assign(self, f));
        let result = result.or_else(|| modify_binary_op(self, f));
        let result = result.or_else(|| modify_block(self, f));
        let result = result.or_else(|| modify_cast(self, f));
        let result = result.or_else(|| modify_comptime(self, f));
        let result = result.or_else(|| modify_constructor(self, f));
        let result = result.or_else(|| modify_if(self, f));
        let result = result.or_else(|| modify_index(self, f));
        let result = result.or_else(|| modify_for(self, f));
        let result = result.or_else(|| modify_for_range(self, f));
        let result = result.or_else(|| modify_lambda(self, f));
        let result = result.or_else(|| modify_let(self, f));
        let result = result.or_else(|| modify_function_call(self, f));
        let result = result.or_else(|| modify_member_access(self, f));
        let result = result.or_else(|| modify_method_call(self, f));
        let result = result.or_else(|| modify_repeated_element_array(self, f));
        let result = result.or_else(|| modify_repeated_element_slice(self, f));
        let result = result.or_else(|| modify_slice(self, f));
        let result = result.or_else(|| modify_tuple(self, f));
        let result = result.or_else(|| modify_unary_op(self, f));
        let result = result.or_else(|| modify_unsafe(self, f));
        if result.is_some() {
            let result = result.unwrap_unchecked();
            let modified = f(result);
            modified.unwrap_or(result)
        } else {
            f(self).unwrap_or(self)
        }
    }

    /// Returns this expression as a \`Quoted\` value. It's the same as \`quote { $self }\`.
    // docs:start:quoted
    pub comptime fn quoted(self) -> Quoted {
        // docs:end:quoted
        quote { $self }
    }

    /// Resolves and type-checks this expression and returns the result as a \`TypedExpr\`.
    ///
    /// The \`in_function\` argument specifies where the expression is resolved:
    /// - If it's \`none\`, the expression is resolved in the function where \`resolve\` was called
    /// - If it's \`some\`, the expression is resolved in the given function
    ///
    /// If any names used by this expression are not in scope or if there are any type errors,
    /// this will give compiler errors as if the expression was written directly into
    /// the current \`comptime\` function.
    #[builtin(expr_resolve)]
    // docs:start:resolve
    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}
    // docs:end:resolve
}

comptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_array().map(|exprs| {
        let exprs = modify_expressions(exprs, f);
        new_array(exprs)
    })
}

comptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_assert().map(|(predicate, msg)| {
        let predicate = predicate.modify(f);
        let msg = msg.map(|msg| msg.modify(f));
        new_assert(predicate, msg)
    })
}

comptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_assert_eq().map(|(lhs, rhs, msg)| {
        let lhs = lhs.modify(f);
        let rhs = rhs.modify(f);
        let msg = msg.map(|msg| msg.modify(f));
        new_assert_eq(lhs, rhs, msg)
    })
}

comptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_assign().map(|expr| {
        let (lhs, rhs) = expr;
        let lhs = lhs.modify(f);
        let rhs = rhs.modify(f);
        new_assign(lhs, rhs)
    })
}

comptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_binary_op().map(|(lhs, op, rhs)| {
        let lhs = lhs.modify(f);
        let rhs = rhs.modify(f);
        new_binary_op(lhs, op, rhs)
    })
}

comptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_block().map(|exprs| {
        let exprs = modify_expressions(exprs, f);
        new_block(exprs)
    })
}

comptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_cast().map(|(expr, typ)| {
        let expr = expr.modify(f);
        new_cast(expr, typ)
    })
}

comptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_comptime().map(|exprs| {
        let exprs = exprs.map(|expr| expr.modify(f));
        new_comptime(exprs)
    })
}

comptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_constructor().map(|(typ, fields)| {
        let fields = fields.map(|(name, value)| (name, value.modify(f)));
        new_constructor(typ, fields)
    })
}

comptime fn modify_function_call<Env>(
    expr: Expr,
    f: fn[Env](Expr) -> Option<Expr>,
) -> Option<Expr> {
    expr.as_function_call().map(|(function, arguments)| {
        let function = function.modify(f);
        let arguments = arguments.map(|arg| arg.modify(f));
        new_function_call(function, arguments)
    })
}

comptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_if().map(|(condition, consequence, alternative)| {
        let condition = condition.modify(f);
        let consequence = consequence.modify(f);
        let alternative = alternative.map(|alternative| alternative.modify(f));
        new_if(condition, consequence, alternative)
    })
}

comptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_index().map(|(object, index)| {
        let object = object.modify(f);
        let index = index.modify(f);
        new_index(object, index)
    })
}

comptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_for().map(|(identifier, array, body)| {
        let array = array.modify(f);
        let body = body.modify(f);
        new_for(identifier, array, body)
    })
}

comptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_for_range().map(|(identifier, from, to, body)| {
        let from = from.modify(f);
        let to = to.modify(f);
        let body = body.modify(f);
        new_for_range(identifier, from, to, body)
    })
}

comptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_lambda().map(|(params, return_type, body)| {
        let params = params.map(|(name, typ)| (name.modify(f), typ));
        let body = body.modify(f);
        new_lambda(params, return_type, body)
    })
}

comptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_let().map(|(pattern, typ, expr)| {
        let pattern = pattern.modify(f);
        let expr = expr.modify(f);
        new_let(pattern, typ, expr)
    })
}

comptime fn modify_member_access<Env>(
    expr: Expr,
    f: fn[Env](Expr) -> Option<Expr>,
) -> Option<Expr> {
    expr.as_member_access().map(|(object, name)| {
        let object = object.modify(f);
        new_member_access(object, name)
    })
}

comptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_method_call().map(|(object, name, generics, arguments)| {
        let object = object.modify(f);
        let arguments = arguments.map(|arg| arg.modify(f));
        new_method_call(object, name, generics, arguments)
    })
}

comptime fn modify_repeated_element_array<Env>(
    expr: Expr,
    f: fn[Env](Expr) -> Option<Expr>,
) -> Option<Expr> {
    expr.as_repeated_element_array().map(|(expr, length)| {
        let expr = expr.modify(f);
        let length = length.modify(f);
        new_repeated_element_array(expr, length)
    })
}

comptime fn modify_repeated_element_slice<Env>(
    expr: Expr,
    f: fn[Env](Expr) -> Option<Expr>,
) -> Option<Expr> {
    expr.as_repeated_element_slice().map(|(expr, length)| {
        let expr = expr.modify(f);
        let length = length.modify(f);
        new_repeated_element_slice(expr, length)
    })
}

comptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_slice().map(|exprs| {
        let exprs = modify_expressions(exprs, f);
        new_slice(exprs)
    })
}

comptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_tuple().map(|exprs| {
        let exprs = modify_expressions(exprs, f);
        new_tuple(exprs)
    })
}

comptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_unary_op().map(|(op, rhs)| {
        let rhs = rhs.modify(f);
        new_unary_op(op, rhs)
    })
}

comptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {
    expr.as_unsafe().map(|exprs| {
        let exprs = exprs.map(|expr| expr.modify(f));
        new_unsafe(exprs)
    })
}

comptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {
    exprs.map(|expr| expr.modify(f))
}

comptime fn new_array(exprs: [Expr]) -> Expr {
    let exprs = join_expressions(exprs, quote { , });
    quote { [$exprs]}.as_expr().unwrap()
}

comptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {
    if msg.is_some() {
        let msg = msg.unwrap();
        quote { assert($predicate, $msg) }.as_expr().unwrap()
    } else {
        quote { assert($predicate) }.as_expr().unwrap()
    }
}

comptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {
    if msg.is_some() {
        let msg = msg.unwrap();
        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()
    } else {
        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()
    }
}

comptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {
    quote { $lhs = $rhs }.as_expr().unwrap()
}

comptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {
    let op = op.quoted();
    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()
}

comptime fn new_block(exprs: [Expr]) -> Expr {
    let exprs = join_expressions(exprs, quote { ; });
    quote { { $exprs }}.as_expr().unwrap()
}

comptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {
    quote { ($expr) as $typ }.as_expr().unwrap()
}

comptime fn new_comptime(exprs: [Expr]) -> Expr {
    let exprs = join_expressions(exprs, quote { ; });
    quote { comptime { $exprs }}.as_expr().unwrap()
}

comptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {
    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });
    quote { $typ { $fields }}.as_expr().unwrap()
}

comptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {
    if alternative.is_some() {
        let alternative = alternative.unwrap();
        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()
    } else {
        quote { if $condition { $consequence } }.as_expr().unwrap()
    }
}

comptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {
    quote { for $identifier in $array { $body } }.as_expr().unwrap()
}

comptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {
    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()
}

comptime fn new_index(object: Expr, index: Expr) -> Expr {
    quote { $object[$index] }.as_expr().unwrap()
}

comptime fn new_lambda(
    params: [(Expr, Option<UnresolvedType>)],
    return_type: Option<UnresolvedType>,
    body: Expr,
) -> Expr {
    let params = params
        .map(|(name, typ)| {
            if typ.is_some() {
                let typ = typ.unwrap();
                quote { $name: $typ }
            } else {
                quote { $name }
            }
        })
        .join(quote { , });

    if return_type.is_some() {
        let return_type = return_type.unwrap();
        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()
    } else {
        quote { |$params| { $body } }.as_expr().unwrap()
    }
}

comptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {
    if typ.is_some() {
        let typ = typ.unwrap();
        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()
    } else {
        quote { let $pattern = $expr; }.as_expr().unwrap()
    }
}

comptime fn new_member_access(object: Expr, name: Quoted) -> Expr {
    quote { $object.$name }.as_expr().unwrap()
}

comptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {
    let arguments = join_expressions(arguments, quote { , });

    quote { $function($arguments) }.as_expr().unwrap()
}

comptime fn new_method_call(
    object: Expr,
    name: Quoted,
    generics: [UnresolvedType],
    arguments: [Expr],
) -> Expr {
    let arguments = join_expressions(arguments, quote { , });

    if generics.len() == 0 {
        quote { $object.$name($arguments) }.as_expr().unwrap()
    } else {
        let generics = generics.map(|generic| quote { $generic }).join(quote { , });
        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()
    }
}

comptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {
    quote { [$expr; $length] }.as_expr().unwrap()
}

comptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {
    quote { &[$expr; $length] }.as_expr().unwrap()
}

comptime fn new_slice(exprs: [Expr]) -> Expr {
    let exprs = join_expressions(exprs, quote { , });
    quote { &[$exprs]}.as_expr().unwrap()
}

comptime fn new_tuple(exprs: [Expr]) -> Expr {
    let exprs = join_expressions(exprs, quote { , });
    quote { ($exprs) }.as_expr().unwrap()
}

comptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {
    let op = op.quoted();
    quote { $op($rhs) }.as_expr().unwrap()
}

comptime fn new_unsafe(exprs: [Expr]) -> Expr {
    let exprs = join_expressions(exprs, quote { ; });
    quote { 
        // Safety: generated by macro
        unsafe { $exprs }
    }
        .as_expr()
        .unwrap()
}

comptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {
    exprs.map(|expr| expr.quoted()).join(separator)
}
`},42:{path:"std/option.nr",source:`use crate::cmp::{Eq, Ord, Ordering};
use crate::default::Default;
use crate::hash::{Hash, Hasher};

pub struct Option<T> {
    _is_some: bool,
    _value: T,
}

impl<T> Option<T> {
    /// Constructs a None value
    pub fn none() -> Self {
        Self { _is_some: false, _value: crate::mem::zeroed() }
    }

    /// Constructs a Some wrapper around the given value
    pub fn some(_value: T) -> Self {
        Self { _is_some: true, _value }
    }

    /// True if this Option is None
    pub fn is_none(self) -> bool {
        !self._is_some
    }

    /// True if this Option is Some
    pub fn is_some(self) -> bool {
        self._is_some
    }

    /// Asserts \`self.is_some()\` and returns the wrapped value.
    pub fn unwrap(self) -> T {
        assert(self._is_some);
        self._value
    }

    /// Returns the inner value without asserting \`self.is_some()\`
    /// Note that if \`self\` is \`None\`, there is no guarantee what value will be returned,
    /// only that it will be of type \`T\`.
    pub fn unwrap_unchecked(self) -> T {
        self._value
    }

    /// Returns the wrapped value if \`self.is_some()\`. Otherwise, returns the given default value.
    pub fn unwrap_or(self, default: T) -> T {
        if self._is_some {
            self._value
        } else {
            default
        }
    }

    /// Returns the wrapped value if \`self.is_some()\`. Otherwise, calls the given function to return
    /// a default value.
    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {
        if self._is_some {
            self._value
        } else {
            default()
        }
    }

    /// Asserts \`self.is_some()\` with a provided custom message and returns the contained \`Some\` value
    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {
        assert(self.is_some(), message);
        self._value
    }

    /// If self is \`Some(x)\`, this returns \`Some(f(x))\`. Otherwise, this returns \`None\`.
    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {
        if self._is_some {
            Option::some(f(self._value))
        } else {
            Option::none()
        }
    }

    /// If self is \`Some(x)\`, this returns \`f(x)\`. Otherwise, this returns the given default value.
    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {
        if self._is_some {
            f(self._value)
        } else {
            default
        }
    }

    /// If self is \`Some(x)\`, this returns \`f(x)\`. Otherwise, this returns \`default()\`.
    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {
        if self._is_some {
            f(self._value)
        } else {
            default()
        }
    }

    /// Returns None if self is None. Otherwise, this returns \`other\`.
    pub fn and(self, other: Self) -> Self {
        if self.is_none() {
            Option::none()
        } else {
            other
        }
    }

    /// If self is None, this returns None. Otherwise, this calls the given function
    /// with the Some value contained within self, and returns the result of that call.
    ///
    /// In some languages this function is called \`flat_map\` or \`bind\`.
    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {
        if self._is_some {
            f(self._value)
        } else {
            Option::none()
        }
    }

    /// If self is Some, return self. Otherwise, return \`other\`.
    pub fn or(self, other: Self) -> Self {
        if self._is_some {
            self
        } else {
            other
        }
    }

    /// If self is Some, return self. Otherwise, return \`default()\`.
    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {
        if self._is_some {
            self
        } else {
            default()
        }
    }

    // If only one of the two Options is Some, return that option.
    // Otherwise, if both options are Some or both are None, None is returned.
    pub fn xor(self, other: Self) -> Self {
        if self._is_some {
            if other._is_some {
                Option::none()
            } else {
                self
            }
        } else if other._is_some {
            other
        } else {
            Option::none()
        }
    }

    /// Returns \`Some(x)\` if self is \`Some(x)\` and \`predicate(x)\` is true.
    /// Otherwise, this returns \`None\`
    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {
        if self._is_some {
            if predicate(self._value) {
                self
            } else {
                Option::none()
            }
        } else {
            Option::none()
        }
    }

    /// Flattens an Option<Option<T>> into a Option<T>.
    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.
    pub fn flatten(option: Option<Option<T>>) -> Option<T> {
        if option._is_some {
            option._value
        } else {
            Option::none()
        }
    }
}

impl<T> Default for Option<T> {
    fn default() -> Self {
        Option::none()
    }
}

impl<T> Eq for Option<T>
where
    T: Eq,
{
    fn eq(self, other: Self) -> bool {
        if self._is_some == other._is_some {
            if self._is_some {
                self._value == other._value
            } else {
                true
            }
        } else {
            false
        }
    }
}

impl<T> Hash for Option<T>
where
    T: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self._is_some.hash(state);
        if self._is_some {
            self._value.hash(state);
        }
    }
}

// For this impl we're declaring Option::none < Option::some
impl<T> Ord for Option<T>
where
    T: Ord,
{
    fn cmp(self, other: Self) -> Ordering {
        if self._is_some {
            if other._is_some {
                self._value.cmp(other._value)
            } else {
                Ordering::greater()
            }
        } else if other._is_some {
            Ordering::less()
        } else {
            Ordering::equal()
        }
    }
}
`},43:{path:"std/panic.nr",source:`pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {
    assert(false, message);
    crate::mem::zeroed()
}
`},50:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/account/schnorr_account_contract/src/main.nr",source:`mod public_key_note;

// Account contract that uses Schnorr signatures for authentication.
// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.
use dep::aztec::macros::aztec;

#[aztec]
pub contract SchnorrAccount {
    use dep::authwit::{
        account::AccountActions,
        auth::{compute_authwit_message_hash, compute_authwit_nullifier},
        auth_witness::get_auth_witness,
        entrypoint::{app::AppPayload, fee::FeePayload},
    };
    use dep::aztec::hash::compute_siloed_nullifier;
    use dep::aztec::macros::{
        functions::{initializer, noinitcheck, private, utility, view},
        storage::storage,
    };
    use dep::aztec::messages::logs::note::encode_and_encrypt_note;
    use dep::aztec::oracle::get_nullifier_membership_witness::get_low_nullifier_membership_witness;
    use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateImmutable};

    use crate::public_key_note::PublicKeyNote;

    #[storage]
    struct Storage<Context> {
        // docs:start:public_key
        signing_public_key: PrivateImmutable<PublicKeyNote, Context>,
        // docs:end:public_key
    }

    // Constructs the contract
    #[private]
    #[initializer]
    fn constructor(signing_pub_key_x: Field, signing_pub_key_y: Field) {
        let this = context.this_address();
        let pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);
        storage.signing_public_key.initialize(pub_key_note).emit(encode_and_encrypt_note(
            &mut context,
            this,
            this,
        ));
    }

    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts file
    // using noinitcheck is an optimization, it reduces gates by omitting a check that the contract has been initialized
    #[private]
    #[noinitcheck]
    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {
        let actions = AccountActions::init(&mut context, is_valid_impl);
        actions.entrypoint(app_payload, fee_payload, cancellable);
    }

    #[private]
    #[noinitcheck]
    #[view]
    fn verify_private_authwit(inner_hash: Field) -> Field {
        let actions = AccountActions::init(&mut context, is_valid_impl);
        actions.verify_private_authwit(inner_hash)
    }

    #[contract_library_method]
    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {
        // docs:start:is_valid_impl
        // Load public key from storage
        let storage = Storage::init(context);
        let public_key = storage.signing_public_key.get_note();

        // Load auth witness
        // Safety: The witness is only used as a "magical value" that makes the signature verification below pass.
        // Hence it's safe.
        let witness: [Field; 64] = unsafe { get_auth_witness(outer_hash) };
        let mut signature: [u8; 64] = [0; 64];
        for i in 0..64 {
            signature[i] = witness[i] as u8;
        }

        let pub_key = std::embedded_curve_ops::EmbeddedCurvePoint {
            x: public_key.x,
            y: public_key.y,
            is_infinite: false,
        };
        // Verify signature of the payload bytes
        schnorr::verify_signature(pub_key, signature, outer_hash.to_be_bytes::<32>())
        // docs:end:is_valid_impl
    }

    /**
    * @notice Helper function to check validity of private authwitnesses
    * @param consumer The address of the consumer of the message
    * @param message_hash The message hash of the message to check the validity
    * @return True if the message_hash can be consumed, false otherwise
    */
    #[utility]
    unconstrained fn lookup_validity(consumer: AztecAddress, inner_hash: Field) -> bool {
        let public_key = storage.signing_public_key.view_note();

        let message_hash = compute_authwit_message_hash(
            consumer,
            context.chain_id(),
            context.version(),
            inner_hash,
        );

        let witness: [Field; 64] = get_auth_witness(message_hash);
        let mut signature: [u8; 64] = [0; 64];
        for i in 0..64 {
            signature[i] = witness[i] as u8;
        }
        let pub_key = std::embedded_curve_ops::EmbeddedCurvePoint {
            x: public_key.x,
            y: public_key.y,
            is_infinite: false,
        };
        let valid_in_private =
            schnorr::verify_signature(pub_key, signature, message_hash.to_be_bytes::<32>());

        // Compute the nullifier and check if it is spent
        // This will BLINDLY TRUST the oracle, but the oracle is us, and
        // it is not as part of execution of the contract, so we are good.
        let nullifier = compute_authwit_nullifier(context.this_address(), inner_hash);
        let siloed_nullifier = compute_siloed_nullifier(consumer, nullifier);
        let lower_wit =
            get_low_nullifier_membership_witness(context.block_number(), siloed_nullifier);
        let is_spent = lower_wit.leaf_preimage.nullifier == siloed_nullifier;

        !is_spent & valid_in_private
    }
}
`},52:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/account.nr",source:`use dep::aztec::{
    context::PrivateContext,
    protocol_types::{
        constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},
        hash::poseidon2_hash_with_separator,
        traits::Hash,
    },
};

use crate::auth::{compute_authwit_message_hash, IS_VALID_SELECTOR};
use crate::entrypoint::{app::AppPayload, fee::FeePayload};

pub struct AccountActions<Context> {
    context: Context,
    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,
}

impl<Context> AccountActions<Context> {
    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {
        AccountActions { context, is_valid_impl }
    }
}

/**
 * An implementation of the Account Action struct for the private context.
 *
 * Implements logic to verify authorization and execute payloads.
 */
impl AccountActions<&mut PrivateContext> {

    /**
     * Verifies that the \`app_hash\` and \`fee_hash\` are authorized and then executes them.
     *
     * Executes the \`fee_payload\` and \`app_payload\` in sequence.
     * Will execute the \`fee_payload\` as part of the setup, and then enter the app phase.
     *
     * @param app_payload The payload that contains the calls to be executed in the app phase.
     * @param fee_payload The payload that contains the calls to be executed in the setup phase.
     */
    // docs:start:entrypoint
    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {
        let valid_fn = self.is_valid_impl;

        let combined_payload_hash = poseidon2_hash_with_separator(
            [app_payload.hash(), fee_payload.hash()],
            GENERATOR_INDEX__COMBINED_PAYLOAD,
        );
        assert(valid_fn(self.context, combined_payload_hash));

        fee_payload.execute_calls(self.context);
        self.context.end_setup();
        app_payload.execute_calls(self.context);
        if cancellable {
            let tx_nullifier =
                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);
            self.context.push_nullifier(tx_nullifier);
        }
    }
    // docs:end:entrypoint

    /**
     * Verifies that the \`msg_sender\` is authorized to consume \`inner_hash\` by the account.
     *
     * Computes the \`message_hash\` using the \`msg_sender\`, \`chain_id\`, \`version\` and \`inner_hash\`.
     * Then executes the \`is_valid_impl\` function to verify that the message is authorized.
     *
     * Will revert if the message is not authorized.
     *
     * @param inner_hash The hash of the message that the \`msg_sender\` is trying to consume.
     */
    // docs:start:verify_private_authwit
    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {
        // The \`inner_hash\` is "siloed" with the \`msg_sender\` to ensure that only it can
        // consume the message.
        // This ensures that contracts cannot consume messages that are not intended for them.
        let message_hash = compute_authwit_message_hash(
            self.context.msg_sender(),
            self.context.chain_id(),
            self.context.version(),
            inner_hash,
        );
        let valid_fn = self.is_valid_impl;
        assert(valid_fn(self.context, message_hash) == true, "Message not authorized by account");
        IS_VALID_SELECTOR
    }
    // docs:end:verify_private_authwit
}
`},53:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth.nr",source:`use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};
use dep::aztec::protocol_types::{
    abis::function_selector::FunctionSelector,
    address::AztecAddress,
    constants::{
        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,
        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,
    },
    hash::poseidon2_hash_with_separator,
    traits::ToField,
};

/**
 * Authenticaion witness helper library
 *
 * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties
 * (e.g. protocols or other users) to execute an action on their behalf.
 *
 * This library provides helper functions to manage such witnesses.
 * The authentication witness, is some "witness" (data) that authenticates a \`message_hash\`.
 * The simplest example of an authentication witness, is a signature. The signature is the "evidence",
 * that the signer has seen the message, agrees with it, and has allowed it.
 * It does not need to be a signature. It could be any kind of "proof" that the message is allowed.
 * Another proof could be knowing some kind of secret, or having some kind of "token" that allows the message.
 *
 * The \`message_hash\` is a hash of the following structure:
 * hash(consumer, chain_id, version, inner_hash)
 * - consumer: the address of the contract that is "consuming" the message,
 * - chain_id: the chain id of the chain that the message is being consumed on,
 * - version: the version of the chain that the message is being consumed on,
 * - inner_hash: the hash of the "inner" message that is being consumed, this is the "actual" message or action.
 *
 * While the \`inner_hash\` could be anything, such as showing you signed a specific message, it will often be
 * a hash of the "action" to approve, along with who made the call. As part of this library, we provide a few
 * helper functions to deal with such messages.
 *
 * For example, we provide helper function that is used for checking that the message is an encoding of the current call.
 * This can be used to let some contract "allow" another contract to act on its behalf, as long as it can
 * show that it is acting on behalf of the contract.
 *
 * If we take a case of allowing a contract to transfer tokens on behalf of an account, the \`inner_hash\` can be
 * derived as:
 * inner_hash = hash(caller, "transfer", hash(to, amount))
 *
 * Where the \`caller\` would be the address of the contract that is trying to transfer the tokens, and \`to\` and \`amount\`
 * the arguments for the transfer.
 *
 * Note that we have both a \`caller\` and a \`consumer\`, the \`consumer\` will be the contract that is consuming the message,
 * in the case of the transfer, it would be the \`Token\` contract itself, while the caller, will be the actor that is
 * allowed to transfer the tokens.
 *
 *
 * The authentication mechanism works differently in public and private contexts. In private, we recall that everything
 * is executed on the user's device, so we can use \`oracles\` to "ask" the user (not contract) for information. In public
 * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a "registry"
 * to store the messages that we have approved.
 *
 * A simple example would be a "token" that is being "pulled" from one account into another. We will first outline
 * how this would look in private, and then in public later.
 *
 * Say that a user \`Alice\` wants to deposit some tokens into a DeFi protocol (say a DEX).
 * \`Alice\` would make a \`deposit\` transaction, that she is executing using her account contract.
 * The account would call the \`DeFi\` contract to execute \`deposit\`, which would try to pull funds from the \`Token\`
 * contract. Since the \`DeFi\` contract is trying to pull funds from an account that is not its own, it needs to
 * convince the \`Token\` contract that it is allowed to do so.
 *
 * This is where the authentication witness comes in The \`Token\` contract computes a \`message_hash\` from the
 * \`transfer\` call, and then asks \`Alice Account\` contract to verify that the \`DeFi\` contract is allowed to
 * execute that call.
 *
 * \`Alice Account\` contract can then ask \`Alice\` if she wants to allow the \`DeFi\` contract to pull funds from her
 * account. If she does, she will sign the \`message_hash\` and return the signature to the \`Alice Account\` which
 * will validate it and return success to the \`Token\` contract which will then allow the \`DeFi\` contract to pull
 * funds from \`Alice\`.
 *
 * To ensure that the same "approval" cannot be used multiple times, we also compute a \`nullifier\` for the
 * authentication witness, and emit it from the \`Token\` contract (consumer).
 *
 * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.
 *
 *
 *  Person          Contract              Contract               Contract
 *  Alice          Alice Account          Token                   DeFi
 *   |                  |                  |                      |
 *   | Defi.deposit(Token, 1000)           |                      |
 *   |----------------->|                  |                      |
 *   |                  | deposit(Token, 1000)                    |
 *   |                  |---------------------------------------->|
 *   |                  |                  |                      |
 *   |                  |                  | transfer(Alice, Defi, 1000)
 *   |                  |                  |<---------------------|
 *   |                  |                  |                      |
 *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)
 *   |                  |<-----------------|                      |
 *   |                  |                  |                      |
 *   | Please give me AuthWit for DeFi     |                      |
 *   | calling transfer(Alice, Defi, 1000) |                      |
 *   |<-----------------|                  |                      |
 *   |                  |                  |                      |
 *   |                  |                  |                      |
 *   | AuthWit for transfer(Alice, Defi, 1000)                    |
 *   |----------------->|                  |                      |
 *   |                  | AuthWit validity |                      |
 *   |                  |----------------->|                      |
 *   |                  |                  |                      |
 *   |                  |       throw if invalid AuthWit          |
 *   |                  |                  |                      |
 *   |                  |       emit AuthWit nullifier            |
 *   |                  |                  |                      |
 *   |                  |       transfer(Alice, Defi, 1000)       |
 *   |                  |                  |                      |
 *   |                  |                  |                      |
 *   |                  |                  | success              |
 *   |                  |                  |--------------------->|
 *   |                  |                  |                      |
 *   |                  |                  |                      |
 *   |                  |                  |           deposit(Token, 1000)
 *   |                  |                  |                      |
 *   |                  |                  |                      |
 *
 *
 * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store
 * the messages that we have approved.
 *
 * To approve a message, \`Alice Account\` can make a \`set_authorized\` call to the registry, to set a \`message_hash\`
 * as authorized. This is essentially a mapping from \`message_hash\` to \`true\` for \`Alice Contract\`. Every account
 * has its own map in the registry, so \`Alice\` cannot approve a message for \`Bob\`.
 *
 * The \`Token\` contract can then try to "spend" the approval by calling \`consume\` on the registry. If the message
 * was approved, the value is updated to \`false\`, and we return the success flag. For more information on the
 * registry, see \`main.nr\` in \`auth_registry_contract\`.
 *
 * Person          Contract              Contract            Contract               Contract
 * Alice          Alice Account          Registry             Token                   DeFi
 *   |                  |                    |                   |                      |
 *   | Registry.set_authorized(..., true)    |                   |                      |
 *   |----------------->|                    |                   |                      |
 *   |                  | set_authorized(..., true)              |                      |
 *   |                  |------------------->|                   |                      |
 *   |                  |                    |                   |                      |
 *   |                  |         set authorized to true         |                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   |                      |
 *   | Defi.deposit(Token, 1000)             |                   |                      |
 *   |----------------->|                    |                   |                      |
 *   |                  | deposit(Token, 1000)                   |                      |
 *   |                  |-------------------------------------------------------------->|
 *   |                  |                    |                   |                      |
 *   |                  |                    |              transfer(Alice, Defi, 1000) |
 *   |                  |                    |                   |<---------------------|
 *   |                  |                    |                   |                      |
 *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)
 *   |                  |                    |<------------------|                      |
 *   |                  |                    |                   |                      |
 *   |                  |          throw if invalid AuthWit      |                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   |                      |
 *   |                  |           set authorized to false      |                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    | AuthWit validity  |                      |
 *   |                  |                    |------------------>|                      |
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   | transfer(Alice, Defi, 1000)
 *   |                  |                    |                   |<-------------------->|
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   | success              |
 *   |                  |                    |                   |--------------------->|
 *   |                  |                    |                   |                      |
 *   |                  |                    |                   |     deposit(Token, 1000)
 *   |                  |                    |                   |                      |
 *
 *
 * --- FAQ ---
 * Q:   Why are we using a success flag of \`poseidon2_hash_bytes("IS_VALID()")\` instead of just returning a boolean?
 * A:   We want to make sure that we don't accidentally return \`true\` if there is a collision in the function selector.
 *      By returning a hash of \`IS_VALID()\`, it becomes very unlikely that there is both a collision and we return
 *      a success flag.
 *
 * Q:   Why are we using static calls?
 * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it
 *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.
 *
 * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?
 * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be
 *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the
 *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.
 *
 * Q:   Why is the chain id and the version part of the message hash?
 * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific
 *      chain to avoid a case where the same message could be used across multiple chains.
 */

pub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes("IS_VALID()")

/**
 * Assert that \`on_behalf_of\` has authorized the current call with a valid authentication witness
 *
 * Compute the \`inner_hash\` using the \`msg_sender\`, \`selector\` and \`args_hash\` and then make a call out to the
 * \`on_behalf_of\` contract to verify that the \`inner_hash\` is valid.
 *
 * @param on_behalf_of The address that has allegedly authorized the current call
 */
// docs:start:assert_current_call_valid_authwit
pub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {
    let inner_hash = compute_inner_authwit_hash([
        context.msg_sender().to_field(),
        context.selector().to_field(),
        context.args_hash,
    ]);
    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);
}
// docs:end:assert_current_call_valid_authwit

/**
 * Assert that a specific \`inner_hash\` is valid for the \`on_behalf_of\` address
 *
 * Used as an internal function for \`assert_current_call_valid_authwit\` and can be used as a standalone function when
 * the \`inner_hash\` is from a different source, e.g., say a block of text etc.
 *
 * @param on_behalf_of The address that has allegedly authorized the current call
 * @param inner_hash The hash of the message to authorize
 */
pub fn assert_inner_hash_valid_authwit(
    context: &mut PrivateContext,
    on_behalf_of: AztecAddress,
    inner_hash: Field,
) {
    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.
    let result: Field = context
        .static_call_private_function(
            on_behalf_of,
            comptime { FunctionSelector::from_signature("verify_private_authwit(Field)") },
            [inner_hash],
        )
        .get_preimage();
    assert(result == IS_VALID_SELECTOR, "Message not authorized by account");
    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.
    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.
    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);
    context.push_nullifier(nullifier);
}

/**
 * Assert that \`on_behalf_of\` has authorized the current call in the authentication registry
 *
 * Compute the \`inner_hash\` using the \`msg_sender\`, \`selector\` and \`args_hash\` and then make a call out to the
 * \`on_behalf_of\` contract to verify that the \`inner_hash\` is valid.
 *
 * Note that the authentication registry will take the \`msg_sender\` into account as the consumer, so this will only
 * work if the \`msg_sender\` is the same as the \`consumer\` when the \`message_hash\` was inserted into the registry.
 *
 * @param on_behalf_of The address that has allegedly authorized the current call
 */
// docs:start:assert_current_call_valid_authwit_public
pub unconstrained fn assert_current_call_valid_authwit_public(
    context: &mut PublicContext,
    on_behalf_of: AztecAddress,
) {
    let inner_hash = compute_inner_authwit_hash([
        (*context).msg_sender().to_field(),
        (*context).selector().to_field(),
        (*context).get_args_hash(),
    ]);
    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);
}
// docs:end:assert_current_call_valid_authwit_public

/**
 * Assert that \`on_behalf_of\` has authorized a specific \`inner_hash\` in the authentication registry
 *
 * Compute the \`inner_hash\` using the \`msg_sender\`, \`selector\` and \`args_hash\` and then make a call out to the
 * \`on_behalf_of\` contract to verify that the \`inner_hash\` is valid.
 *
 * Note that the authentication registry will take the \`msg_sender\` into account as the consumer, so this will only
 * work if the \`msg_sender\` is the same as the \`consumer\` when the \`message_hash\` was inserted into the registry.
 *
 * @param on_behalf_of The address that has allegedly authorized the \`inner_hash\`
 */
pub unconstrained fn assert_inner_hash_valid_authwit_public(
    context: &mut PublicContext,
    on_behalf_of: AztecAddress,
    inner_hash: Field,
) {
    let results: [Field] = context.call_public_function(
        CANONICAL_AUTH_REGISTRY_ADDRESS,
        comptime { FunctionSelector::from_signature("consume((Field),Field)") },
        [on_behalf_of.to_field(), inner_hash].as_slice(),
        GasOpts::default(),
    );
    assert(results.len() == 1, "Invalid response from registry");
    assert(results[0] == IS_VALID_SELECTOR, "Message not authorized by account");
}

/**
 * Compute the \`message_hash\` from a function call to be used by an authentication witness
 *
 * Useful for when you need a non-account contract to approve during execution. For example if you need a contract
 * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow
 * B to transfer T on its behalf.
 *
 * @param caller The address of the contract that is calling the function, in the example above, this would be B
 * @param consumer The address of the contract that is consuming the message, in the example above, this would be T
 * @param chain_id The chain id of the chain that the message is being consumed on
 * @param version The version of the chain that the message is being consumed on
 * @param selector The function selector of the function that is being called
 * @param args The arguments of the function that is being called
 */
// docs:start:compute_authwit_message_hash_from_call
pub fn compute_authwit_message_hash_from_call<let N: u32>(
    caller: AztecAddress,
    consumer: AztecAddress,
    chain_id: Field,
    version: Field,
    selector: FunctionSelector,
    args: [Field; N],
) -> Field {
    let args_hash = hash_args_array(args);
    let inner_hash =
        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);
    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)
}
// docs:end:compute_authwit_message_hash_from_call

/**
 * Computes the \`inner_hash\` of the authentication witness
 *
 * This is used internally, but also useful in cases where you want to compute the \`inner_hash\` for a specific message
 * that is not necessarily a call, but just some "bytes" or text.
 *
 * @param args The arguments to hash
 */
pub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {
    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)
}

/**
 * Computes the \`authwit_nullifier\` for a specific \`on_behalf_of\` and \`inner_hash\`
 *
 * Using the \`on_behalf_of\` and the \`inner_hash\` to ensure that the nullifier is siloed for a specific \`on_behalf_of\`.
 *
 * @param on_behalf_of The address that has authorized the \`inner_hash\`
 * @param inner_hash The hash of the message to authorize
 */
pub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {
    poseidon2_hash_with_separator(
        [on_behalf_of.to_field(), inner_hash],
        GENERATOR_INDEX__AUTHWIT_NULLIFIER,
    )
}

/**
 * Computes the \`message_hash\` for the authentication witness
 *
 * @param consumer The address of the contract that is consuming the message
 * @param chain_id The chain id of the chain that the message is being consumed on
 * @param version The version of the chain that the message is being consumed on
 * @param inner_hash The hash of the "inner" message that is being consumed
 */
pub fn compute_authwit_message_hash(
    consumer: AztecAddress,
    chain_id: Field,
    version: Field,
    inner_hash: Field,
) -> Field {
    poseidon2_hash_with_separator(
        [consumer.to_field(), chain_id, version, inner_hash],
        GENERATOR_INDEX__AUTHWIT_OUTER,
    )
}

/**
 * Helper function to set the authorization status of a message hash
 *
 * Wraps a public call to the authentication registry to set the authorization status of a \`message_hash\`
 *
 * @param message_hash The hash of the message to authorize
 * @param authorize True if the message should be authorized, false if it should be revoked
 */
pub unconstrained fn set_authorized(
    context: &mut PublicContext,
    message_hash: Field,
    authorize: bool,
) {
    let res = context.call_public_function(
        CANONICAL_AUTH_REGISTRY_ADDRESS,
        comptime { FunctionSelector::from_signature("set_authorized(Field,bool)") },
        [message_hash, authorize as Field].as_slice(),
        GasOpts::default(),
    );
    assert(res.len() == 0);
}

/**
 * Helper function to reject all authwits
 *
 * Wraps a public call to the authentication registry to set the \`reject_all\` flag
 *
 * @param reject True if all authwits should be rejected, false otherwise
 */
pub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {
    let res = context.call_public_function(
        CANONICAL_AUTH_REGISTRY_ADDRESS,
        comptime { FunctionSelector::from_signature("set_reject_all(bool)") },
        [context.this_address().to_field(), reject as Field].as_slice(),
        GasOpts::default(),
    );
    assert(res.len() == 0);
}
`},54:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth_witness.nr",source:`#[oracle(getAuthWitness)]
unconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}

/**
 * Oracle wrapper to fetch an \`auth_witness\` for a given \`message_hash\` from the PXE.
 *
 * @param message_hash The hash of the message for which the \`auth_witness\` is to be fetched.
 * @return The \`auth_witness\` for the given \`message_hash\` as Field array.
 */
pub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {
    get_auth_witness_oracle(message_hash)
}
`},56:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr",source:`use dep::aztec::{
    prelude::PrivateContext,
    protocol_types::{
        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,
        hash::poseidon2_hash_with_separator,
        traits::{Hash, Serialize},
    },
};
use std::meta::derive;

use crate::entrypoint::function_call::FunctionCall;

// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32
global APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;

global ACCOUNT_MAX_CALLS: u32 = 4;

// Note: If you change the following struct you have to update default_entrypoint.ts
// docs:start:app-payload-struct
#[derive(Serialize)]
pub struct AppPayload {
    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],
    pub nonce: Field,
}
// docs:end:app-payload-struct

impl Hash for AppPayload {
    fn hash(self) -> Field {
        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)
    }
}

impl AppPayload {
    // Serializes the payload as an array of bytes. Useful for hashing with sha256.
    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {
        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();

        for i in 0..ACCOUNT_MAX_CALLS {
            bytes.extend_from_array(self.function_calls[i].to_be_bytes());
        }
        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());

        bytes.storage()
    }

    // Executes all private and public calls
    // docs:start:entrypoint-execute-calls
    pub fn execute_calls(self, context: &mut PrivateContext) {
        for call in self.function_calls {
            if !call.target_address.is_zero() {
                if call.is_public {
                    context.call_public_function_with_calldata_hash(
                        call.target_address,
                        call.args_hash,
                        call.is_static,
                    );
                } else {
                    let _result = context.call_private_function_with_args_hash(
                        call.target_address,
                        call.function_selector,
                        call.args_hash,
                        call.is_static,
                    );
                }
            }
        }
    }
    // docs:end:entrypoint-execute-calls
}
`},57:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr",source:`use crate::entrypoint::function_call::FunctionCall;
use dep::aztec::{
    prelude::PrivateContext,
    protocol_types::{
        constants::GENERATOR_INDEX__FEE_PAYLOAD,
        hash::poseidon2_hash_with_separator,
        traits::{Hash, Serialize},
    },
};
use std::meta::derive;

// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32
global FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;

global MAX_FEE_FUNCTION_CALLS: u32 = 2;

// docs:start:fee-payload-struct
#[derive(Serialize)]
pub struct FeePayload {
    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],
    nonce: Field,
    is_fee_payer: bool,
}
// docs:end:fee-payload-struct

impl Hash for FeePayload {
    fn hash(self) -> Field {
        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)
    }
}

impl FeePayload {
    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {
        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();

        for i in 0..MAX_FEE_FUNCTION_CALLS {
            bytes.extend_from_array(self.function_calls[i].to_be_bytes());
        }
        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());
        bytes.push(self.is_fee_payer as u8);

        bytes.storage()
    }

    pub fn execute_calls(self, context: &mut PrivateContext) {
        for call in self.function_calls {
            if !call.target_address.is_zero() {
                if call.is_public {
                    context.call_public_function_with_calldata_hash(
                        call.target_address,
                        call.args_hash,
                        call.is_static,
                    );
                } else {
                    let _result = context.call_private_function_with_args_hash(
                        call.target_address,
                        call.function_selector,
                        call.args_hash,
                        call.is_static,
                    );
                }
            }
        }
        if self.is_fee_payer {
            context.set_as_fee_payer();
        }
    }
}
`},61:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",source:`use crate::oracle::capsules;
use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};

/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until
/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness
/// generation. All values are scoped per contract address, so external contracts cannot access them.
pub struct CapsuleArray<T> {
    contract_address: AztecAddress,
    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots
    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at
    /// slot 6, the second element (index 1) is at slot 7, and so on.
    base_slot: Field,
}

impl<T> CapsuleArray<T> {
    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in
    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to
    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.
    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {
        Self { contract_address, base_slot }
    }

    /// Returns the number of elements stored in the array.
    pub unconstrained fn len(self) -> u32 {
        // An uninitialized array defaults to a length of 0.
        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32
    }

    /// Stores a value at the end of the array.
    pub unconstrained fn push<let N: u32>(self, value: T)
    where
        T: Serialize<N>,
    {
        let current_length = self.len();

        // The slot corresponding to the index \`current_length\` is the first slot immediately after the end of the
        // array, which is where we want to place the new value.
        capsules::store(self.contract_address, self.slot_at(current_length), value);

        // Then we simply update the length.
        let new_length = current_length + 1;
        capsules::store(self.contract_address, self.base_slot, new_length);
    }

    /// Retrieves the value stored in the array at \`index\`. Throws if the index is out of bounds.
    pub unconstrained fn get<let N: u32>(self, index: u32) -> T
    where
        T: Deserialize<N>,
    {
        assert(index < self.len(), "Attempted to read past the length of a CapsuleArray");

        capsules::load(self.contract_address, self.slot_at(index)).unwrap()
    }

    /// Deletes the value stored in the array at \`index\`. Throws if the index is out of bounds.
    pub unconstrained fn remove(self, index: u32) {
        let current_length = self.len();
        assert(index < current_length, "Attempted to delete past the length of a CapsuleArray");

        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the
        // array past the removed element one slot backward so that we don't end up with a gap and preserve the
        // contiguous slots. We can skip this when deleting the last element however.
        if index != current_length - 1 {
            // The source and destination regions overlap, but \`copy\` supports this.
            capsules::copy(
                self.contract_address,
                self.slot_at(index + 1),
                self.slot_at(index),
                current_length - index - 1,
            );
        }

        // We can now delete the last element (which has either been copied to the slot immediately before it, or was
        // the element we meant to delete in the first place) and update the length.
        capsules::delete(self.contract_address, self.slot_at(current_length - 1));
        capsules::store(self.contract_address, self.base_slot, current_length - 1);
    }

    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which
    /// values are processed is arbitrary.
    ///
    /// It is safe to delete the current element (and only the current element) from inside the callback via \`remove\`:
    /// \`\`\`noir
    /// array.for_each(|index, value| {
    ///   if some_condition(value) {
    ///     array.remove(index); // safe only for this index
    ///   }
    /// }
    /// \`\`\`
    ///
    /// If all elements in the array need to iterated over and then removed, then using \`for_each\` results in optimal
    /// efficiency.
    ///
    /// It is **not** safe to push new elements into the array from inside the callback.
    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())
    where
        T: Deserialize<N>,
    {
        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current
        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays
        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes
        // unconditionally, resulting in a full clear) is a very common access pattern.
        //
        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change
        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last
        // element. This results in an optimal full clear since \`remove\` will be able to skip the \`capsules::copy\` call
        // to shift any elements past the deleted one (because there will be none).
        let mut i = self.len();
        while i > 0 {
            i -= 1;
            f(i, self.get(i));
        }
    }

    unconstrained fn slot_at(self, index: u32) -> Field {
        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first
        // element.
        self.base_slot + 1 + index as Field
    }
}

mod test {
    use crate::test::helpers::test_environment::TestEnvironment;
    use super::CapsuleArray;
    use protocol_types::address::AztecAddress;

    global SLOT: Field = 1230;

    unconstrained fn setup() -> AztecAddress {
        TestEnvironment::new().utility().this_address()
    }

    #[test]
    unconstrained fn empty_array() {
        let contract_address = setup();

        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);
        assert_eq(array.len(), 0);
    }

    #[test(should_fail_with = "Attempted to read past the length of a CapsuleArray")]
    unconstrained fn empty_array_read() {
        let contract_address = setup();

        let array = CapsuleArray::at(contract_address, SLOT);
        let _: Field = array.get(0);
    }

    #[test]
    unconstrained fn array_push() {
        let contract_address = setup();

        let array = CapsuleArray::at(contract_address, SLOT);
        array.push(5);

        assert_eq(array.len(), 1);
        assert_eq(array.get(0), 5);
    }

    #[test(should_fail_with = "Attempted to read past the length of a CapsuleArray")]
    unconstrained fn read_past_len() {
        let contract_address = setup();

        let array = CapsuleArray::at(contract_address, SLOT);
        array.push(5);

        let _ = array.get(1);
    }

    #[test]
    unconstrained fn array_remove_last() {
        let contract_address = setup();

        let array = CapsuleArray::at(contract_address, SLOT);

        array.push(5);
        array.remove(0);

        assert_eq(array.len(), 0);
    }

    #[test]
    unconstrained fn array_remove_some() {
        let contract_address = setup();

        let array = CapsuleArray::at(contract_address, SLOT);

        array.push(7);
        array.push(8);
        array.push(9);

        assert_eq(array.len(), 3);
        assert_eq(array.get(0), 7);
        assert_eq(array.get(1), 8);
        assert_eq(array.get(2), 9);

        array.remove(1);

        assert_eq(array.len(), 2);
        assert_eq(array.get(0), 7);
        assert_eq(array.get(1), 9);
    }

    #[test]
    unconstrained fn array_remove_all() {
        let contract_address = setup();

        let array = CapsuleArray::at(contract_address, SLOT);

        array.push(7);
        array.push(8);
        array.push(9);

        array.remove(1);
        array.remove(1);
        array.remove(0);

        assert_eq(array.len(), 0);
    }

    #[test]
    unconstrained fn for_each_called_with_all_elements() {
        let contract_address = setup();
        let array = CapsuleArray::at(contract_address, SLOT);

        array.push(4);
        array.push(5);
        array.push(6);

        // We store all values that we were called with and check that all (value, index) tuples are present. Note that
        // we do not care about the order in which each tuple was passed to the closure.
        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();
        array.for_each(|index, value| { called_with.push((index, value)); });

        assert_eq(called_with.len(), 3);
        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));
        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));
        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));
    }

    #[test]
    unconstrained fn for_each_remove_some() {
        let contract_address = setup();
        let array = CapsuleArray::at(contract_address, SLOT);

        array.push(4);
        array.push(5);
        array.push(6);

        array.for_each(|index, _| {
            if index == 1 {
                array.remove(index);
            }
        });

        assert_eq(array.len(), 2);
        assert_eq(array.get(0), 4);
        assert_eq(array.get(1), 6);
    }

    #[test]
    unconstrained fn for_each_remove_all() {
        let contract_address = setup();
        let array = CapsuleArray::at(contract_address, SLOT);

        array.push(4);
        array.push(5);
        array.push(6);

        array.for_each(|index, _| { array.remove(index); });

        assert_eq(array.len(), 0);
    }

    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.
    // #[test]
    // unconstrained fn for_each_remove_all_no_copy() {
    //     let contract_address = setup();
    //     let array = CapsuleArray::at(contract_address, SLOT);

    //     array.push(4);
    //     array.push(5);
    //     array.push(6);

    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.
    //     let mock = OracleMock::mock("copyCapsule");

    //     array.for_each(|index, _| {
    //         array.remove(index);
    //     });

    //     assert_eq(mock.count(), 0);
    // }
}
`},69:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",source:`use crate::{
    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},
    hash::{ArgsHasher, hash_args_array, hash_calldata_array},
    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},
    messaging::process_l1_to_l2_message,
    oracle::{
        block_header::get_block_header_at,
        call_private_function::call_private_function_internal,
        enqueue_public_function_call::{
            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,
            notify_set_public_teardown_function_call,
        },
        execution_cache,
        key_validation_request::get_key_validation_request,
        notes::{notify_created_nullifier, notify_nullified_note},
    },
};
use dep::protocol_types::{
    abis::{
        call_context::CallContext,
        function_selector::FunctionSelector,
        gas_settings::GasSettings,
        log_hash::LogHash,
        max_block_number::MaxBlockNumber,
        note_hash::NoteHash,
        nullifier::Nullifier,
        private_call_request::PrivateCallRequest,
        private_circuit_public_inputs::PrivateCircuitPublicInputs,
        private_log::{PrivateLog, PrivateLogData},
        public_call_request::PublicCallRequest,
        read_request::ReadRequest,
        side_effect::Counted,
        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},
    },
    address::{AztecAddress, EthAddress},
    block_header::BlockHeader,
    constants::{
        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,
        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,
        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,
        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,
        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,
        PRIVATE_LOG_SIZE_IN_FIELDS,
    },
    messaging::l2_to_l1_message::L2ToL1Message,
    traits::{Empty, Hash, ToField},
    utils::arrays::array_concat,
};

// When finished, one can call .finish() to convert back to the abi
pub struct PrivateContext {
    // docs:start:private-context
    pub inputs: PrivateContextInputs,
    pub side_effect_counter: u32,

    pub min_revertible_side_effect_counter: u32,
    pub is_fee_payer: bool,

    pub args_hash: Field,
    pub return_hash: Field,

    pub max_block_number: MaxBlockNumber,

    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,
    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,
    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,

    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,
    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,

    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,
    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,
    pub public_teardown_call_request: PublicCallRequest,
    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,
    // docs:end:private-context

    // Header of a block whose state is used during private execution (not the block the transaction is included in).
    pub historical_header: BlockHeader,

    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,
    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,

    // Contains the last key validation request for each key type. This is used to cache the last request and avoid
    // fetching the same request multiple times.
    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).
    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],
}

impl PrivateContext {
    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {
        PrivateContext {
            inputs,
            side_effect_counter: inputs.start_side_effect_counter + 1,
            min_revertible_side_effect_counter: 0,
            is_fee_payer: false,
            args_hash,
            return_hash: 0,
            max_block_number: MaxBlockNumber::empty(),
            note_hash_read_requests: BoundedVec::new(),
            nullifier_read_requests: BoundedVec::new(),
            key_validation_requests_and_generators: BoundedVec::new(),
            note_hashes: BoundedVec::new(),
            nullifiers: BoundedVec::new(),
            historical_header: inputs.historical_header,
            private_call_requests: BoundedVec::new(),
            public_call_requests: BoundedVec::new(),
            public_teardown_call_request: PublicCallRequest::empty(),
            l2_to_l1_msgs: BoundedVec::new(),
            private_logs: BoundedVec::new(),
            contract_class_logs_hashes: BoundedVec::new(),
            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],
        }
    }

    pub fn msg_sender(self) -> AztecAddress {
        self.inputs.call_context.msg_sender
    }

    pub fn this_address(self) -> AztecAddress {
        self.inputs.call_context.contract_address
    }

    pub fn chain_id(self) -> Field {
        self.inputs.tx_context.chain_id
    }

    pub fn version(self) -> Field {
        self.inputs.tx_context.version
    }

    pub fn gas_settings(self) -> GasSettings {
        self.inputs.tx_context.gas_settings
    }

    pub fn selector(self) -> FunctionSelector {
        self.inputs.call_context.function_selector
    }

    pub fn get_args_hash(self) -> Field {
        self.args_hash
    }

    pub fn push_note_hash(&mut self, note_hash: Field) {
        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });
    }

    pub fn push_nullifier(&mut self, nullifier: Field) {
        notify_created_nullifier(nullifier);
        self.nullifiers.push(
            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },
        );
    }

    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {
        let nullifier_counter = self.next_counter();
        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);
        self.nullifiers.push(
            Nullifier {
                value: nullifier,
                note_hash: nullified_note_hash,
                counter: nullifier_counter,
            },
        );
    }

    // Returns the header of a block whose state is used during private execution (not the block the transaction is
    // included in).
    pub fn get_block_header(self) -> BlockHeader {
        self.historical_header
    }

    // Returns the header of an arbitrary block whose block number is less than or equal to the block number
    // of historical header.
    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {
        get_block_header_at(block_number, self)
    }

    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {
        self.return_hash = returns_hasher.hash();
        execution_cache::store(returns_hasher.fields, self.return_hash);
    }

    pub fn finish(self) -> PrivateCircuitPublicInputs {
        PrivateCircuitPublicInputs {
            call_context: self.inputs.call_context,
            args_hash: self.args_hash,
            returns_hash: self.return_hash,
            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,
            is_fee_payer: self.is_fee_payer,
            max_block_number: self.max_block_number,
            note_hash_read_requests: self.note_hash_read_requests.storage(),
            nullifier_read_requests: self.nullifier_read_requests.storage(),
            key_validation_requests_and_generators: self
                .key_validation_requests_and_generators
                .storage(),
            note_hashes: self.note_hashes.storage(),
            nullifiers: self.nullifiers.storage(),
            private_call_requests: self.private_call_requests.storage(),
            public_call_requests: self.public_call_requests.storage(),
            public_teardown_call_request: self.public_teardown_call_request,
            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),
            start_side_effect_counter: self.inputs.start_side_effect_counter,
            end_side_effect_counter: self.side_effect_counter,
            private_logs: self.private_logs.storage(),
            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),
            historical_header: self.historical_header,
            tx_context: self.inputs.tx_context,
        }
    }

    pub fn set_as_fee_payer(&mut self) {
        dep::protocol_types::debug_log::debug_log_format(
            "Setting {0} as fee payer",
            [self.this_address().to_field()],
        );
        self.is_fee_payer = true;
    }

    pub fn end_setup(&mut self) {
        // dep::protocol_types::debug_log::debug_log_format(
        //     "Ending setup at counter {0}",
        //     [self.side_effect_counter as Field]
        // );
        self.min_revertible_side_effect_counter = self.side_effect_counter;
        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);
    }

    // docs:start:max-block-number
    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {
        // docs:end:max-block-number
        self.max_block_number =
            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);
    }

    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {
        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };
        self.note_hash_read_requests.push(side_effect);
    }

    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {
        let request = ReadRequest { value: nullifier, counter: self.next_counter() };
        self.nullifier_read_requests.push(request);
    }

    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {
        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)
    }

    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {
        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)
    }

    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {
        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(
            KeyValidationRequest::empty(),
        );

        if cached_request.pk_m.hash() == pk_m_hash {
            // We get a match so the cached request is the latest one
            cached_request.sk_app
        } else {
            // We didn't get a match meaning the cached result is stale
            // Typically we'd validate keys by showing that they are the preimage of \`pk_m_hash\`, but that'd require
            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn
            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to
            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes
            // to \`pk_m_hash\`.

            // Safety: Kernels verify that the key validation request is valid and below we verify that a request
            // for the correct public key has been received.
            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };
            assert_eq(request.pk_m.hash(), pk_m_hash, "Obtained invalid key validation request");

            self.key_validation_requests_and_generators.push(
                KeyValidationRequestAndGenerator {
                    request,
                    sk_app_generator: sk_generators[key_index as u32],
                },
            );
            self.last_key_validation_requests[key_index as u32] = Option::some(request);
            request.sk_app
        }
    }

    // docs:start:context_message_portal
    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {
        // docs:end:context_message_portal
        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };
        self.l2_to_l1_msgs.push(message);
    }

    // docs:start:context_consume_l1_to_l2_message
    // docs:start:consume_l1_to_l2_message
    pub fn consume_l1_to_l2_message(
        &mut self,
        content: Field,
        secret: Field,
        sender: EthAddress,
        leaf_index: Field,
    ) {
        // docs:end:context_consume_l1_to_l2_message
        let nullifier = process_l1_to_l2_message(
            self.historical_header.state.l1_to_l2_message_tree.root,
            self.this_address(),
            sender,
            self.chain_id(),
            self.version(),
            content,
            secret,
            leaf_index,
        );

        // Push nullifier (and the "commitment" corresponding to this can be "empty")
        self.push_nullifier(nullifier)
    }
    // docs:end:consume_l1_to_l2_message

    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {
        let counter = self.next_counter();
        let private_log =
            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };
        self.private_logs.push(private_log);
    }

    pub fn emit_raw_note_log(
        &mut self,
        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],
        length: u32,
        note_hash_counter: u32,
    ) {
        let counter = self.next_counter();
        let private_log =
            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };
        self.private_logs.push(private_log);
    }

    pub fn call_private_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) -> ReturnsHash {
        let args_hash = hash_args_array(args);
        execution_cache::store(args, args_hash);
        self.call_private_function_with_args_hash(
            contract_address,
            function_selector,
            args_hash,
            false,
        )
    }

    pub fn static_call_private_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) -> ReturnsHash {
        let args_hash = hash_args_array(args);
        execution_cache::store(args, args_hash);
        self.call_private_function_with_args_hash(
            contract_address,
            function_selector,
            args_hash,
            true,
        )
    }

    pub fn call_private_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) -> ReturnsHash {
        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)
    }

    pub fn static_call_private_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) -> ReturnsHash {
        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)
    }

    pub fn call_private_function_with_args_hash(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args_hash: Field,
        is_static_call: bool,
    ) -> ReturnsHash {
        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;
        let start_side_effect_counter = self.side_effect_counter;

        // Safety: The oracle simulates the private call and returns the value of the side effects counter after
        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is
        // the number of side effects that took place), along with the hash of the return values. We validate these
        // by requesting a private kernel iteration in which the return values are constrained to hash
        // to \`returns_hash\` and the side effects counter to increment from start to end.
        let (end_side_effect_counter, returns_hash) = unsafe {
            call_private_function_internal(
                contract_address,
                function_selector,
                args_hash,
                start_side_effect_counter,
                is_static_call,
            )
        };

        self.private_call_requests.push(
            PrivateCallRequest {
                call_context: CallContext {
                    msg_sender: self.this_address(),
                    contract_address,
                    function_selector,
                    is_static_call,
                },
                args_hash,
                returns_hash,
                start_side_effect_counter,
                end_side_effect_counter,
            },
        );

        // TODO (fees) figure out why this crashes the prover and enable it
        // we need this in order to pay fees inside child call contexts
        // assert(
        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)
        //     | (item.public_inputs.min_revertible_side_effect_counter
        //         > self.min_revertible_side_effect_counter)
        // );
        // if item.public_inputs.min_revertible_side_effect_counter
        //     > self.min_revertible_side_effect_counter {
        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;
        // }
        self.side_effect_counter = end_side_effect_counter + 1;
        ReturnsHash::new(returns_hash)
    }

    pub fn call_public_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn static_call_public_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)
    }

    pub fn call_public_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) {
        let calldata_hash = hash_calldata_array([function_selector.to_field()]);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn static_call_public_function_no_args(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
    ) {
        let calldata_hash = hash_calldata_array([function_selector.to_field()]);
        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)
    }

    pub fn call_public_function_with_calldata_hash(
        &mut self,
        contract_address: AztecAddress,
        calldata_hash: Field,
        is_static_call: bool,
    ) {
        let counter = self.next_counter();

        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;

        notify_enqueued_public_function_call(
            contract_address,
            calldata_hash,
            counter,
            is_static_call,
        );

        let call_request = PublicCallRequest {
            msg_sender: self.this_address(),
            contract_address,
            is_static_call,
            calldata_hash,
        };

        self.public_call_requests.push(Counted::new(call_request, counter));
    }

    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(
        &mut self,
        contract_address: AztecAddress,
        function_selector: FunctionSelector,
        args: [Field; ARGS_COUNT],
    ) {
        let calldata = array_concat([function_selector.to_field()], args);
        let calldata_hash = hash_calldata_array(calldata);
        execution_cache::store(calldata, calldata_hash);
        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)
    }

    pub fn set_public_teardown_function_with_calldata_hash(
        &mut self,
        contract_address: AztecAddress,
        calldata_hash: Field,
        is_static_call: bool,
    ) {
        let counter = self.next_counter();

        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;

        notify_set_public_teardown_function_call(
            contract_address,
            calldata_hash,
            counter,
            is_static_call,
        );

        self.public_teardown_call_request = PublicCallRequest {
            msg_sender: self.this_address(),
            contract_address,
            is_static_call,
            calldata_hash,
        };
    }

    fn next_counter(&mut self) -> u32 {
        let counter = self.side_effect_counter;
        self.side_effect_counter += 1;
        counter
    }
}

impl Empty for PrivateContext {
    fn empty() -> Self {
        PrivateContext {
            inputs: PrivateContextInputs::empty(),
            side_effect_counter: 0 as u32,
            min_revertible_side_effect_counter: 0 as u32,
            is_fee_payer: false,
            args_hash: 0,
            return_hash: 0,
            max_block_number: MaxBlockNumber::empty(),
            note_hash_read_requests: BoundedVec::new(),
            nullifier_read_requests: BoundedVec::new(),
            key_validation_requests_and_generators: BoundedVec::new(),
            note_hashes: BoundedVec::new(),
            nullifiers: BoundedVec::new(),
            private_call_requests: BoundedVec::new(),
            public_call_requests: BoundedVec::new(),
            public_teardown_call_request: PublicCallRequest::empty(),
            l2_to_l1_msgs: BoundedVec::new(),
            historical_header: BlockHeader::empty(),
            private_logs: BoundedVec::new(),
            contract_class_logs_hashes: BoundedVec::new(),
            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],
        }
    }
}
`},72:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",source:`use crate::oracle::{
    execution::{get_block_number, get_chain_id, get_contract_address, get_version},
    storage::storage_read,
};
use dep::protocol_types::{address::AztecAddress, traits::Packable};

pub struct UtilityContext {
    block_number: u32,
    contract_address: AztecAddress,
    version: Field,
    chain_id: Field,
}

impl UtilityContext {
    pub unconstrained fn new() -> Self {
        // We could call these oracles on the getters instead of at creation, which makes sense given that they might
        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user
        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not
        // available.
        let block_number = get_block_number();
        let contract_address = get_contract_address();
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub unconstrained fn at(contract_address: AztecAddress) -> Self {
        let block_number = get_block_number();
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {
        let chain_id = get_chain_id();
        let version = get_version();
        Self { block_number, contract_address, version, chain_id }
    }

    pub fn block_number(self) -> u32 {
        self.block_number
    }

    pub fn this_address(self) -> AztecAddress {
        self.contract_address
    }

    pub fn version(self) -> Field {
        self.version
    }

    pub fn chain_id(self) -> Field {
        self.chain_id
    }

    pub unconstrained fn raw_storage_read<let N: u32>(
        self: Self,
        storage_slot: Field,
    ) -> [Field; N] {
        storage_read(self.this_address(), storage_slot, self.block_number())
    }

    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T
    where
        T: Packable<N>,
    {
        T::unpack(self.raw_storage_read(storage_slot))
    }
}
`},76:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",source:`use dep::protocol_types::{
    address::{AztecAddress, EthAddress},
    constants::{
        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,
        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,
    },
    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},
    point::Point,
    traits::{Hash, ToField},
};

pub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};

pub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {
    std::hash::pedersen_commitment_with_separator(inputs, hash_index)
}

pub fn compute_secret_hash(secret: Field) -> Field {
    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)
}

pub fn compute_l1_to_l2_message_hash(
    sender: EthAddress,
    chain_id: Field,
    recipient: AztecAddress,
    version: Field,
    content: Field,
    secret_hash: Field,
    leaf_index: Field,
) -> Field {
    let mut hash_bytes = [0 as u8; 224];
    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();
    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();
    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();
    let version_bytes: [u8; 32] = version.to_be_bytes();
    let content_bytes: [u8; 32] = content.to_be_bytes();
    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();
    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();

    for i in 0..32 {
        hash_bytes[i] = sender_bytes[i];
        hash_bytes[i + 32] = chain_id_bytes[i];
        hash_bytes[i + 64] = recipient_bytes[i];
        hash_bytes[i + 96] = version_bytes[i];
        hash_bytes[i + 128] = content_bytes[i];
        hash_bytes[i + 160] = secret_hash_bytes[i];
        hash_bytes[i + 192] = leaf_index_bytes[i];
    }

    sha256_to_field(hash_bytes)
}

// The nullifier of a l1 to l2 message is the hash of the message salted with the secret
pub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {
    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)
}

pub struct ArgsHasher {
    pub fields: [Field],
}

impl Hash for ArgsHasher {
    fn hash(self) -> Field {
        hash_args(self.fields)
    }
}

impl ArgsHasher {
    pub fn new() -> Self {
        Self { fields: [] }
    }

    pub fn add(&mut self, field: Field) {
        self.fields = self.fields.push_back(field);
    }

    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {
        for i in 0..N {
            self.fields = self.fields.push_back(fields[i]);
        }
    }
}

// Computes the hash of input arguments or return values for private functions, or for authwit creation.
pub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {
    if args.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)
    }
}

// Same as \`hash_args_array\`, but takes a slice instead of an array.
pub fn hash_args(args: [Field]) -> Field {
    if args.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)
    }
}

// Computes the hash of calldata for public functions.
pub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {
    if calldata.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)
    }
}

// Same as \`hash_calldata_array\`, but takes a slice instead of an array.
pub fn hash_calldata(calldata: [Field]) -> Field {
    if calldata.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)
    }
}

#[test]
unconstrained fn compute_var_args_hash() {
    let mut input = ArgsHasher::new();
    for i in 0..100 {
        input.add(i as Field);
    }
    let hash = input.hash();
    dep::std::println(hash);
    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);
}
`},91:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",source:`use dep::protocol_types::{
    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,
};
use std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};

/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.
/// The input secret is known only to one party. The output shared secret is derivable
/// by both parties, through this function.
/// E.g.:
/// Epk = esk * G // ephemeral keypair
/// Pk = sk * G // recipient keypair
/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?
// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman
pub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {
    let shared_secret = multi_scalar_mul([public_key], [secret]);
    shared_secret
}

/// Computes a standard ecdh shared secret using the address public key of the given address:
/// [ephemeral_secret] * recipient_address_public_key = shared_secret.
/// The intention is that the _creator_ of a shared secret would call this function,
/// given the address of their intended recipient.
pub fn derive_ecdh_shared_secret_using_aztec_address(
    ephemeral_secret: Scalar,
    recipient_address: AztecAddress,
) -> Point {
    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)
}

#[test]
unconstrained fn test_consistency_with_typescript() {
    let secret = Scalar {
        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,
        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,
    };
    let point = Point {
        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,
        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,
        is_infinite: false,
    };

    let shared_secret = derive_ecdh_shared_secret(secret, point);

    // This is just pasted from a test run.
    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.
    let hard_coded_shared_secret = Point {
        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,
        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,
        is_infinite: false,
    };
    assert_eq(shared_secret, hard_coded_shared_secret);
}

#[test]
unconstrained fn test_shared_secret_computation_in_both_directions() {
    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };
    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };

    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);
    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);

    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);
    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);

    assert_eq(shared_secret, shared_secret_alt);
}

#[test]
unconstrained fn test_shared_secret_computation_from_address_in_both_directions() {
    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };
    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };

    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);
    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);

    let address_b = AztecAddress::from_field(pk_b.x);

    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates
    // of the pk_a or pk_b to be less than half the field modulus.
    // If needed, we negate the pk's so that they yield valid address points.
    // (We could also have negated the secrets, but there's no negate method for
    // EmbeddedCurvesScalar).
    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {
        pk_a
    } else {
        pk_a.neg()
    };
    pk_b = if (address_b.to_address_point().inner == pk_b) {
        pk_b
    } else {
        pk_b.neg()
    };

    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);
    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);

    assert_eq(shared_secret, shared_secret_alt);
}
`},92:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",source:`use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};

use dep::protocol_types::{point::Point, scalar::Scalar};

use crate::oracle::random::random;

pub fn generate_ephemeral_key_pair() -> (Scalar, Point) {
    // @todo Need to draw randomness from the full domain of Fq not only Fr

    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a
    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,
    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the
    // sender will cooperate in the random value generation.
    let randomness = unsafe { random() };

    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box
    // called by fixed_base_scalar_mul).
    let eph_sk = EmbeddedCurveScalar::from_field(randomness);
    let eph_pk = fixed_base_scalar_mul(eph_sk);

    (eph_sk, eph_pk)
}
`},93:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",source:`use crate::{
    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},
    oracle::{
        key_validation_request::get_key_validation_request,
        keys::get_public_keys_and_partial_address,
    },
};
use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};

mod test;

pub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {
    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app
}

// A helper function that gets app-siloed outgoing viewing key for a given \`ovpk_m_hash\`. This function is used
// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is \`request_ovsk_app\`
// function defined on \`PrivateContext\`.
pub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {
    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app
}

// Returns all public keys for a given account, applying proper constraints to the context. We read all
// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any
// read keys that are not required by the caller can simply be discarded.
pub fn get_public_keys(account: AztecAddress) -> PublicKeys {
    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.
    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };
    assert_eq(
        account,
        AztecAddress::compute(public_keys, partial_address),
        "Invalid public keys hint for address",
    );

    public_keys
}
`},97:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",source:`use crate::{
    macros::{
        dispatch::generate_public_dispatch,
        functions::{stub_registry, utils::check_each_fn_macroified},
        notes::{generate_note_export, NOTES},
        storage::STORAGE_LAYOUT_NAME,
        utils::{get_trait_impl_method, module_has_storage},
    },
    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,
};

/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting
/// the \`sync_private_state\` utility function.
/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.
pub comptime fn aztec(m: Module) -> Quoted {
    let interface = generate_contract_interface(m);

    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not
    // allowed in contracts.
    check_each_fn_macroified(m);

    let contract_library_method_compute_note_hash_and_nullifier =
        generate_contract_library_method_compute_note_hash_and_nullifier();
    let note_exports = generate_note_exports();
    let public_dispatch = generate_public_dispatch(m);
    let sync_private_state = generate_sync_private_state();

    quote {
        $note_exports
        $interface
        $contract_library_method_compute_note_hash_and_nullifier
        $public_dispatch
        $sync_private_state
    }
}

comptime fn generate_contract_interface(m: Module) -> Quoted {
    let module_name = m.name();
    let contract_stubs = stub_registry::get(m);
    let fn_stubs_quote = if contract_stubs.is_some() {
        contract_stubs.unwrap().join(quote {})
    } else {
        quote {}
    };

    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();
    let storage_layout_getter = if has_storage_layout {
        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();
        quote {
            pub fn storage_layout() -> StorageLayoutFields {
                $storage_layout_name.fields
            }
        }
    } else {
        quote {}
    };

    let library_storage_layout_getter = if has_storage_layout {
        quote {
            #[contract_library_method]
            $storage_layout_getter
        }
    } else {
        quote {}
    };

    quote {
        pub struct $module_name {
            pub target_contract: dep::aztec::protocol_types::address::AztecAddress
        }

        impl $module_name {
            $fn_stubs_quote

            pub fn at(
                addr: aztec::protocol_types::address::AztecAddress
            ) -> Self {
                Self { target_contract: addr }
            }

            pub fn interface() -> Self {
                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }
            }

            $storage_layout_getter
        }

        #[contract_library_method]
        pub fn at(
            addr: aztec::protocol_types::address::AztecAddress
        ) -> $module_name {
            $module_name { target_contract: addr }
        }

        #[contract_library_method]
        pub fn interface() -> $module_name {
            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }
        }

        $library_storage_layout_getter

    }
}

/// Generates a contract library method called \`_compute_note_hash_and_nullifier\` which is used for note
/// discovery (to create the \`aztec::messages::discovery::ComputeNoteHashAndNullifier\` function) and to implement the
/// \`compute_note_hash_and_nullifier\` unconstrained contract function.
comptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {
    let notes = NOTES.entries();

    if notes.len() > 0 {
        let max_note_packed_len = notes.fold(
            0,
            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {
                if len > acc {
                    len
                } else {
                    acc
                }
            },
        );

        if max_note_packed_len > MAX_NOTE_PACKED_LEN {
            panic(
                f"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}",
            );
        }

        // Contracts that do define notes produce an if-else chain where \`note_type_id\` is matched against the
        // \`get_note_type_id()\` function of each note type that we know of, in order to identify the note type. Once we
        // know it we call we correct \`unpack\` method from the \`Packable\` trait to obtain the underlying note type, and
        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).

        let mut if_note_type_id_match_statements_list = &[];
        for i in 0..notes.len() {
            let (typ, (_, packed_note_length, _, _)) = notes[i];

            let get_note_type_id = get_trait_impl_method(
                typ,
                quote { crate::note::note_interface::NoteType },
                quote { get_id },
            );
            let unpack = get_trait_impl_method(
                typ,
                quote { crate::protocol_types::traits::Packable<_> },
                quote { unpack },
            );

            let compute_note_hash = get_trait_impl_method(
                typ,
                quote { crate::note::note_interface::NoteHash },
                quote { compute_note_hash },
            );

            let compute_nullifier_unconstrained = get_trait_impl_method(
                typ,
                quote { crate::note::note_interface::NoteHash },
                quote { compute_nullifier_unconstrained },
            );

            let if_or_else_if = if i == 0 {
                quote { if }
            } else {
                quote { else if }
            };

            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(
                quote {
                    $if_or_else_if note_type_id == $get_note_type_id() {
                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected
                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the
                        // unpack function on it.
                        let expected_len = $packed_note_length;
                        let actual_len = packed_note.len();
                        assert(
                            actual_len == expected_len,
                            f"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}"
                        );

                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));

                        let note_hash = $compute_note_hash(note, storage_slot);
    
                        // The message discovery process finds settled notes, that is, notes that were created in prior
                        // transactions and are therefore already part of the note hash tree. We therefore compute the
                        // nullification note hash by treating the note as a settled note with the provided nonce.
                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(
                            aztec::note::retrieved_note::RetrievedNote{ 
                                note, 
                                contract_address, 
                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() 
                            }, 
                            storage_slot,
                        );

                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);

                        Option::some(
                            aztec::messages::discovery::NoteHashAndNullifier {
                                note_hash, inner_nullifier
                            }
                        )
                    }
                },
            );
        }

        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});

        quote {
            /// Unpacks an array into a note corresponding to \`note_type_id\` and then computes its note hash
            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash
            /// tree with \`nonce\`.
            ///
            /// The signature of this function notably matches the \`aztec::messages::discovery::ComputeNoteHashAndNullifier\` type,
            /// and so it can be used to call functions from that module such as \`discover_new_messages\`, 
            /// \`do_process_log\` and \`attempt_note_discovery\`.
            ///
            /// This function is automatically injected by the \`#[aztec]\` macro.
            #[contract_library_method]
            unconstrained fn _compute_note_hash_and_nullifier(
                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,
                storage_slot: Field,
                note_type_id: Field,
                contract_address: aztec::protocol_types::address::AztecAddress,
                nonce: Field,
            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {
                $if_note_type_id_match_statements
                else {
                    Option::none()
                }
            }
        }
    } else {
        // Contracts with no notes still implement this function to avoid having special-casing, the implementation
        // simply throws immediately.
        quote {
            /// This contract does not use private notes, so this function should never be called as it will
            /// unconditionally fail.
            ///
            /// This function is automatically injected by the \`#[aztec]\` macro.
            #[contract_library_method]
            unconstrained fn _compute_note_hash_and_nullifier(
                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,
                _storage_slot: Field,
                _note_type_id: Field,
                _contract_address: aztec::protocol_types::address::AztecAddress,
                _nonce: Field,
            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {
                panic(f"This contract does not use private notes")
            }
        }
    }
}

comptime fn generate_note_exports() -> Quoted {
    let notes = NOTES.values();
    // Second value in each tuple is \`note_packed_len\` and that is ignored here because it's only used when
    // generating partial note helper functions.
    notes
        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {
            generate_note_export(s, note_type_id, fields)
        })
        .join(quote {})
}

comptime fn generate_sync_private_state() -> Quoted {
    // We obtain the \`utility\` function on the next line instead of directly doing
    // \`#[aztec::macros::functions::utility]\` in the returned quote because the latter would result in the function
    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only
    // to determine whether a function is \`private\`, \`public\`, or \`utility\`.
    let utility = crate::macros::functions::utility;

    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't
    // need to do anything extra.
    quote {
        #[$utility]
        unconstrained fn sync_private_state() {
        }
    }
}
`},102:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",source:`use dep::protocol_types::{
    abis::function_selector::FunctionSelector, address::AztecAddress,
    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,
};

use crate::{
    context::{PrivateContext, PublicContext},
    oracle::get_contract_instance::{
        get_contract_instance, get_contract_instance_deployer_avm,
        get_contract_instance_initialization_hash_avm,
    },
};

pub fn mark_as_initialized_public(context: &mut PublicContext) {
    let init_nullifier =
        compute_unsiloed_contract_initialization_nullifier((*context).this_address());
    context.push_nullifier(init_nullifier);
}

pub fn mark_as_initialized_private(context: &mut PrivateContext) {
    let init_nullifier =
        compute_unsiloed_contract_initialization_nullifier((*context).this_address());
    context.push_nullifier(init_nullifier);
}

pub fn assert_is_initialized_public(context: &mut PublicContext) {
    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());
    assert(context.nullifier_exists(init_nullifier, context.this_address()), "Not initialized");
}

pub fn assert_is_initialized_private(context: &mut PrivateContext) {
    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());
    context.push_nullifier_read_request(init_nullifier);
}

fn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {
    address.to_field()
}

pub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {
    let address = context.this_address();
    let deployer = get_contract_instance_deployer_avm(address).unwrap();
    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();
    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());
    assert(initialization_hash == expected_init, "Initialization hash does not match");
    assert(
        (deployer.is_zero()) | (deployer == context.msg_sender()),
        "Initializer address is not the contract deployer",
    );
}

pub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {
    let address = context.this_address();
    let instance = get_contract_instance(address);
    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());
    assert(instance.initialization_hash == expected_init, "Initialization hash does not match");
    assert(
        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),
        "Initializer address is not the contract deployer",
    );
}

/// This function is not only used in macros but it's also used by external people to check that an instance has been
/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.
pub fn compute_initialization_hash(
    init_selector: FunctionSelector,
    init_args_hash: Field,
) -> Field {
    poseidon2_hash_with_separator(
        [init_selector.to_field(), init_args_hash],
        GENERATOR_INDEX__CONSTRUCTOR,
    )
}
`},105:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",source:`use crate::macros::{
    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},
    notes::NOTES,
    utils::{
        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,
        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,
        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,
    },
};
use protocol_types::meta::generate_serialize_to_fields;
use std::meta::type_of;

pub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // If a function is further modified as unconstrained, we throw an error
    if f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword",
        );
    }

    let module_has_initializer = module_has_initializer(f.module());
    let module_has_storage = module_has_storage(f.module());

    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the
    // Private Kernel Circuit.
    // First we change the function signature so that it also receives \`PrivateContextInputs\`, which contain information
    // about the execution context (e.g. the caller).
    let original_params = f.parameters();
    f.set_parameters(&[(
        quote { inputs },
        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),
    )]
        .append(original_params));

    let mut body = f.body().as_block().unwrap();

    // The original params are hashed and passed to the \`context\` object, so that the kernel can verify we've received
    // the correct values.
    // TODO: Optimize args_hasher for small number of arguments
    let args_hasher_name = quote { args_hasher };
    let args_hasher = original_params.fold(
        quote {
            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();
        },
        |args_hasher, param: (Quoted, Type)| {
            let (name, typ) = param;
            let appended_arg = add_to_hasher(args_hasher_name, name, typ);
            quote {
                $args_hasher
                $appended_arg
            }
        },
    );

    let context_creation = quote {
        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));
    };

    // Modifications introduced by the different marker attributes.
    let internal_check = if is_fn_internal(f) {
        create_internal_check(f)
    } else {
        quote {}
    };

    let view_check = if is_fn_view(f) {
        create_view_check(f)
    } else {
        quote {}
    };

    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {
        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))
    } else {
        (quote {}, quote {})
    };

    let storage_init = if module_has_storage {
        quote {
            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
            // referenced. We instead ignore 'unused variable' warnings for it.
            #[allow(unused_variables)]
            let storage = Storage::init(&mut context);
        }
    } else {
        quote {}
    };

    // Initialization checks are not included in contracts that don't have initializers.
    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {
        create_init_check(f)
    } else {
        quote {}
    };

    // All private functions perform message discovery, since they may need to access notes. This is slightly
    // inefficient and could be improved by only doing it once we actually attempt to read any.
    let message_discovery_call = if NOTES.len() > 0 {
        create_message_discovery_call()
    } else {
        quote {}
    };

    // Finally, we need to change the return type to be \`PrivateCircuitPublicInputs\`, which is what the Private Kernel
    // circuit expects.
    let return_value_var_name = quote { macro__returned__values };

    let return_value_type = f.return_type();
    let return_value = if body.len() == 0 {
        quote {}
    } else if return_value_type != type_of(()) {
        // The original return value is passed to a second args hasher which the context receives.
        let (body_without_return, last_body_expr) = body.pop_back();
        let return_value = last_body_expr.quoted();
        let return_value_assignment =
            quote { let $return_value_var_name: $return_value_type = $return_value; };
        let return_hasher_name = quote { return_hasher };
        let return_value_into_hasher =
            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);

        body = body_without_return;

        quote {
            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();
            $return_value_assignment
            $return_value_into_hasher
            context.set_return_hash($return_hasher_name);
        }
    } else {
        let (body_without_return, last_body_expr) = body.pop_back();
        if !last_body_expr.has_semicolon()
            & last_body_expr.as_for().is_none()
            & last_body_expr.as_assert().is_none()
            & last_body_expr.as_for_range().is_none()
            & last_body_expr.as_assert_eq().is_none()
            & last_body_expr.as_let().is_none() {
            let unused_return_value_name = f"_{return_value_var_name}".quoted_contents();
            body = body_without_return.push_back(
                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),
            );
        }
        quote {}
    };

    let context_finish = quote { context.finish() };

    let to_prepend = quote {
        $args_hasher
        $context_creation
        $assert_initializer
        $init_check
        $internal_check
        $view_check
        $storage_init
        $message_discovery_call
    };

    let to_append = quote {
        $return_value
        $mark_as_initialized
        $context_finish
    };
    let modified_body = modify_fn_body(body, to_prepend, to_append);
    f.set_body(modified_body);
    f.set_return_type(
        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }
            .as_type(),
    );
    f.set_return_data();

    fn_abi
}

pub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // If a function is further modified as unconstrained, we throw an error
    if f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword",
        );
    }

    let module_has_initializer = module_has_initializer(f.module());
    let module_has_storage = module_has_storage(f.module());

    // Public functions undergo a lot of transformations from their Aztec.nr form.
    let original_params = f.parameters();
    let args_len = original_params
        .map(|(name, typ): (Quoted, Type)| {
            generate_serialize_to_fields(name, typ, false).0.len()
        })
        .fold(0, |acc: u32, val: u32| acc + val);

    // Unlike in the private case, in public the \`context\` does not need to receive the hash of the original params.
    let context_creation = quote {
        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {
        // We start from 1 because we skip the selector for the dispatch function.
        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);
        dep::aztec::hash::hash_args_array(serialized_args)
        });
    };

    // Modifications introduced by the different marker attributes.
    let internal_check = if is_fn_internal(f) {
        create_internal_check(f)
    } else {
        quote {}
    };

    let view_check = if is_fn_view(f) {
        create_view_check(f)
    } else {
        quote {}
    };

    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {
        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))
    } else {
        (quote {}, quote {})
    };

    let storage_init = if module_has_storage {
        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
        // referenced. We instead ignore 'unused variable' warnings for it.
        quote {
            #[allow(unused_variables)]
            let storage = Storage::init(&mut context);
        }
    } else {
        quote {}
    };

    // Initialization checks are not included in contracts that don't have initializers.
    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {
        create_init_check(f)
    } else {
        quote {}
    };

    let to_prepend = quote {
        $context_creation
        $assert_initializer
        $init_check
        $internal_check
        $view_check
        $storage_init
    };

    let to_append = quote {
        $mark_as_initialized
    };

    let body = f.body().as_block().unwrap();
    let modified_body = modify_fn_body(body, to_prepend, to_append);
    f.set_body(modified_body);

    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because
    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM
    // bytecode.
    f.set_unconstrained(true);
    f.set_return_public(true);

    fn_abi
}

pub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {
    let fn_abi = create_fn_abi_export(f);
    let fn_stub = stub_fn(f);
    stub_registry::register(f.module(), fn_stub);

    // Check if function is marked as unconstrained
    if !f.is_unconstrained() {
        let name = f.name();
        panic(
            f"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword",
        );
    }

    // Create utility context
    let context_creation =
        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };
    let module_has_storage = module_has_storage(f.module());

    // Initialize Storage if module has storage
    let storage_init = if module_has_storage {
        quote {
            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is
            // referenced. We instead ignore 'unused variable' warnings for it.
            #[allow(unused_variables)]
            let storage = Storage::init(context);
        }
    } else {
        quote {}
    };

    // All utility functions perform message discovery, since they may need to access private notes that would be
    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually
    // attempt to read any.
    let message_discovery_call = if NOTES.len() > 0 {
        create_message_discovery_call()
    } else {
        quote {}
    };

    // Inject context creation, storage initialization, and message discovery call at the beginning of the function
    // body.
    let to_prepend = quote {
        $context_creation
        $storage_init
        $message_discovery_call
    };
    let body = f.body().as_block().unwrap();
    let modified_body = modify_fn_body(body, to_prepend, quote {});
    f.set_body(modified_body);

    f.set_return_public(true);

    fn_abi
}

comptime fn create_internal_check(f: FunctionDefinition) -> Quoted {
    let name = f.name();
    let assertion_message = f"Function {name} can only be called internally";
    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }
}

comptime fn create_view_check(f: FunctionDefinition) -> Quoted {
    let name = f.name();
    let assertion_message = f"Function {name} can only be called statically";
    if is_fn_private(f) {
        // Here \`context\` is of type context::PrivateContext
        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }
    } else {
        // Here \`context\` is of type context::PublicContext
        quote { assert(context.is_static_call(), $assertion_message); }
    }
}

comptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);"
        .quoted_contents()
}

comptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);"
        .quoted_contents()
}

comptime fn create_init_check(f: FunctionDefinition) -> Quoted {
    let fn_visibility = get_fn_visibility(f);
    f"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);"
        .quoted_contents()
}

/// Injects a call to \`aztec::messages::discovery::discover_new_messages\`, causing for new notes to be added to PXE and made
/// available for the current execution.
pub(crate) comptime fn create_message_discovery_call() -> Quoted {
    quote {
        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore
        /// always safe to call.
        unsafe {
            dep::aztec::messages::discovery::discover_new_messages(
                context.this_address(),
                _compute_note_hash_and_nullifier,
            );
        };
    }
}

/// Checks if each function in the module is marked with either #[private], #[public], #[utility],
/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.
pub(crate) comptime fn check_each_fn_macroified(m: Module) {
    for f in m.functions() {
        let name = f.name();
        if !is_fn_private(f)
            & !is_fn_public(f)
            & !is_fn_utility(f)
            & !is_fn_contract_library_method(f)
            & !is_fn_test(f) {
            panic(
                f"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]",
            );
        }
    }
}
`},107:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",source:`use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};
use poseidon::poseidon2::Poseidon2Hasher;
use protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};
use std::{
    collections::umap::UHashMap,
    hash::{BuildHasherDefault, Hash, Hasher},
    meta::{type_of, unquote},
};

/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).
/// \`fields\` is an array of tuples where each tuple contains the name of the field/struct member (e.g. \`amount\`
/// in \`TokenNote\`), the index of where the packed member starts in the packed note and a flag indicating
/// whether the field is nullable or not.
pub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =
    UHashMap::default();

pub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;

/// The note type id is set by enumerating the note types.
comptime fn get_next_note_type_id() -> Field {
    // We assert that the note type id fits within 7 bits
    assert(
        NOTE_TYPE_ID_COUNTER < 128 as u32,
        "A contract can contain at most 128 different note types",
    );

    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;
    NOTE_TYPE_ID_COUNTER += 1;
    note_type_id
}

/// Generates a quote that implements \`Packable\` for a given struct \`s\`.
/// If the note struct already implements \`Packable\`, we return an empty quote.
comptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {
    // We try to get the packed length of the note struct. If it does not implement \`Packable\`, we get Option::none()
    let packed_len_typ = std::meta::typ::fresh_type_variable();
    // We don't care about the result of the implements check. We just want the get the packed length.
    let _ = s.as_type().implements(
        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),
    );
    let maybe_packed_length = packed_len_typ.as_constant();

    if maybe_packed_length.is_some() {
        // We got some packed length meaning that the note struct implements \`Packable\`. For this reason we return
        // an empty quote for the implementation and the packed length.
        (quote {}, maybe_packed_length.unwrap())
    } else {
        // We didn't manage to get the packed length which means the note struct doesn't implement \`Packable\`
        // so we derive it and return it along with the packed length.
        derive_packable_and_get_packed_len(s)
    }
}

/// Generates default \`NoteType\` implementation for a given note struct \`s\` and returns it as a quote.
///
/// impl NoteType for NoteStruct {
///     fn get_id() -> Field {
///         ...
///     }
/// }
comptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {
    let name = s.name();

    quote {
        impl aztec::note::note_interface::NoteType for $name {
            fn get_id() -> Field {
                $note_type_id
            }
        }
    }
}

/// Generates default \`NoteHash\` trait implementation for a given note struct \`s\` and returns it as a quote.
///
/// # Generated Implementation
/// \`\`\`
/// impl NoteHash for NoteStruct {
///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }
///
///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }
///
///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }
/// }
/// \`\`\`
comptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {
    let name = s.name();

    quote {
        impl aztec::note::note_interface::NoteHash for $name {
            fn compute_note_hash(self, storage_slot: Field) -> Field {
                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);
                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)
            }

            fn compute_nullifier(
                self,
                context: &mut aztec::prelude::PrivateContext,
                note_hash_for_nullify: Field,
            ) -> Field {
                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;
                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly
                // in the quote to avoid "trait not in scope" compiler warnings.
                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);
                let secret = context.request_nsk_app(owner_npk_m_hash);
                aztec::protocol_types::hash::poseidon2_hash_with_separator(
                    [note_hash_for_nullify, secret],
                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,
                )
            }

            unconstrained fn compute_nullifier_unconstrained(
                self,
                note_hash_for_nullify: Field,
            ) -> Field {
                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;
                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly
                // in the quote to avoid "trait not in scope" compiler warnings.
                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);
                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);
                aztec::protocol_types::hash::poseidon2_hash_with_separator(
                    [note_hash_for_nullify, secret],
                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,
                )
            }
        }
    }
}

/// Generates note properties struct for a given note struct \`s\`.
///
/// Example:
/// \`\`\`
/// struct TokenNoteProperties {
///     amount: aztec::note::note_getter_options::PropertySelector,
///     npk_m_hash: aztec::note::note_getter_options::PropertySelector
///     randomness: aztec::note::note_getter_options::PropertySelector
/// }
///
/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {
///     fn properties() -> TokenNoteProperties {
///         Self {
///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },
///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },
///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }
///         }
///     }
/// }
/// \`\`\`
comptime fn generate_note_properties(s: TypeDefinition) -> Quoted {
    let name = s.name();

    let struct_name = f"{name}Properties".quoted_contents();

    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });

    let note_fields = s.fields_as_written();

    let properties_types = note_fields
        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })
        .join(quote {,});

    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694
    let mut properties_list = &[];
    for i in 0..note_fields.len() {
        let (name, _) = note_fields[i];
        properties_list = properties_list.push_back(
            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },
        );
    }

    let properties = properties_list.join(quote {,});

    quote {
        pub struct $struct_name {
            $properties_types
        }

        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {
            fn properties() -> $struct_name {
                $struct_name {
                    $properties
                }
            }
        }
    }
}

/// Generates note export for a given note struct \`s\`. The export is a global variable that contains note type id,
/// note name and information about note fields (field name, index and whether the field is nullable or not).
///
/// Example:
/// \`\`\`
/// struct TokenNoteFields_5695262104 {
///     amount: aztec::note::note_field::NoteField,
///     owner: aztec::note::note_field::NoteField
/// }
///
/// #[abi(notes)]
/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (
///     0,
///     "TokenNote",
///     TokenNoteFields_5695262104 {
///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },
///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }
///     }
/// );
///
/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included
/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.
pub(crate) comptime fn generate_note_export(
    s: TypeDefinition,
    note_type_id: Field,
    fields: [(Quoted, u32, bool)],
) -> Quoted {
    let name = s.name();
    let mut hasher = Poseidon2Hasher::default();
    s.as_type().hash(&mut hasher);
    let hash = hasher.finish() as u32;
    let global_export_name = f"{name}_EXPORTS_{hash}".quoted_contents();
    let note_fields_name = f"{name}Fields_{hash}".quoted_contents();
    let (note_name_as_str, _) = name.as_str_quote();
    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });

    let mut note_fields = &[];
    let mut note_field_constructors = &[];
    for field in fields {
        let (name, index, nullable) = field;
        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });
        note_field_constructors = note_field_constructors.push_back(
            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},
        );
    }

    let note_fields = note_fields.join(quote {,});
    let note_field_constructors = note_field_constructors.join(quote {,});

    quote {
        pub struct $note_fields_name {
            pub $note_fields
        }

        #[abi(notes)]
        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });
    }
}

/// Registers a note struct \`note\` with the given \`note_packed_len\`, \`note_type_id\`, \`fixed_fields\` and
/// \`nullable_fields\` in the global \`NOTES\` map.
comptime fn register_note(
    note: TypeDefinition,
    note_packed_len: u32,
    note_type_id: Field,
    fixed_fields: [(Quoted, Type, u32)],
    nullable_fields: [(Quoted, Type, u32)],
) {
    let mut fields = &[];
    for field in fixed_fields {
        let (name, _, index) = field;
        fields = fields.push_back((name, index, false));
    }
    for field in nullable_fields {
        let (name, _, index) = field;
        fields = fields.push_back((name, index, true));
    }

    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));
}

/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member
/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).
comptime fn index_note_fields(
    s: TypeDefinition,
    nullable_fields: [Quoted],
) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {
    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];
    let mut indexed_nullable_fields = &[];
    let mut counter: u32 = 0;
    for field in s.fields_as_written() {
        let (name, typ) = field;
        if nullable_fields.all(|field| field != name) {
            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));
        } else {
            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));
        }
        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);
        // Each struct member can occupy multiple fields so we need to increment the counter accordingly
        counter += serialization_fields.len();
    }
    (indexed_fixed_fields, indexed_nullable_fields)
}

/// Generates the following:
/// - NoteTypeProperties
/// - NoteType trait implementation
/// - NoteHash trait implementation
/// - Packable implementation
///
/// Registers the note in the global \`NOTES\` map.
///
/// For more details on the generated code, see the individual functions.
pub comptime fn note(s: TypeDefinition) -> Quoted {
    assert_has_owner(s);

    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);

    let note_properties = generate_note_properties(s);
    let note_type_id = get_next_note_type_id();
    let note_interface_impl = generate_note_interface(s, note_type_id);
    let note_hash_impl = generate_note_hash_trait_impl(s);
    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);

    register_note(
        s,
        note_packed_len,
        note_type_id,
        indexed_fixed_fields,
        indexed_nullable_fields,
    );

    quote {
        $note_properties
        $note_interface_impl
        $note_hash_impl
        $packable_impl
    }
}

/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.
///
/// # Generated Code
/// - NoteTypeProperties: Defines the structure and properties of note fields
/// - NoteType trait implementation: Provides the note type ID
/// - Packable implementation: Enables serialization/deserialization of the note
///
/// # Registration
/// Registers the note in the global \`NOTES\` map with:
/// - Note type ID
/// - Packed length
/// - Field indices and nullability
///
/// # Use Cases
/// Use this macro when implementing a note that needs custom:
/// - Note hash computation logic
/// - Nullifier computation logic
///
/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.
///
/// # Example
/// \`\`\`
/// #[custom_note]
/// struct CustomNote {
///     value: Field,
///     metadata: Field
/// }
///
/// impl NoteHash for CustomNote {
///     // Custom note hash computation...
///     fn compute_note_hash(...) -> Field { ... }
///
///     // Custom nullifier computation...
///     fn compute_nullifier(...) -> Field { ... }
///     fn compute_nullifier_unconstrained(...) -> Field { ... }
/// }
/// \`\`\`
pub comptime fn custom_note(s: TypeDefinition) -> Quoted {
    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);
    let note_type_id = get_next_note_type_id();

    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);
    register_note(
        s,
        note_packed_len,
        note_type_id,
        indexed_fixed_fields,
        indexed_nullable_fields,
    );

    let note_properties = generate_note_properties(s);
    let note_interface_impl = generate_note_interface(s, note_type_id);

    quote {
        $note_properties
        $note_interface_impl
        $packable_impl
    }
}

/// Asserts that the note has an 'owner' field.
///
/// We require notes implemented with #[note] macro macro to have an 'owner' field because our
/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.
comptime fn assert_has_owner(note: TypeDefinition) {
    let fields = note.fields_as_written();
    let mut has_owner = false;
    for i in 0..fields.len() {
        let (field_name, _) = fields[i];
        if field_name == quote { owner } {
            has_owner = true;
            break;
        }
    }
    assert(
        has_owner,
        "Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.",
    );
}
`},110:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",source:`use protocol_types::{address::AztecAddress, debug_log::debug_log};

pub mod nonce_discovery;
pub mod partial_notes;
pub mod pending_tagged_log;
pub mod private_logs;
pub mod private_notes;

use private_notes::MAX_NOTE_PACKED_LEN;

pub struct NoteHashAndNullifier {
    /// The result of NoteHash::compute_note_hash
    pub note_hash: Field,
    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)
    pub inner_nullifier: Field,
}

/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type
/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by
/// address).
///
/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a
/// contract. The \`#[aztec]\` macro automatically creates such a contract library method called
/// \`_compute_note_hash_and_nullifier\`, which looks something like this:
///
/// \`\`\`
/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {
///     if note_type_id == MyNoteType::get_id() {
///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);
///
///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));
///
///         let note_hash = note.compute_note_hash(storage_slot);
///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(
///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },
///             storage_slot
///         );
///
///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);
///
///         Option::some(
///             aztec::messages::discovery::NoteHashAndNullifier {
///                 note_hash, inner_nullifier
///             }
///         )
///     } else if note_type_id == MyOtherNoteType::get_id() {
///           ... // Similar to above but calling MyOtherNoteType::unpack_content
///     } else {
///         Option::none() // Unknown note type ID
///     };
/// }
/// \`\`\`
type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;

/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,
/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.
/// This is the mechanism via which a contract updates its knowledge of its private state.
///
/// Receives the address of the contract on which discovery is performed along with its
/// \`compute_note_hash_and_nullifier\` function.
pub unconstrained fn discover_new_messages<Env>(
    contract_address: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
) {
    debug_log("Performing message discovery");

    private_logs::fetch_and_process_private_tagged_logs(
        contract_address,
        compute_note_hash_and_nullifier,
    );

    partial_notes::fetch_and_process_public_partial_note_completion_logs(
        contract_address,
        compute_note_hash_and_nullifier,
    );
}
`},111:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",source:`use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};

use dep::protocol_types::{
    address::AztecAddress,
    constants::MAX_NOTE_HASHES_PER_TX,
    debug_log::debug_log_format,
    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},
    traits::ToField,
};

/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*
/// the complete note information, since it does not include content, storage slot, etc.
pub struct DiscoveredNoteInfo {
    pub nonce: Field,
    pub note_hash: Field,
    pub inner_nullifier: Field,
}

/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible
/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in
/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most
/// cases it will contain a single element.
///
/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,
/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.
pub unconstrained fn attempt_note_nonce_discovery<Env>(
    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,
    first_nullifier_in_tx: Field,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    contract_address: AztecAddress,
    storage_slot: Field,
    note_type_id: Field,
    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,
) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {
    let discovered_notes = &mut BoundedVec::new();

    debug_log_format(
        "Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}",
        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],
    );

    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,
    // is one of the note hashes created by the transaction.
    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {
        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the
        // new note hashes array. We therefore know for each note in every transaction what its nonce is.
        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);

        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches
        // the note hash at the array index we're currently processing.
        // TODO(#11157): handle failed note_hash_and_nullifier computation
        let hashes = compute_note_hash_and_nullifier(
            packed_note,
            storage_slot,
            note_type_id,
            contract_address,
            candidate_nonce,
        )
            .expect(f"Failed to compute a note hash for note type {note_type_id}");

        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);
        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);

        if unique_note_hash == expected_unique_note_hash {
            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we
            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows
            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then
            // PXE may fail to realize that a given note has been nullified already, and calls to the application
            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an
            // application already has more direct means of making a call to it fail the transaction.
            discovered_notes.push(
                DiscoveredNoteInfo {
                    nonce: candidate_nonce,
                    note_hash: hashes.note_hash,
                    inner_nullifier: hashes.inner_nullifier,
                },
            );

            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present
            // multiple times in the same transaction with different nonces. This typically doesn't happen due to
            // notes containing random values in order to hide their contents.
        }
    });

    debug_log_format(
        "Discovered a total of {0} notes",
        [discovered_notes.len() as Field],
    );

    *discovered_notes
}

mod test {
    use crate::{
        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},
        note::{
            note_interface::{NoteHash, NoteType},
            note_metadata::SettledNoteMetadata,
            retrieved_note::RetrievedNote,
            utils::compute_note_hash_for_nullify,
        },
        oracle::random::random,
        test::mocks::mock_note::MockNote,
        utils::array,
    };

    use dep::protocol_types::{
        address::AztecAddress,
        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},
        traits::{FromField, Packable},
    };

    use super::attempt_note_nonce_discovery;

    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real
    // implementation, and as a sanity check that the interface is sufficient.
    unconstrained fn compute_note_hash_and_nullifier(
        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,
        storage_slot: Field,
        note_type_id: Field,
        contract_address: AztecAddress,
        nonce: Field,
    ) -> Option<NoteHashAndNullifier> {
        if note_type_id == MockNote::get_id() {
            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));
            let note_hash = note.compute_note_hash(storage_slot);

            let note_hash_for_nullify = compute_note_hash_for_nullify(
                RetrievedNote {
                    note,
                    contract_address,
                    metadata: SettledNoteMetadata::new(nonce).into(),
                },
                storage_slot,
            );

            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);

            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })
        } else {
            Option::none()
        }
    }

    global VALUE: Field = 7;
    global FIRST_NULLIFIER_IN_TX: Field = 47;
    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);
    global STORAGE_SLOT: Field = 99;

    #[test]
    unconstrained fn no_note_hashes() {
        let unique_note_hashes_in_tx = BoundedVec::new();
        let packed_note = BoundedVec::new();

        let discovered_notes = attempt_note_nonce_discovery(
            unique_note_hashes_in_tx,
            FIRST_NULLIFIER_IN_TX,
            compute_note_hash_and_nullifier,
            CONTRACT_ADDRESS,
            STORAGE_SLOT,
            MockNote::get_id(),
            packed_note,
        );

        assert_eq(discovered_notes.len(), 0);
    }

    #[test(should_fail_with = "Failed to compute a note hash")]
    unconstrained fn failed_hash_computation() {
        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);
        let packed_note = BoundedVec::new();
        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier

        let discovered_notes = attempt_note_nonce_discovery(
            unique_note_hashes_in_tx,
            FIRST_NULLIFIER_IN_TX,
            compute_note_hash_and_nullifier,
            CONTRACT_ADDRESS,
            STORAGE_SLOT,
            note_type_id,
            packed_note,
        );

        assert_eq(discovered_notes.len(), 0);
    }

    struct NoteAndData {
        note: MockNote,
        nonce: Field,
        note_hash: Field,
        unique_note_hash: Field,
        inner_nullifier: Field,
    }

    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {
        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);

        let retrieved_note = MockNote::new(value)
            .contract_address(CONTRACT_ADDRESS)
            .note_metadata(SettledNoteMetadata::new(nonce).into())
            .build_retrieved_note();
        let note = retrieved_note.note;

        let note_hash = note.compute_note_hash(STORAGE_SLOT);
        let unique_note_hash =
            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));
        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(
            retrieved_note,
            STORAGE_SLOT,
        ));

        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }
    }

    #[test]
    unconstrained fn single_note() {
        let note_index_in_tx = 2;
        let note_and_data = construct_note(VALUE, note_index_in_tx);

        let mut unique_note_hashes_in_tx = BoundedVec::from_array([
            random(), random(), random(), random(), random(), random(), random(),
        ]);
        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);

        let discovered_notes = attempt_note_nonce_discovery(
            unique_note_hashes_in_tx,
            FIRST_NULLIFIER_IN_TX,
            compute_note_hash_and_nullifier,
            CONTRACT_ADDRESS,
            STORAGE_SLOT,
            MockNote::get_id(),
            BoundedVec::from_array(note_and_data.note.pack()),
        );

        assert_eq(discovered_notes.len(), 1);
        let discovered_note = discovered_notes.get(0);

        assert_eq(discovered_note.nonce, note_and_data.nonce);
        assert_eq(discovered_note.note_hash, note_and_data.note_hash);
        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);
    }

    #[test]
    unconstrained fn multiple_notes_same_preimage() {
        let first_note_index_in_tx = 3;
        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);

        let second_note_index_in_tx = 5;
        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);

        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same
        // call.
        assert_eq(first_note_and_data.note, second_note_and_data.note);
        let packed_note = first_note_and_data.note.pack();

        let mut unique_note_hashes_in_tx = BoundedVec::from_array([
            random(), random(), random(), random(), random(), random(), random(),
        ]);
        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);
        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);

        let discovered_notes = attempt_note_nonce_discovery(
            unique_note_hashes_in_tx,
            FIRST_NULLIFIER_IN_TX,
            compute_note_hash_and_nullifier,
            CONTRACT_ADDRESS,
            STORAGE_SLOT,
            MockNote::get_id(),
            BoundedVec::from_array(packed_note),
        );

        assert_eq(discovered_notes.len(), 2);

        assert(discovered_notes.any(|discovered_note| {
            (discovered_note.nonce == first_note_and_data.nonce)
                & (discovered_note.note_hash == first_note_and_data.note_hash)
                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)
        }));

        assert(discovered_notes.any(|discovered_note| {
            (discovered_note.nonce == second_note_and_data.nonce)
                & (discovered_note.note_hash == second_note_and_data.note_hash)
                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)
        }));
    }
}
`},112:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",source:`use crate::{
    capsules::CapsuleArray,
    messages::{
        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},
        encoding::MAX_MESSAGE_CONTENT_LEN,
    },
    oracle::message_discovery::{deliver_note, get_log_by_tag},
    utils::array,
};

use dep::protocol_types::{
    address::AztecAddress,
    constants::PUBLIC_LOG_SIZE_IN_FIELDS,
    debug_log::debug_log_format,
    hash::sha256_to_field,
    traits::{Deserialize, Serialize, ToField},
};

global PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;

/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message
/// (e.g. the storage slot, note completion log tag, etc.).
pub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =
    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;

/// The slot in the PXE capsules where we store a \`CapsuleArray\` of \`DeliveredPendingPartialNote\`.
pub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(
    "AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT".as_bytes(),
);

/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial
/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of
/// the packed public content.
// TODO(#10273): improve how contract log siloing is handled
pub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;

/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log
/// size and extra fields in the log (e.g. the tag).
pub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =
    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;

/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the
/// log that will complete it and lead to a note being discovered and delivered.
#[derive(Serialize, Deserialize)]
pub(crate) struct DeliveredPendingPartialNote {
    pub(crate) note_completion_log_tag: Field,
    pub(crate) storage_slot: Field,
    pub(crate) note_type_id: Field,
    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,
    pub(crate) recipient: AztecAddress,
}

pub unconstrained fn process_partial_note_private_msg(
    contract_address: AztecAddress,
    recipient: AztecAddress,
    msg_metadata: u64,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
) {
    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =
        decode_partial_note_private_msg(msg_metadata, msg_content);

    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search
    // for the public log that will complete it.
    let pending = DeliveredPendingPartialNote {
        note_completion_log_tag,
        storage_slot,
        note_type_id,
        packed_private_note_content,
        recipient,
    };

    CapsuleArray::at(
        contract_address,
        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,
    )
        .push(pending);
}

/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the
/// notes being delivered to PXE if completed.
pub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(
    contract_address: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
) {
    let pending_partial_notes = CapsuleArray::at(
        contract_address,
        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,
    );

    debug_log_format(
        "{} pending partial notes",
        [pending_partial_notes.len() as Field],
    );

    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {
        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);
        if maybe_log.is_none() {
            debug_log_format(
                "Found no completion logs for partial note with tag {}",
                [pending_partial_note.note_completion_log_tag],
            );

            // Note that we're not removing the pending partial note from the capsule array, so we will continue
            // searching for this tagged log when performing message discovery in the future until we either find it or
            // the entry is somehow removed from the array.
        } else {
            debug_log_format(
                "Completion log found for partial note with tag {}",
                [pending_partial_note.note_completion_log_tag],
            );
            let log = maybe_log.unwrap();

            // Public logs have an extra field at the beginning with the contract address, which we use to verify
            // that we're getting the logs from the expected contract.
            // TODO(#10273): improve how contract log siloing is handled
            assert_eq(
                log.log_content.get(0),
                contract_address.to_field(),
                "Got a public log emitted by a different contract",
            );

            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the
            // private and public packed fields (i.e. the contents of the private message and public log sans the extra
            // fields) to get the complete packed content.
            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =
                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);
            let complete_packed_note = array::append(
                pending_partial_note.packed_private_note_content,
                packed_public_note_content,
            );

            let discovered_notes = attempt_note_nonce_discovery(
                log.unique_note_hashes_in_tx,
                log.first_nullifier_in_tx,
                compute_note_hash_and_nullifier,
                contract_address,
                pending_partial_note.storage_slot,
                pending_partial_note.note_type_id,
                complete_packed_note,
            );

            debug_log_format(
                "Discovered {0} notes for partial note with tag {1}",
                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],
            );

            discovered_notes.for_each(|discovered_note| {
                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a
                // temporary node connectivity issue - is simply throwing good enough here?
                assert(
                    deliver_note(
                        contract_address,
                        pending_partial_note.storage_slot,
                        discovered_note.nonce,
                        complete_packed_note,
                        discovered_note.note_hash,
                        discovered_note.inner_nullifier,
                        log.tx_hash,
                        pending_partial_note.recipient,
                    ),
                    "Failed to deliver note",
                );
            });

            // Because there is only a single log for a given tag, once we've processed the tagged log then we
            // simply delete the pending work entry, regardless of whether it was actually completed or not.
            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note
            // being completed.
            pending_partial_notes.remove(i);
        }
    });
}

fn decode_partial_note_private_msg(
    msg_metadata: u64,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {
    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field

    assert(
        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,
        f"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields",
    );

    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the
    // destructuring of the partial note private message encoding below must be updated as well.
    std::static_assert(
        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,
        "unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN",
    );

    // We currently have two fields that are not the partial note's packed representation, which are the storage slot
    // and the note completion log tag.
    let storage_slot = msg_content.get(0);
    let note_completion_log_tag = msg_content.get(1);

    let packed_private_note_content = array::subbvec(msg_content, 2);

    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)
}
`},114:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",source:`use crate::{
    capsules::CapsuleArray,
    messages::{
        discovery::{
            ComputeNoteHashAndNullifier,
            partial_notes::process_partial_note_private_msg,
            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},
            private_notes::process_private_note_msg,
        },
        encoding::decode_message,
        encryption::{aes128::AES128, log_encryption::LogEncryption},
        msg_type::{
            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,
        },
    },
    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},
    utils::array,
};

use protocol_types::{
    abis::event_selector::EventSelector,
    address::AztecAddress,
    debug_log::{debug_log, debug_log_format},
    traits::FromField,
};

/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that
/// are stored in the PXE capsules so that \`fetch_and_process_public_partial_note_completion_logs\` can later search for
/// public logs that will complete them.
pub unconstrained fn fetch_and_process_private_tagged_logs<Env>(
    contract_address: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
) {
    // We will eventually perform log discovery via tagging here, but for now we simply call the \`fetchTaggedLogs\` oracle.
    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then
    // retrieved and processed here.
    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);

    // Get the logs from the capsule array and process them one by one
    let logs =
        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);
    logs.for_each(|i, log: PendingTaggedLog| {
        process_log(contract_address, compute_note_hash_and_nullifier, log);
        logs.remove(i);
    });
}

/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.
///
/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the
/// transaction hash in which the notes would've been created (typically the same transaction in which the log was
/// emitted), along with the list of unique note hashes in said transaction and the \`compute_note_hash_and_nullifier\`
/// function.
///
/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to
/// search for the note's completion public log.
unconstrained fn process_log<Env>(
    contract_address: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    pending_tagged_log: PendingTaggedLog,
) {
    debug_log_format(
        "Processing log with tag {0}",
        [pending_tagged_log.log.get(0)],
    );

    // The tag is ignored for now.
    let ciphertext = array::subbvec(pending_tagged_log.log, 1);

    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);

    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We
    // have 3 log types: private note logs, partial note logs and event logs.

    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);

    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {
        debug_log("Processing private note msg");

        process_private_note_msg(
            contract_address,
            pending_tagged_log.tx_hash,
            pending_tagged_log.unique_note_hashes_in_tx,
            pending_tagged_log.first_nullifier_in_tx,
            pending_tagged_log.recipient,
            compute_note_hash_and_nullifier,
            msg_metadata,
            msg_content,
        );
    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {
        debug_log("Processing partial note private msg");

        process_partial_note_private_msg(
            contract_address,
            pending_tagged_log.recipient,
            msg_metadata,
            msg_content,
        );
    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {
        debug_log("Processing private event msg");

        // In the case of events, the msg metadata is the event selector.
        let event_selector = EventSelector::from_field(msg_metadata as Field);

        store_private_event_log(
            contract_address,
            pending_tagged_log.recipient,
            event_selector,
            msg_content,
            pending_tagged_log.tx_hash,
            pending_tagged_log.log_index_in_tx,
            pending_tagged_log.tx_index_in_block,
        );
    } else {
        debug_log_format("Unknown msg type id {0}", [msg_type_id as Field]);
    }
}
`},115:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",source:`use crate::{
    messages::{
        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},
        encoding::MAX_MESSAGE_CONTENT_LEN,
    },
    oracle,
    utils::array,
};
use protocol_types::{
    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,
};

/// The number of fields in a private note message content that are not the note's packed representation.
global PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;

/// The maximum length of the packed representation of a note's contents. This is limited by private log size,
/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).
pub global MAX_NOTE_PACKED_LEN: u32 =
    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;

pub unconstrained fn process_private_note_msg<Env>(
    contract_address: AztecAddress,
    tx_hash: Field,
    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,
    first_nullifier_in_tx: Field,
    recipient: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    msg_metadata: u64,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
) {
    let (note_type_id, storage_slot, packed_note) =
        decode_private_note_msg(msg_metadata, msg_content);

    attempt_note_discovery(
        contract_address,
        tx_hash,
        unique_note_hashes_in_tx,
        first_nullifier_in_tx,
        recipient,
        compute_note_hash_and_nullifier,
        storage_slot,
        note_type_id,
        packed_note,
    );
}

/// Attempts discovery of a note given information about its contents and the transaction in which it is
/// suspected the note was created.
pub unconstrained fn attempt_note_discovery<Env>(
    contract_address: AztecAddress,
    tx_hash: Field,
    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,
    first_nullifier_in_tx: Field,
    recipient: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    storage_slot: Field,
    note_type_id: Field,
    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,
) {
    let discovered_notes = attempt_note_nonce_discovery(
        unique_note_hashes_in_tx,
        first_nullifier_in_tx,
        compute_note_hash_and_nullifier,
        contract_address,
        storage_slot,
        note_type_id,
        packed_note,
    );

    debug_log_format(
        "Discovered {0} notes from a private message",
        [discovered_notes.len() as Field],
    );

    discovered_notes.for_each(|discovered_note| {
        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity
        // issue, and we should perhaps not have marked the tag index as taken.
        assert(
            oracle::message_discovery::deliver_note(
                contract_address,
                storage_slot,
                discovered_note.nonce,
                packed_note,
                discovered_note.note_hash,
                discovered_note.inner_nullifier,
                tx_hash,
                recipient,
            ),
            "Failed to deliver note",
        );
    });
}

fn decode_private_note_msg(
    msg_metadata: u64,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {
    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field

    assert(
        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,
        f"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields",
    );

    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the
    // destructuring of the private note message encoding below must be updated as well.
    std::static_assert(
        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,
        "unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN",
    );

    // We currently have a single field that is not the note's packed representation, which is the storage slot.
    let storage_slot = msg_content.get(0);
    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);

    (note_type_id, storage_slot, packed_note)
}
`},116:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",source:`// TODO(#12750): don't make these values assume we're using AES.
use crate::{
    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,
};

global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;

global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;

// The standard message layout is composed of:
//  - an initial field called the 'expanded metadata'
//  - an arbitrary number of fields following that called the 'message content'
//
// \`\`\`
// message: [ msg_expanded_metadata, ...msg_content ]
// \`\`\`
//
// The expanded metadata itself is interpreted as a u128, of which:
//  - the upper 64 bits are the message type id
//  - the lower 64 bits are called the 'message metadata'
//
// \`\`\`
// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]
//                        <---  64 bits --->|<--- 64 bits --->
// \`\`\`
//
// The meaning of the message metadata and message content depend on the value of the message type id. Note that there
// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different
// name to make it distinct from the message content given that it is not a full field.

/// The maximum length of a message's content, i.e. not including the expanded message metadata.
pub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;

/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with
/// \`decode_message\` to retrieve the original values.
///
/// - The \`msg_type\` is an identifier that groups types of messages that are all processed the same way, e.g. private
/// notes or events. Possible values are defined in \`aztec::messages::msg_type\`.
/// - The \`msg_metadata\` and \`msg_content\` are the values stored in the message, whose meaning depends on the
///  \`msg_type\`. The only special thing about \`msg_metadata\` that separates it from \`msg_content\` is that it is a u64
/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into
/// this smaller variable to achieve higher data efficiency.
pub fn encode_message<let N: u32>(
    msg_type: u64,
    msg_metadata: u64,
    msg_content: [Field; N],
) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {
    std::static_assert(
        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,
        "Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN",
    );

    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of
    // the message encoding below must be updated as well.
    std::static_assert(
        MESSAGE_EXPANDED_METADATA_LEN == 1,
        "unexpected value for MESSAGE_EXPANDED_METADATA_LEN",
    );
    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();

    message[0] = to_expanded_metadata(msg_type, msg_metadata);
    for i in 0..msg_content.len() {
        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];
    }

    message
}

/// Decodes a standard aztec-nr message, i.e. one created via \`encode_message\`, returning the original encoded values.
///
/// Note that \`encode_message\` returns a fixed size array while this function takes a \`BoundedVec\`: this is because
/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with
/// fixed-size messages, consider using \`BoundedVec::from_array\` to convert them.
pub unconstrained fn decode_message(
    message: BoundedVec<Field, MAX_MESSAGE_LEN>,
) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {
    assert(
        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,
        f"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields",
    );

    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of
    // the message encoding below must be updated as well.
    std::static_assert(
        MESSAGE_EXPANDED_METADATA_LEN == 1,
        "unexpected value for MESSAGE_EXPANDED_METADATA_LEN",
    );

    let msg_expanded_metadata = message.get(0);
    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);
    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);

    (msg_type_id, msg_metadata, msg_content)
}

global U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);

fn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {
    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are
    // expensive in circuits.
    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;
    let msg_metadata_field = msg_metadata as Field;

    type_field + msg_metadata_field
}

fn from_expanded_metadata(input: Field) -> (u64, u64) {
    input.assert_max_bit_size::<128>();
    let msg_metadata = (input as u64);
    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;
    // Use division instead of bit shift since bit shifts are expensive in circuits
    (msg_type, msg_metadata)
}

mod tests {
    use crate::utils::array::subarray::subarray;
    use super::{
        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,
        to_expanded_metadata,
    };

    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;
    global U128_MAX: Field = (2.pow_32(128) - 1);

    #[test]
    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {
        let encoded = encode_message(msg_type, msg_metadata, []);
        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =
            decode_message(BoundedVec::from_array(encoded));

        assert_eq(decoded_msg_type, msg_type);
        assert_eq(decoded_msg_metadata, msg_metadata);
        assert_eq(decoded_msg_content.len(), 0);
    }

    #[test]
    unconstrained fn encode_decode_short_message(
        msg_type: u64,
        msg_metadata: u64,
        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],
    ) {
        let encoded = encode_message(msg_type, msg_metadata, msg_content);
        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =
            decode_message(BoundedVec::from_array(encoded));

        assert_eq(decoded_msg_type, msg_type);
        assert_eq(decoded_msg_metadata, msg_metadata);
        assert_eq(decoded_msg_content.len(), msg_content.len());
        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);
    }

    #[test]
    unconstrained fn encode_decode_full_message(
        msg_type: u64,
        msg_metadata: u64,
        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],
    ) {
        let encoded = encode_message(msg_type, msg_metadata, msg_content);
        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =
            decode_message(BoundedVec::from_array(encoded));

        assert_eq(decoded_msg_type, msg_type);
        assert_eq(decoded_msg_metadata, msg_metadata);
        assert_eq(decoded_msg_content.len(), msg_content.len());
        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);
    }

    #[test]
    unconstrained fn to_expanded_metadata_packing() {
        // Test case 1: All bits set
        let packed = to_expanded_metadata(U64_MAX, U64_MAX);
        let (msg_type, msg_metadata) = from_expanded_metadata(packed);
        assert_eq(msg_type, U64_MAX);
        assert_eq(msg_metadata, U64_MAX);

        // Test case 2: Only log type bits set
        let packed = to_expanded_metadata(U64_MAX, 0);
        let (msg_type, msg_metadata) = from_expanded_metadata(packed);
        assert_eq(msg_type, U64_MAX);
        assert_eq(msg_metadata, 0);

        // Test case 3: Only msg_metadata bits set
        let packed = to_expanded_metadata(0, U64_MAX);
        let (msg_type, msg_metadata) = from_expanded_metadata(packed);
        assert_eq(msg_type, 0);
        assert_eq(msg_metadata, U64_MAX);

        // Test case 4: No bits set
        let packed = to_expanded_metadata(0, 0);
        let (msg_type, msg_metadata) = from_expanded_metadata(packed);
        assert_eq(msg_type, 0);
        assert_eq(msg_metadata, 0);
    }

    #[test]
    unconstrained fn from_expanded_metadata_packing() {
        // Test case 1: All bits set
        let input = U128_MAX as Field;
        let (msg_type, msg_metadata) = from_expanded_metadata(input);
        assert_eq(msg_type, U64_MAX);
        assert_eq(msg_metadata, U64_MAX);

        // Test case 2: Only log type bits set
        let input = (U128_MAX - U64_MAX as Field);
        let (msg_type, msg_metadata) = from_expanded_metadata(input);
        assert_eq(msg_type, U64_MAX);
        assert_eq(msg_metadata, 0);

        // Test case 3: Only msg_metadata bits set
        let input = U64_MAX as Field;
        let (msg_type, msg_metadata) = from_expanded_metadata(input);
        assert_eq(msg_type, 0);
        assert_eq(msg_metadata, U64_MAX);

        // Test case 4: No bits set
        let input = 0;
        let (msg_type, msg_metadata) = from_expanded_metadata(input);
        assert_eq(msg_type, 0);
        assert_eq(msg_metadata, 0);
    }

    #[test]
    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {
        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);
        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);

        assert_eq(original_msg_type, unpacked_msg_type);
        assert_eq(original_msg_metadata, unpacked_msg_metadata);
    }
}
`},117:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",source:`use dep::protocol_types::{
    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},
    hash::poseidon2_hash_with_separator,
    point::Point,
};

use crate::{
    keys::{
        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,
        ephemeral::generate_ephemeral_key_pair,
    },
    messages::{
        encryption::log_encryption::{
            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,
            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,
            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,
        },
        logs::arithmetic_generics_utils::{
            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,
        },
    },
    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},
    prelude::AztecAddress,
    utils::{
        array,
        conversion::{
            bytes_to_fields::{bytes_from_fields, bytes_to_fields},
            fields_to_bytes::{fields_from_bytes, fields_to_bytes},
        },
        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},
        random::get_random_bytes,
    },
};

use std::aes128::aes128_encrypt;

fn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(
    shared_secret: Point,
) -> [u8; 32] {
    let rand1: Field = poseidon2_hash_with_separator(
        [shared_secret.x, shared_secret.y],
        GENERATOR_INDEX__SYMMETRIC_KEY,
    );
    let rand2: Field = poseidon2_hash_with_separator(
        [shared_secret.x, shared_secret.y],
        GENERATOR_INDEX__SYMMETRIC_KEY_2,
    );
    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();
    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();
    let mut bytes: [u8; 32] = [0; 32];
    for i in 0..16 {
        bytes[i] = rand1_bytes[i];
        bytes[i + 1] = rand2_bytes[i];
    }
    bytes
}

// TODO(#10537): Consider nuking this function.
fn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(
    shared_secret: Point,
) -> [u8; 32] {
    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);

    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();
    for i in 0..shared_secret_bytes.len() {
        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];
    }
    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;

    sha256::digest(shared_secret_bytes_with_separator)
}

fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(
    shared_secret: Point,
    randomness_extraction_fn: fn(Point) -> [u8; 32],
) -> ([u8; 16], [u8; 16]) {
    let random_256_bits = randomness_extraction_fn(shared_secret);
    let mut sym_key = [0; 16];
    let mut iv = [0; 16];
    for i in 0..16 {
        sym_key[i] = random_256_bits[i];
        iv[i] = random_256_bits[i + 16];
    }
    (sym_key, iv)
}

// TODO(#10537): Consider nuking this function.
pub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(
    shared_secret: Point,
) -> ([u8; 16], [u8; 16]) {
    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(
        shared_secret,
        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,
    )
}

// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.
pub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(
    shared_secret: Point,
) -> ([u8; 16], [u8; 16]) {
    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(
        shared_secret,
        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,
    )
}

pub struct AES128 {}

impl LogEncryption for AES128 {
    fn encrypt_log<let PLAINTEXT_LEN: u32>(
        plaintext: [Field; PLAINTEXT_LEN],
        recipient: AztecAddress,
    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {
        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.
        // (This process is then reversed when processing the log in \`do_process_log\`)
        let plaintext_bytes = fields_to_bytes(plaintext);

        // *****************************************************************************
        // Compute the shared secret
        // *****************************************************************************

        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();

        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;

        // (not to be confused with the tagging shared secret)
        let ciphertext_shared_secret =
            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);

        // TODO: also use this shared secret for deriving note randomness.

        // *****************************************************************************
        // Convert the plaintext into whatever format the encryption function expects
        // *****************************************************************************

        // Already done for this strategy: AES expects bytes.

        // *****************************************************************************
        // Encrypt the plaintext
        // *****************************************************************************

        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(
            ciphertext_shared_secret,
        );

        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);

        // |full_pt| = |pt_length| + |pt|
        // |pt_aes_padding| = 16 - (|full_pt| % 16)
        // or... since a % b is the same as a - b * (a // b) (integer division), so:
        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))
        // |ct| = |full_pt| + |pt_aes_padding|
        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))
        //      = 16 + 16 * (|full_pt| // 16)
        //      = 16 * (1 + |full_pt| // 16)
        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));

        // *****************************************************************************
        // Compute the header ciphertext
        // *****************************************************************************

        // Header contains only the length of the ciphertext stored in 2 bytes.
        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.
        // This would be more costly constraint-wise but cheaper DA-wise.
        let mut header_plaintext: [u8; 2] = [0 as u8; 2];
        let ciphertext_bytes_length = ciphertext_bytes.len();
        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;
        header_plaintext[1] = ciphertext_bytes_length as u8;

        // TODO: this is insecure and wasteful:
        // "Insecure", because the esk shouldn't be used twice (once for the header,
        // and again for the proper ciphertext) (at least, I never got the
        // "go ahead" that this would be safe, unfortunately).
        // "Wasteful", because the exact same computation is happening further down.
        // I'm leaving that 2nd computation where it is, because this 1st computation
        // will be imminently deleted, when the header logic is deleted.
        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(
            ciphertext_shared_secret,
        );

        // Note: the aes128_encrypt builtin fn automatically appends bytes to the
        // input, according to pkcs#7; hence why the output \`header_ciphertext_bytes\` is 16
        // bytes larger than the input in this case.
        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);
        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:
        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);

        // *****************************************************************************
        // Prepend / append more bytes of data to the ciphertext, before converting back
        // to fields.
        // *****************************************************************************

        let mut log_bytes_padding_to_mult_31 =
            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();
        // Safety: this randomness won't be constrained to be random. It's in the
        // interest of the executor of this fn to encrypt with random bytes.
        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };

        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();

        assert(
            log_bytes.len() % 31 == 0,
            "Unexpected error: log_bytes.len() should be divisible by 31, by construction.",
        );

        log_bytes[0] = eph_pk_sign_byte;
        let mut offset = 1;
        for i in 0..header_ciphertext_bytes.len() {
            log_bytes[offset + i] = header_ciphertext_bytes[i];
        }
        offset += header_ciphertext_bytes.len();

        for i in 0..ciphertext_bytes.len() {
            log_bytes[offset + i] = ciphertext_bytes[i];
        }
        offset += ciphertext_bytes.len();

        for i in 0..log_bytes_padding_to_mult_31.len() {
            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];
        }

        assert(
            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),
            "Something has gone wrong",
        );

        // *****************************************************************************
        // Convert bytes back to fields
        // *****************************************************************************

        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes
        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function
        // should cover a full field.
        let log_bytes_as_fields = bytes_to_fields(log_bytes);

        // *****************************************************************************
        // Prepend / append fields, to create the final log
        // *****************************************************************************

        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];

        ciphertext[0] = eph_pk.x;

        let mut offset = 1;
        for i in 0..log_bytes_as_fields.len() {
            ciphertext[offset + i] = log_bytes_as_fields[i];
        }
        offset += log_bytes_as_fields.len();

        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {
            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log
            // (all the "real" log fields contain at most 31 bytes because of the way we convert the bytes to fields).
            // TODO(#12749): Long term, this is not a good solution.

            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its
            // contents publicly. It is therefore fine to trust the sender to provide random padding.
            let field_bytes = unsafe { get_random_bytes::<31>() };
            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);
        }

        ciphertext
    }

    unconstrained fn decrypt_log(
        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,
        recipient: AztecAddress,
    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {
        let eph_pk_x = ciphertext.get(0);

        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(
            ciphertext,
            EPH_PK_X_SIZE_IN_FIELDS,
        );

        // Convert the ciphertext represented as fields to a byte representation (its original format)
        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);

        // First byte of the ciphertext represents the ephemeral public key sign
        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;
        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point
        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);

        // Derive shared secret and symmetric key
        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);
        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(
            ciphertext_shared_secret,
        );

        // Extract the header ciphertext
        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte
        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =
            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);
        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work
        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length
        // is fixed. But we do it anyway to not have to have duplicate oracles.
        let header_ciphertext_bvec =
            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);

        // Decrypt header
        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);

        // Extract ciphertext length from header (2 bytes, big-endian)
        let ciphertext_length =
            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);

        // Extract and decrypt main ciphertext
        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;
        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =
            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);
        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =
            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);

        // Decrypt main ciphertext and return it
        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);

        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.
        fields_from_bytes(plaintext_bytes)
    }
}

mod test {
    use crate::{
        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,
        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},
        test::helpers::test_environment::TestEnvironment,
    };
    use super::AES128;
    use protocol_types::{
        address::AztecAddress,
        indexed_tagging_secret::IndexedTaggingSecret,
        traits::{Deserialize, FromField},
    };
    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};

    #[test]
    unconstrained fn encrypt_decrypt_log() {
        let mut env = TestEnvironment::new();
        // Advance 1 block so we can read historic state from private
        env.advance_block_by(1);

        let plaintext = [1, 2, 3];

        let recipient = AztecAddress::from_field(
            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,
        );

        // Mock random values for deterministic test
        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;
        let _ = OracleMock::mock("getRandomField").returns(eph_sk).times(1);

        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;
        let _ = OracleMock::mock("getRandomField").returns(randomness).times(1000000);

        let _ = OracleMock::mock("getIndexedTaggingSecretAsSender").returns(
            IndexedTaggingSecret::deserialize([69420, 1337]),
        );
        let _ = OracleMock::mock("incrementAppTaggingSecretIndexAsSender").returns(());

        // Encrypt the log
        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));

        // Mock shared secret for deterministic test
        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(
            EmbeddedCurveScalar::from_field(eph_sk),
            recipient,
        );
        let _ = OracleMock::mock("getSharedSecret").returns(shared_secret);

        // Decrypt the log
        let decrypted = AES128::decrypt_log(encrypted_log, recipient);

        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length
        // at compile time. For this reason we need to convert the original input to a BoundedVec.
        let plaintext_bvec =
            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);

        // Verify decryption matches original plaintext
        assert_eq(decrypted, plaintext_bvec, "Decrypted bytes should match original plaintext");

        // The following is a workaround of "struct is never constructed" Noir compilation error (we only ever use
        // static methods of the struct).
        let _ = AES128 {};
    }
}
`},124:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",source:`use crate::{
    context::PrivateContext,
    messages::{
        encoding::encode_message,
        encryption::{aes128::AES128, log_encryption::LogEncryption},
        logs::utils::prefix_with_tag,
        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},
    },
    note::{note_emission::NoteEmission, note_interface::NoteType},
};
use protocol_types::{
    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,
    traits::Packable,
};

// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?
fn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {
    // TODO(#8589): use typesystem to skip this check when not needed
    let note_exists =
        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);
    assert(note_exists, "Can only emit a note log for an existing note.");
}

pub fn compute_note_log<Note, let N: u32>(
    note: Note,
    storage_slot: Field,
    recipient: AztecAddress,
    sender: AztecAddress,
) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]
where
    Note: NoteType + Packable<N>,
{
    compute_log(
        note,
        storage_slot,
        recipient,
        sender,
        PRIVATE_NOTE_MSG_TYPE_ID,
    )
}

pub fn compute_partial_note_log<Note, let N: u32>(
    note: Note,
    storage_slot: Field,
    recipient: AztecAddress,
    sender: AztecAddress,
) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]
where
    Note: NoteType + Packable<N>,
{
    compute_log(
        note,
        storage_slot,
        recipient,
        sender,
        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,
    )
}

fn compute_log<Note, let N: u32>(
    note: Note,
    storage_slot: Field,
    recipient: AztecAddress,
    sender: AztecAddress,
    msg_type: u64,
) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]
where
    Note: NoteType + Packable<N>,
{
    let packed_note = note.pack();

    // A note message's content is the storage slot followed by the packed note representation
    let mut msg_content: [Field; N + 1] = std::mem::zeroed();
    msg_content[0] = storage_slot;
    for i in 0..packed_note.len() {
        msg_content[1 + i] = packed_note[i];
    }

    // Notes use the note type id for metadata
    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);

    let ciphertext = AES128::encrypt_log(plaintext, recipient);

    let log = prefix_with_tag(ciphertext, sender, recipient);

    log
}

pub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(
    note: Note,
    storage_slot: Field,
    recipient: AztecAddress,
    sender: AztecAddress,
) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]
where
    Note: NoteType + Packable<N>,
{
    compute_note_log(note, storage_slot, recipient, sender)
}

/// Sends an encrypted message to \`recipient\` with the content of the note, which they will discover when processing
/// private logs.
pub fn encode_and_encrypt_note<Note, let N: u32>(
    context: &mut PrivateContext,
    recipient: AztecAddress,
    // We need this because to compute a tagging secret, we require a sender:
    sender: AztecAddress,
) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()
where
    Note: NoteType + Packable<N>,
{
    |e: NoteEmission<Note>| {
        let note = e.note;
        let storage_slot = e.storage_slot;
        let note_hash_counter = e.note_hash_counter;
        assert_note_exists(*context, note_hash_counter);

        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);
        // Regardless of the original note size \`N, the log is padded with random bytes up to
        // \`PRIVATE_LOG_SIZE_IN_FIELDS\` to prevent leaking information about the actual size.
        let length = encrypted_log.len();
        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);
    }
}

/// Same as \`encode_and_encrypt_note\`, except encryption is unconstrained. This means that the sender is free to make
/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to
/// decrypt and process the payload, **leading to the note being lost**.
///
/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.
pub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(
    context: &mut PrivateContext,
    recipient: AztecAddress,
    // We need this because to compute a tagging secret, we require a sender:
    sender: AztecAddress,
) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()
where
    Note: NoteType + Packable<N>,
{
    |e: NoteEmission<Note>| {
        let note = e.note;
        let storage_slot = e.storage_slot;
        let note_hash_counter = e.note_hash_counter;

        assert_note_exists(*context, note_hash_counter);

        // Safety: this function does not constrain the encryption of the log, as explained on its description.
        let encrypted_log =
            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };
        // Regardless of the original note size \`N\`, the log is padded with random bytes up to
        // \`PRIVATE_LOG_SIZE_IN_FIELDS\` to prevent leaking information about the actual size.
        let length = encrypted_log.len();
        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);
    }
}
`},125:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",source:`use crate::{
    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},
    prelude::AztecAddress,
};

pub(crate) fn prefix_with_tag<let L: u32>(
    log_without_tag: [Field; L],
    sender: AztecAddress,
    recipient: AztecAddress,
) -> [Field; L + 1] {
    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will
    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the
    // note automatically.
    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };
    increment_app_tagging_secret_index_as_sender(sender, recipient);

    let mut log_with_tag = [0; L + 1];

    log_with_tag[0] = tag;
    for i in 0..log_without_tag.len() {
        log_with_tag[i + 1] = log_without_tag[i];
    }

    log_with_tag
}

mod test {
    use super::prefix_with_tag;
    use protocol_types::{
        address::AztecAddress,
        indexed_tagging_secret::IndexedTaggingSecret,
        traits::{Deserialize, FromField},
    };
    use std::test::OracleMock;

    #[test]
    unconstrained fn prefixing_with_tag() {
        let sender = AztecAddress::from_field(1);
        let recipient = AztecAddress::from_field(2);

        let app_tagging_secret = 42;
        let index = 5;

        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because
        // direct instantiation functionality is not exposed.
        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);

        // Mock the tagging oracles
        let _ = OracleMock::mock("getIndexedTaggingSecretAsSender").returns(indexed_tagging_secret);
        let _ = OracleMock::mock("incrementAppTaggingSecretIndexAsSender").returns(());

        let log_without_tag = [1, 2, 3];
        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);

        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];

        // Check tag was prefixed correctly
        assert_eq(log_with_tag, expected_result, "Tag was not prefixed correctly");
    }
}
`},130:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",source:`use crate::context::PrivateContext;
use crate::note::{
    note_emission::NoteEmission,
    note_interface::{NoteHash, NoteType},
    retrieved_note::RetrievedNote,
    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},
};
use crate::oracle::notes::notify_created_note;
use protocol_types::traits::Packable;

pub fn create_note<Note, let N: u32>(
    context: &mut PrivateContext,
    storage_slot: Field,
    note: Note,
) -> NoteEmission<Note>
where
    Note: NoteType + NoteHash + Packable<N>,
{
    let note_hash_counter = context.side_effect_counter;

    let note_hash = note.compute_note_hash(storage_slot);

    let packed_note = Note::pack(note);
    notify_created_note(
        storage_slot,
        Note::get_id(),
        packed_note,
        note_hash,
        note_hash_counter,
    );

    context.push_note_hash(note_hash);

    NoteEmission::new(note, storage_slot, note_hash_counter)
}

// Note: This function is currently totally unused.
pub fn destroy_note<Note>(
    context: &mut PrivateContext,
    retrieved_note: RetrievedNote<Note>,
    storage_slot: Field,
)
where
    Note: NoteHash,
{
    let note_hash_for_read_request =
        compute_note_hash_for_read_request(retrieved_note, storage_slot);

    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)
}

pub fn destroy_note_unsafe<Note>(
    context: &mut PrivateContext,
    retrieved_note: RetrievedNote<Note>,
    note_hash_for_read_request: Field,
)
where
    Note: NoteHash,
{
    let note_hash_for_nullify =
        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);
    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);

    let note_hash = if retrieved_note.metadata.is_settled() {
        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.
        0
    } else {
        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been
        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its
        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both
        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's
        // a siloed note hash.
        note_hash_for_nullify
    };

    context.push_nullifier_for_note_hash(nullifier, note_hash)
}
`},132:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",source:`/**
 * A note emission struct containing the information required for emitting a note.
 * The exact \`emit\` logic is passed in by the application code
 */
pub struct NoteEmission<Note> {
    pub note: Note,
    pub storage_slot: Field,
    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled
}

impl<Note> NoteEmission<Note> {
    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {
        Self { note, storage_slot, note_hash_counter }
    }

    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {
        _emit(self);
    }

    pub fn discard(_self: Self) {}
}

/**
 * A struct wrapping note emission in \`Option<T>\`.
 * This is the struct provided to application codes, which can be used to emit
 * only when a note was actually inserted.
 * It is fairly common to have cases where a function conditionally inserts,
 * and this allows us to keep the same API for emission in both cases (e.g. inserting
 * a change note in a token's transfer function only when there is "change" left).
 */
pub struct OuterNoteEmission<Note> {
    emission: Option<NoteEmission<Note>>,
}

impl<Note> OuterNoteEmission<Note> {
    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {
        Self { emission }
    }

    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {
        if self.emission.is_some() {
            _emit(self.emission.unwrap());
        }
    }

    pub fn discard(_self: Self) {}
}
`},135:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",source:`use crate::{
    context::PrivateContext,
    note::{
        note_getter_options::{
            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,
        },
        note_interface::{NoteHash, NoteType},
        note_viewer_options::NoteViewerOptions,
        retrieved_note::RetrievedNote,
        utils::compute_note_hash_for_read_request,
    },
    oracle,
    utils::{array, comparison::compare},
};

use protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};

pub use crate::note::constants::MAX_NOTES_PER_PAGE;

mod test;

fn extract_property_value_from_selector<let N: u32>(
    packed_note: [Field; N],
    selector: PropertySelector,
) -> Field {
    // Selectors use PropertySelectors in order to locate note properties inside the packed note.
    // This allows easier packing and custom (un)packing schemas. A note property is located
    // inside the packed note using the index inside the array, a byte offset and a length.
    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();
    let offset = selector.offset;
    let length = selector.length;
    let mut value_field = 0 as Field;
    let mut acc: Field = 1;
    for i in 0..32 {
        if i < length {
            value_field += value[(31 + offset - i) as u32] as Field * acc;
            acc = acc * 256;
        }
    }
    value_field
}

fn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {
    for i in 0..selects.len() {
        let select = selects.get_unchecked(i).unwrap_unchecked();
        let value_field =
            extract_property_value_from_selector(packed_note, select.property_selector);

        assert(
            compare(value_field, select.comparator, select.value.to_field()),
            "Mismatch return note field.",
        );
    }
}

fn check_notes_order<let N: u32>(
    fields_0: [Field; N],
    fields_1: [Field; N],
    sorts: BoundedVec<Option<Sort>, N>,
) {
    for i in 0..sorts.len() {
        let sort = sorts.get_unchecked(i).unwrap_unchecked();
        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);
        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);
        let eq = field_0 == field_1;
        let lt = field_0.lt(field_1);
        if sort.order == SortOrder.ASC {
            assert(eq | lt, "Return notes not sorted in ascending order.");
        } else if !eq {
            assert(!lt, "Return notes not sorted in descending order.");
        }
    }
}

pub fn get_note<Note, let N: u32>(
    context: &mut PrivateContext,
    storage_slot: Field,
) -> (RetrievedNote<Note>, Field)
where
    Note: NoteType + NoteHash + Packable<N>,
{
    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do
    // is check that the metadata is correct, and that the note exists.
    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };

    // For settled notes, the contract address is implicitly checked since the hash returned from
    // \`compute_note_hash_for_read_request\` is siloed and kernels verify the siloing during note read request
    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract
    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all
    // note types.
    assert(
        retrieved_note.contract_address.eq(context.this_address()),
        "Note contract address mismatch.",
    );

    let note_hash_for_read_request =
        compute_note_hash_for_read_request(retrieved_note, storage_slot);
    context.push_note_hash_read_request(note_hash_for_read_request);

    (retrieved_note, note_hash_for_read_request)
}

/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or
/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read
/// requests, which can save constraints when computing the note's nullifiers.
///
/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_
/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted
/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe
/// abstractions such as aztec-nr's state variables should be used instead.
pub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(
    context: &mut PrivateContext,
    storage_slot: Field,
    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,
    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)
where
    Note: NoteType + NoteHash + Eq + Packable<N>,
{
    // Safety: The notes are constrained below.
    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };

    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that
    // these checks correctly reject bad notes.
    constrain_get_notes_internal(context, storage_slot, opt_notes, options)
}

unconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(
    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],
    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],
    preprocessor_args: PREPROCESSOR_ARGS,
) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {
    preprocessor(notes, preprocessor_args)
}

fn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(
    context: &mut PrivateContext,
    storage_slot: Field,
    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],
    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,
    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)
where
    Note: NoteType + NoteHash + Eq + Packable<N>,
{
    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that
    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private
    // kernel will later validate that these note actually exist, so transformations would cause for that check
    // to fail.
    let filter_fn = options.filter;
    let filter_args = options.filter_args;
    let filtered_notes = filter_fn(opt_notes, filter_args);

    let notes = array::collapse(filtered_notes);
    let mut note_hashes = BoundedVec::new();

    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also
    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound
    // for the runtime length, and can therefore have fewer loop iterations.
    assert(notes.len() <= options.limit, "Got more notes than limit.");

    let mut prev_packed_note = [0; N];
    for i in 0..options.limit {
        if i < notes.len() {
            let retrieved_note = notes.get_unchecked(i);

            // For settled notes, the contract address is implicitly checked since the hash returned from
            // \`compute_note_hash_for_read_request\` is siloed and kernels verify the siloing during note read request
            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the
            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform
            // this check on all note types.
            assert(
                retrieved_note.contract_address.eq(context.this_address()),
                "Note contract address mismatch.",
            );

            let packed_note = retrieved_note.note.pack();
            check_packed_note(packed_note, options.selects);
            if i != 0 {
                check_notes_order(prev_packed_note, packed_note, options.sorts);
            }
            prev_packed_note = packed_note;

            let note_hash_for_read_request =
                compute_note_hash_for_read_request(retrieved_note, storage_slot);
            context.push_note_hash_read_request(note_hash_for_read_request);
            note_hashes.push(note_hash_for_read_request);
        };
    }

    (notes, note_hashes)
}

unconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>
where
    Note: NoteType + Packable<N>,
{
    let opt_notes: [_; 1] = oracle::notes::get_notes(
        storage_slot,
        0,
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        1, // limit
        0, // offset
        NoteStatus.ACTIVE,
    );

    opt_notes[0].expect(f"Failed to get a note") // Notice: we don't allow dummies to be returned from get_note (singular).
}

unconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(
    storage_slot: Field,
    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,
) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]
where
    Note: NoteType + Packable<N>,
{
    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.
    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =
        flatten_options(options.selects, options.sorts);

    let opt_notes = oracle::notes::get_notes(
        storage_slot,
        num_selects,
        select_by_indexes,
        select_by_offsets,
        select_by_lengths,
        select_values,
        select_comparators,
        sort_by_indexes,
        sort_by_offsets,
        sort_by_lengths,
        sort_order,
        options.limit,
        options.offset,
        options.status,
    );

    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)
}

/// Unconstrained variant of \`get_notes\`, meant to be used in unconstrained execution contexts. Notably only the note
/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).
pub unconstrained fn view_notes<Note, let N: u32>(
    storage_slot: Field,
    options: NoteViewerOptions<Note, N>,
) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>
where
    Note: NoteType + Packable<N> + Eq,
{
    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =
        flatten_options(options.selects, options.sorts);

    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the
    // metadata in order to prove existence.
    let opt_notes = oracle::notes::get_notes(
        storage_slot,
        num_selects,
        select_by_indexes,
        select_by_offsets,
        select_by_lengths,
        select_values,
        select_comparators,
        sort_by_indexes,
        sort_by_offsets,
        sort_by_lengths,
        sort_order,
        options.limit,
        options.offset,
        options.status,
    );

    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to
    // convert it into a BoundedVec.
    array::collapse(opt_notes).map(
        // view_notes just returns the actual note, so we drop the metadata
        |retrieved_note| retrieved_note.note,
    )
}

unconstrained fn flatten_options<let N: u32>(
    selects: BoundedVec<Option<Select>, N>,
    sorts: BoundedVec<Option<Sort>, N>,
) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {
    let mut num_selects = 0;
    let mut select_by_indexes = [0; N];
    let mut select_by_offsets = [0; N];
    let mut select_by_lengths = [0; N];
    let mut select_values = [0; N];
    let mut select_comparators = [0; N];

    for i in 0..selects.len() {
        let select = selects.get(i);
        if select.is_some() {
            select_by_indexes[num_selects as u32] =
                select.unwrap_unchecked().property_selector.index;
            select_by_offsets[num_selects as u32] =
                select.unwrap_unchecked().property_selector.offset;
            select_by_lengths[num_selects as u32] =
                select.unwrap_unchecked().property_selector.length;
            select_values[num_selects as u32] = select.unwrap_unchecked().value;
            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;
            num_selects += 1;
        };
    }

    let mut sort_by_indexes = [0; N];
    let mut sort_by_offsets = [0; N];
    let mut sort_by_lengths = [0; N];
    let mut sort_order = [0; N];
    for i in 0..sorts.len() {
        let sort = sorts.get(i);
        if sort.is_some() {
            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;
            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;
            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;
            sort_order[i] = sort.unwrap_unchecked().order;
        };
    }

    (
        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,
        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,
    )
}
`},138:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",source:`use protocol_types::traits::Serialize;

// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will
// eventually be simplified into something closer to:
//
// pub enum NoteMetadata {
//   PendingSamePhase{ note_hash_counter: u32 },
//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },
//   Settled{ nonce: Field },
// }
//
// For now, we have \`NoteMetadata\` acting as a sort of tagged union.

struct NoteStageEnum {
    /// A note that was created in the transaction that is currently being executed, during the current execution phase,
    /// i.e. non-revertible or revertible.
    ///
    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction
    /// (becoming a transient note).
    PENDING_SAME_PHASE: u8,
    /// A note that was created in the transaction that is currently being executed, during the previous execution
    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then
    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is
    /// the revertible phase.
    ///
    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this
    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)
    /// in order to avoid double spends once they become settled.
    PENDING_PREVIOUS_PHASE: u8,
    /// A note that was created in a prior transaction and is therefore already in the note hash tree.
    SETTLED: u8,
}

global NoteStage: NoteStageEnum =
    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };

/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel
/// read requests, as well as the correct nullifier to avoid double-spends.
///
/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In
/// order to access the underlying fields callers must first find the appropriate stage (e.g. via \`is_settled()\`) and
/// then convert this into the appropriate type (e.g. via \`to_settled()\`).
#[derive(Eq, Serialize)]
pub struct NoteMetadata {
    stage: u8,
    maybe_nonce: Field,
}

impl NoteMetadata {
    /// Constructs a \`NoteMetadata\` object from optional note hash counter and nonce. Both a zero note hash counter and
    /// a zero nonce are invalid, so those are used to signal non-existent values.
    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {
        if nonzero_note_hash_counter {
            if maybe_nonce == 0 {
                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }
            } else {
                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }
            }
        } else if maybe_nonce != 0 {
            Self { stage: NoteStage.SETTLED, maybe_nonce }
        } else {
            panic(
                f"Note has a zero note hash counter and no nonce - existence cannot be proven",
            )
        }
    }

    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current
    /// transaction during the current execution phase (either non-revertible or revertible).
    pub fn is_pending_same_phase(self) -> bool {
        self.stage == NoteStage.PENDING_SAME_PHASE
    }

    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current
    /// transaction during an execution phase prior to the current one. Because private execution only has two phases
    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current
    /// phase is the revertible phase.
    pub fn is_pending_previous_phase(self) -> bool {
        self.stage == NoteStage.PENDING_PREVIOUS_PHASE
    }

    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already
    /// in the note hash tree.
    pub fn is_settled(self) -> bool {
        self.stage == NoteStage.SETTLED
    }

    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.
    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {
        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);
        PendingSamePhaseNoteMetadata::new()
    }

    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.
    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {
        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);
        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)
    }

    /// Asserts that the metadata is that of a settled note and converts it accordingly.
    pub fn to_settled(self) -> SettledNoteMetadata {
        assert_eq(self.stage, NoteStage.SETTLED);
        SettledNoteMetadata::new(self.maybe_nonce)
    }
}

impl From<PendingSamePhaseNoteMetadata> for NoteMetadata {
    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {
        NoteMetadata::from_raw_data(true, std::mem::zeroed())
    }
}

impl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {
    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {
        NoteMetadata::from_raw_data(true, value.nonce())
    }
}

impl From<SettledNoteMetadata> for NoteMetadata {
    fn from(value: SettledNoteMetadata) -> Self {
        NoteMetadata::from_raw_data(false, value.nonce())
    }
}

/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel
/// read requests, as well as the correct nullifier to avoid double-spends.
///
/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being
/// executed during the current execution phase (either non-revertible or revertible).
pub struct PendingSamePhaseNoteMetadata {
    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no
    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash
    // counter we cannot constrain its value (and don't need to - only that it is non-zero).
}

impl PendingSamePhaseNoteMetadata {
    pub fn new() -> Self {
        Self {}
    }
}

/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel
/// read requests, as well as the correct nullifier to avoid double-spends.
///
/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently
/// being executed, during the previous execution phase. Because there are only two phases and their order is always the
/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,
/// and that the current phase is the revertible phase.
pub struct PendingPreviousPhaseNoteMetadata {
    nonce: Field,
    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot
    // constrain its value (and don't need to - only that it is non-zero).
}

impl PendingPreviousPhaseNoteMetadata {
    pub fn new(nonce: Field) -> Self {
        Self { nonce }
    }

    pub fn nonce(self) -> Field {
        self.nonce
    }
}

/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel
/// read requests, as well as the correct nullifier to avoid double-spends.
///
/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the
/// note hash tree.
pub struct SettledNoteMetadata {
    nonce: Field,
}

impl SettledNoteMetadata {
    pub fn new(nonce: Field) -> Self {
        Self { nonce }
    }

    pub fn nonce(self) -> Field {
        self.nonce
    }
}
`},140:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",source:`use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};
use protocol_types::{
    address::AztecAddress,
    traits::{FromField, Packable, Serialize, ToField},
    utils::arrays::array_concat,
};

// Number of fields a RetrievedNote adds to the packed or serialized representation of a note
// +1 for the contract address
// +2 for the note metadata
pub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;

/// A container of a note and the metadata required to prove its existence, regardless of whether the note is
/// pending (created in the current transaction) or settled (created in a previous transaction).
#[derive(Eq)]
pub struct RetrievedNote<NOTE> {
    pub note: NOTE,
    pub contract_address: AztecAddress,
    pub metadata: NoteMetadata,
}

impl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>
where
    NOTE: Serialize<N>,
{
    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {
        array_concat(
            array_concat(self.note.serialize(), [self.contract_address.to_field()]),
            self.metadata.serialize(),
        )
    }
}

// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack
// functionality resides in TS (oracle.ts and txe_service.ts).
pub fn unpack_retrieved_note<NOTE, let N: u32>(
    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],
) -> RetrievedNote<NOTE>
where
    NOTE: Packable<N>,
{
    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);
    let nonce = packed_retrieved_note[1];
    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;

    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);
    let note = NOTE::unpack(packed_note);

    RetrievedNote {
        note,
        contract_address,
        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),
    }
}
`},141:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",source:`use crate::{
    context::PrivateContext,
    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},
};

use dep::protocol_types::hash::{
    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,
};

/// Returns the note hash that must be used to issue a private kernel read request for a note.
pub fn compute_note_hash_for_read_request<Note>(
    retrieved_note: RetrievedNote<Note>,
    storage_slot: Field,
) -> Field
where
    Note: NoteHash,
{
    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);

    if retrieved_note.metadata.is_settled() {
        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,
        // which is already in the note hash tree).
        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);
        compute_unique_note_hash(
            retrieved_note.metadata.to_settled().nonce(),
            siloed_note_hash,
        )
    } else {
        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by
        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash
        // counter).
        note_hash
    }
}

/// Returns the note hash that must be used to compute a note's nullifier when calling \`NoteHash::compute_nullifier\` or
/// \`NoteHash::compute_nullifier_unconstrained\`.
pub fn compute_note_hash_for_nullify<Note>(
    retrieved_note: RetrievedNote<Note>,
    storage_slot: Field,
) -> Field
where
    Note: NoteHash,
{
    compute_note_hash_for_nullify_from_read_request(
        retrieved_note,
        compute_note_hash_for_read_request(retrieved_note, storage_slot),
    )
}

/// Same as \`compute_note_hash_for_nullify\`, except it takes the note hash used in a read request (i.e. what
/// \`compute_note_hash_for_read_request\` would return). This is useful in scenarios where that hash has already been
/// computed to reduce constraints by reusing this value.
pub fn compute_note_hash_for_nullify_from_read_request<Note>(
    retrieved_note: RetrievedNote<Note>,
    note_hash_for_read_request: Field,
) -> Field {
    // There is just one instance in which the note hash for nullification does not match the note hash used for a read
    // request, which is when dealing with pending previous phase notes. These had their existence proven using their
    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be
    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the
    // *unique* note hash.
    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,
    // once the note is settled, resulting in a double spend.

    if retrieved_note.metadata.is_pending_previous_phase() {
        let siloed_note_hash =
            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);
        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();

        compute_unique_note_hash(nonce, siloed_note_hash)
    } else {
        note_hash_for_read_request
    }
}

/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.
pub fn compute_siloed_note_nullifier<Note>(
    retrieved_note: RetrievedNote<Note>,
    storage_slot: Field,
    context: &mut PrivateContext,
) -> Field
where
    Note: NoteHash,
{
    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);
    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);

    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)
}
`},144:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",source:`use dep::protocol_types::{
    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,
};

#[oracle(callPrivateFunction)]
unconstrained fn call_private_function_oracle(
    _contract_address: AztecAddress,
    _function_selector: FunctionSelector,
    _args_hash: Field,
    _start_side_effect_counter: u32,
    _is_static_call: bool,
) -> [Field; 2] {}

pub unconstrained fn call_private_function_internal(
    contract_address: AztecAddress,
    function_selector: FunctionSelector,
    args_hash: Field,
    start_side_effect_counter: u32,
    is_static_call: bool,
) -> (u32, Field) {
    let fields = call_private_function_oracle(
        contract_address,
        function_selector,
        args_hash,
        start_side_effect_counter,
        is_static_call,
    );

    let mut reader = Reader::new(fields);
    let end_side_effect_counter = reader.read_u32();
    let returns_hash = reader.read();

    (end_side_effect_counter, returns_hash)
}
`},145:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",source:`use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};

/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with \`load\`. If
/// data was already stored at this slot, it is overwritten.
pub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)
where
    T: Serialize<N>,
{
    let serialized = value.serialize();
    store_oracle(contract_address, slot, serialized);
}

/// Returns data previously stored via \`storeCapsule\` in the per-contract non-volatile database. Returns Option::none() if
/// nothing was stored at the given slot.
pub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>
where
    T: Deserialize<N>,
{
    let serialized_option = load_oracle::<N>(contract_address, slot, N);
    serialized_option.map(|arr| Deserialize::deserialize(arr))
}

/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.
pub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {
    delete_oracle(contract_address, slot);
}

/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data
/// structures by avoiding repeated calls to \`loadCapsule\` and \`storeCapsule\`.
/// Supports overlapping source and destination regions (which will result in the overlapped source values being
/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)
pub unconstrained fn copy(
    contract_address: AztecAddress,
    src_slot: Field,
    dst_slot: Field,
    num_entries: u32,
) {
    copy_oracle(contract_address, src_slot, dst_slot, num_entries);
}

#[oracle(storeCapsule)]
unconstrained fn store_oracle<let N: u32>(
    contract_address: AztecAddress,
    slot: Field,
    values: [Field; N],
) {}

/// We need to pass in \`array_len\` (the value of N) as a parameter to tell the oracle how many fields the response must
/// have.
///
/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would
/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected
/// response shape would be 3 single items, whereas it were a struct containing \`u32, [Field;10], u32\` then the expected
/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.
#[oracle(loadCapsule)]
unconstrained fn load_oracle<let N: u32>(
    contract_address: AztecAddress,
    slot: Field,
    array_len: u32,
) -> Option<[Field; N]> {}

#[oracle(deleteCapsule)]
unconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}

#[oracle(copyCapsule)]
unconstrained fn copy_oracle(
    contract_address: AztecAddress,
    src_slot: Field,
    dst_slot: Field,
    num_entries: u32,
) {}

mod test {
    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but
    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir
    // oracles are hooked up correctly.

    use crate::{
        oracle::capsules::{copy, delete, load, store},
        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},
    };
    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};

    unconstrained fn setup() -> AztecAddress {
        let env = TestEnvironment::new();
        env.contract_address()
    }

    global SLOT: Field = 1;

    #[test]
    unconstrained fn stores_and_loads() {
        let contract_address = setup();

        let value = MockStruct::new(5, 6);
        store(contract_address, SLOT, value);

        assert_eq(load(contract_address, SLOT).unwrap(), value);
    }

    #[test]
    unconstrained fn store_overwrites() {
        let contract_address = setup();

        let value = MockStruct::new(5, 6);
        store(contract_address, SLOT, value);

        let new_value = MockStruct::new(7, 8);
        store(contract_address, SLOT, new_value);

        assert_eq(load(contract_address, SLOT).unwrap(), new_value);
    }

    #[test]
    unconstrained fn loads_empty_slot() {
        let contract_address = setup();

        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);
        assert_eq(loaded_value, Option::none());
    }

    #[test]
    unconstrained fn deletes_stored_value() {
        let contract_address = setup();

        let value = MockStruct::new(5, 6);
        store(contract_address, SLOT, value);
        delete(contract_address, SLOT);

        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);
        assert_eq(loaded_value, Option::none());
    }

    #[test]
    unconstrained fn deletes_empty_slot() {
        let contract_address = setup();

        delete(contract_address, SLOT);
        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);
        assert_eq(loaded_value, Option::none());
    }

    #[test]
    unconstrained fn copies_non_overlapping_values() {
        let contract_address = setup();

        let src = 5;

        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];
        store(contract_address, src, values[0]);
        store(contract_address, src + 1, values[1]);
        store(contract_address, src + 2, values[2]);

        let dst = 10;
        copy(contract_address, src, dst, 3);

        assert_eq(load(contract_address, dst).unwrap(), values[0]);
        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);
        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);
    }

    #[test]
    unconstrained fn copies_overlapping_values_with_src_ahead() {
        let contract_address = setup();

        let src = 1;

        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];
        store(contract_address, src, values[0]);
        store(contract_address, src + 1, values[1]);
        store(contract_address, src + 2, values[2]);

        let dst = 2;
        copy(contract_address, src, dst, 3);

        assert_eq(load(contract_address, dst).unwrap(), values[0]);
        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);
        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);

        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]
        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)
        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]
        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]
    }

    #[test]
    unconstrained fn copies_overlapping_values_with_dst_ahead() {
        let contract_address = setup();

        let src = 2;

        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];
        store(contract_address, src, values[0]);
        store(contract_address, src + 1, values[1]);
        store(contract_address, src + 2, values[2]);

        let dst = 1;
        copy(contract_address, src, dst, 3);

        assert_eq(load(contract_address, dst).unwrap(), values[0]);
        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);
        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);

        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]
        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]
        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]
        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)
    }

    #[test(should_fail_with = "copy empty slot")]
    unconstrained fn cannot_copy_empty_values() {
        let contract_address = setup();

        copy(contract_address, SLOT, SLOT, 1);
    }

    #[test(should_fail_with = "not allowed to access")]
    unconstrained fn cannot_store_other_contract() {
        let contract_address = setup();
        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);

        let value = MockStruct::new(5, 6);
        store(other_contract_address, SLOT, value);
    }

    #[test(should_fail_with = "not allowed to access")]
    unconstrained fn cannot_load_other_contract() {
        let contract_address = setup();
        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);

        let _: Option<MockStruct> = load(other_contract_address, SLOT);
    }

    #[test(should_fail_with = "not allowed to access")]
    unconstrained fn cannot_delete_other_contract() {
        let contract_address = setup();
        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);

        delete(other_contract_address, SLOT);
    }

    #[test(should_fail_with = "not allowed to access")]
    unconstrained fn cannot_copy_other_contract() {
        let contract_address = setup();
        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);

        copy(other_contract_address, SLOT, SLOT, 0);
    }
}
`},146:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",source:`use dep::protocol_types::address::AztecAddress;

#[oracle(notifyEnqueuedPublicFunctionCall)]
unconstrained fn notify_enqueued_public_function_call_oracle(
    _contract_address: AztecAddress,
    _calldata_hash: Field,
    _side_effect_counter: u32,
    _is_static_call: bool,
) {}

unconstrained fn notify_enqueued_public_function_call_wrapper(
    contract_address: AztecAddress,
    calldata_hash: Field,
    side_effect_counter: u32,
    is_static_call: bool,
) {
    notify_enqueued_public_function_call_oracle(
        contract_address,
        calldata_hash,
        side_effect_counter,
        is_static_call,
    )
}

pub fn notify_enqueued_public_function_call(
    contract_address: AztecAddress,
    calldata_hash: Field,
    side_effect_counter: u32,
    is_static_call: bool,
) {
    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.
    unsafe {
        notify_enqueued_public_function_call_wrapper(
            contract_address,
            calldata_hash,
            side_effect_counter,
            is_static_call,
        )
    }
}

#[oracle(notifySetPublicTeardownFunctionCall)]
unconstrained fn notify_set_public_teardown_function_call_oracle(
    _contract_address: AztecAddress,
    _calldata_hash: Field,
    _side_effect_counter: u32,
    _is_static_call: bool,
) {}

unconstrained fn notify_set_public_teardown_function_call_wrapper(
    contract_address: AztecAddress,
    calldata_hash: Field,
    side_effect_counter: u32,
    is_static_call: bool,
) {
    notify_set_public_teardown_function_call_oracle(
        contract_address,
        calldata_hash,
        side_effect_counter,
        is_static_call,
    )
}

pub fn notify_set_public_teardown_function_call(
    contract_address: AztecAddress,
    calldata_hash: Field,
    side_effect_counter: u32,
    is_static_call: bool,
) {
    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.
    unsafe {
        notify_set_public_teardown_function_call_wrapper(
            contract_address,
            calldata_hash,
            side_effect_counter,
            is_static_call,
        )
    }
}

pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call.
    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };
}

pub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {
    notify_set_min_revertible_side_effect_counter_oracle(counter);
}

#[oracle(notifySetMinRevertibleSideEffectCounter)]
unconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}
`},147:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",source:`use dep::protocol_types::address::AztecAddress;

#[oracle(getContractAddress)]
unconstrained fn get_contract_address_oracle() -> AztecAddress {}

#[oracle(getBlockNumber)]
unconstrained fn get_block_number_oracle() -> u32 {}

#[oracle(getChainId)]
unconstrained fn get_chain_id_oracle() -> Field {}

#[oracle(getVersion)]
unconstrained fn get_version_oracle() -> Field {}

pub unconstrained fn get_contract_address() -> AztecAddress {
    get_contract_address_oracle()
}

pub unconstrained fn get_block_number() -> u32 {
    get_block_number_oracle()
}

pub unconstrained fn get_chain_id() -> Field {
    get_chain_id_oracle()
}

pub unconstrained fn get_version() -> Field {
    get_version_oracle()
}
`},148:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",source:`/// Stores values represented as slice in execution cache to be later obtained by its hash.
pub fn store(values: [Field], hash: Field) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.
    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };
}

unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {
    store_in_execution_cache_oracle(values, hash);
}

pub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {
    load_from_execution_cache_oracle(hash)
}

#[oracle(storeInExecutionCache)]
unconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}

#[oracle(loadFromExecutionCache)]
unconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}
`},149:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",source:`use protocol_types::{
    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,
    traits::FromField,
};

// NOTE: this is for use in private only
#[oracle(getContractInstance)]
unconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}

// NOTE: this is for use in private only
unconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {
    get_contract_instance_oracle(address)
}

// NOTE: this is for use in private only
pub fn get_contract_instance(address: AztecAddress) -> ContractInstance {
    // Safety: The to_address function combines all values in the instance object to produce an address,
    // so by checking that we get the expected address we validate the entire struct.
    let instance = unsafe { get_contract_instance_internal(address) };
    assert_eq(instance.to_address(), address);

    instance
}

struct GetContractInstanceResult {
    exists: bool,
    member: Field,
}

// These oracles each return a ContractInstance member
// plus a boolean indicating whether the instance was found.
#[oracle(avmOpcodeGetContractInstanceDeployer)]
unconstrained fn get_contract_instance_deployer_oracle_avm(
    _address: AztecAddress,
) -> [GetContractInstanceResult; 1] {}
#[oracle(avmOpcodeGetContractInstanceClassId)]
unconstrained fn get_contract_instance_class_id_oracle_avm(
    _address: AztecAddress,
) -> [GetContractInstanceResult; 1] {}
#[oracle(avmOpcodeGetContractInstanceInitializationHash)]
unconstrained fn get_contract_instance_initialization_hash_oracle_avm(
    _address: AztecAddress,
) -> [GetContractInstanceResult; 1] {}

unconstrained fn get_contract_instance_deployer_internal_avm(
    address: AztecAddress,
) -> [GetContractInstanceResult; 1] {
    get_contract_instance_deployer_oracle_avm(address)
}
unconstrained fn get_contract_instance_class_id_internal_avm(
    address: AztecAddress,
) -> [GetContractInstanceResult; 1] {
    get_contract_instance_class_id_oracle_avm(address)
}
unconstrained fn get_contract_instance_initialization_hash_internal_avm(
    address: AztecAddress,
) -> [GetContractInstanceResult; 1] {
    get_contract_instance_initialization_hash_oracle_avm(address)
}

pub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {
    // Safety: AVM opcodes are constrained by the AVM itself
    let GetContractInstanceResult { exists, member } =
        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };
    if exists {
        Option::some(AztecAddress::from_field(member))
    } else {
        Option::none()
    }
}
pub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {
    // Safety: AVM opcodes are constrained by the AVM itself
    let GetContractInstanceResult { exists, member } =
        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };
    if exists {
        Option::some(ContractClassId::from_field(member))
    } else {
        Option::none()
    }
}
pub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {
    // Safety: AVM opcodes are constrained by the AVM itself
    let GetContractInstanceResult { exists, member } =
        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };
    if exists {
        Option::some(member)
    } else {
        Option::none()
    }
}
`},152:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr",source:`use crate::utils::array;
use dep::protocol_types::{
    abis::nullifier_leaf_preimage::NullifierLeafPreimage, constants::NULLIFIER_TREE_HEIGHT,
};

// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT
global NULLIFIER_MEMBERSHIP_WITNESS: u32 = 44;

pub struct NullifierMembershipWitness {
    pub index: Field,
    pub leaf_preimage: NullifierLeafPreimage,
    pub path: [Field; NULLIFIER_TREE_HEIGHT],
}

impl NullifierMembershipWitness {
    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {
        let serialized_leaf_preimage = array::subarray(fields, 1);

        Self {
            index: fields[0],
            leaf_preimage: NullifierLeafPreimage::deserialize(serialized_leaf_preimage),
            path: array::subarray(fields, 1 + serialized_leaf_preimage.len()),
        }
    }
}

#[oracle(getLowNullifierMembershipWitness)]
unconstrained fn get_low_nullifier_membership_witness_oracle(
    _block_number: u32,
    _nullifier: Field,
) -> NullifierMembershipWitness {}

// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower
// nullifier's next_value is bigger than the nullifier)
pub unconstrained fn get_low_nullifier_membership_witness(
    block_number: u32,
    nullifier: Field,
) -> NullifierMembershipWitness {
    get_low_nullifier_membership_witness_oracle(block_number, nullifier)
}

#[oracle(getNullifierMembershipWitness)]
unconstrained fn get_nullifier_membership_witness_oracle(
    _block_number: u32,
    _nullifier: Field,
) -> NullifierMembershipWitness {}

// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower
// nullifier's next_value is bigger than the nullifier)
pub unconstrained fn get_nullifier_membership_witness(
    block_number: u32,
    nullifier: Field,
) -> NullifierMembershipWitness {
    get_nullifier_membership_witness_oracle(block_number, nullifier)
}
`},154:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",source:`use protocol_types::abis::validation_requests::KeyValidationRequest;

#[oracle(getKeyValidationRequest)]
unconstrained fn get_key_validation_request_oracle(
    _pk_m_hash: Field,
    _key_index: Field,
) -> KeyValidationRequest {}

pub unconstrained fn get_key_validation_request(
    pk_m_hash: Field,
    key_index: Field,
) -> KeyValidationRequest {
    get_key_validation_request_oracle(pk_m_hash, key_index)
}
`},155:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",source:`use dep::protocol_types::{
    address::{AztecAddress, PartialAddress},
    point::Point,
    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},
};

#[oracle(getPublicKeysAndPartialAddress)]
unconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}

pub unconstrained fn get_public_keys_and_partial_address(
    address: AztecAddress,
) -> (PublicKeys, PartialAddress) {
    let result = get_public_keys_and_partial_address_oracle(address);

    let keys = PublicKeys {
        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },
        ivpk_m: IvpkM {
            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },
        },
        ovpk_m: OvpkM {
            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },
        },
        tpk_m: TpkM {
            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },
        },
    };

    let partial_address = PartialAddress::from_field(result[12]);

    (keys, partial_address)
}
`},156:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",source:`use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;
use protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};

/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.
pub unconstrained fn notify_created_contract_class_log<let N: u32>(
    contract_address: AztecAddress,
    message: [Field; N],
    length: u32,
    counter: u32,
) {
    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)
}

#[oracle(notifyCreatedContractClassLog)]
unconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(
    contract_address: AztecAddress,
    message: [Field; N],
    length: u32,
    counter: u32,
) {}

pub unconstrained fn store_private_event_log(
    contract_address: AztecAddress,
    recipient: AztecAddress,
    event_selector: EventSelector,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
    tx_hash: Field,
    log_index_in_tx: Field,
    tx_index_in_block: Field,
) {
    store_private_event_log_oracle(
        contract_address,
        recipient,
        event_selector,
        msg_content,
        tx_hash,
        log_index_in_tx,
        tx_index_in_block,
    )
}

#[oracle(storePrivateEventLog)]
unconstrained fn store_private_event_log_oracle(
    contract_address: AztecAddress,
    recipient: AztecAddress,
    event_selector: EventSelector,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
    tx_hash: Field,
    log_index_in_tx: Field,
    tx_index_in_block: Field,
) {}
`},157:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",source:`use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;
use dep::protocol_types::{
    address::AztecAddress,
    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},
};

/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes
/// them available for later processing in Noir by storing them in a capsule array.
pub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {
    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);
}

#[oracle(fetchTaggedLogs)]
unconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}

/// Informs PXE of a note's existence so that it can later be retrieved by the \`getNotes\` oracle. The note will be
/// scoped to \`contract_address\`, meaning other contracts will not be able to access it unless authorized.
///
/// The packed note is what \`getNotes\` will later return. PXE indexes notes by \`storage_slot\`, so this value
/// is typically used to filter notes that correspond to different state variables. \`note_hash\` and \`nullifier\` are
/// the inner hashes, i.e. the raw hashes returned by \`NoteHash::compute_note_hash\` and
/// \`NoteHash::compute_nullifier\`. PXE will verify that the siloed unique note hash was inserted into the tree
/// at \`tx_hash\`, and will store the nullifier to later check for nullification.
///
/// \`recipient\` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.
/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.
///
/// Returns true if the note was successfully delivered and added to PXE's database.
pub unconstrained fn deliver_note(
    contract_address: AztecAddress,
    storage_slot: Field,
    nonce: Field,
    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,
    note_hash: Field,
    nullifier: Field,
    tx_hash: Field,
    recipient: AztecAddress,
) -> bool {
    deliver_note_oracle(
        contract_address,
        storage_slot,
        nonce,
        packed_note,
        note_hash,
        nullifier,
        tx_hash,
        recipient,
    )
}

/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This
/// is the data required in order to discover notes that are being delivered in a log.
// TODO(#11639): this could also be used to fetch private logs, but the \`BoundedVec\` maximum length is that of a public
// log.
pub struct LogWithTxData {
    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.
    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,
    pub tx_hash: Field,
    /// The array of new note hashes created by \`tx_hash\`
    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,
    /// The first nullifier created by \`tx_hash\`
    pub first_nullifier_in_tx: Field,
}

/// Fetches a log from the node that has the corresponding \`tag\`. The log can be either a public or a private log, and
/// the tag is the first field in the log's content. Returns \`Option::none\` if no such log exists. Throws if more than
/// one log with that tag exists.
/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.
// TODO(#11627): handle multiple logs with the same tag.
// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.
pub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {
    get_log_by_tag_oracle(tag)
}

#[oracle(deliverNote)]
unconstrained fn deliver_note_oracle(
    contract_address: AztecAddress,
    storage_slot: Field,
    nonce: Field,
    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,
    note_hash: Field,
    nullifier: Field,
    tx_hash: Field,
    recipient: AztecAddress,
) -> bool {}

#[oracle(getLogByTag)]
unconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}
`},159:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",source:`use crate::note::{
    note_interface::NoteType,
    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},
};

use dep::protocol_types::{
    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,
};

/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same
/// transaction. This note should only be added to the non-volatile database if found in an actual block.
pub fn notify_created_note<let N: u32>(
    storage_slot: Field,
    note_type_id: Field,
    packed_note: [Field; N],
    note_hash: Field,
    counter: u32,
) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call.
    unsafe {
        notify_created_note_oracle_wrapper(
            storage_slot,
            note_type_id,
            packed_note,
            note_hash,
            counter,
        )
    };
}

/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in
/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an
/// actual block.
pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to
    // call.
    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };
}

/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.
pub fn notify_created_nullifier(nullifier: Field) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to
    // call.
    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };
}

unconstrained fn notify_created_note_oracle_wrapper<let N: u32>(
    storage_slot: Field,
    note_type_id: Field,
    packed_note: [Field; N],
    note_hash: Field,
    counter: u32,
) {
    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);
}

#[oracle(notifyCreatedNote)]
unconstrained fn notify_created_note_oracle<let N: u32>(
    _storage_slot: Field,
    _note_type_id: Field,
    _packed_note: [Field; N],
    _note_hash: Field,
    _counter: u32,
) {}

unconstrained fn notify_nullified_note_oracle_wrapper(
    nullifier: Field,
    note_hash: Field,
    counter: u32,
) {
    notify_nullified_note_oracle(nullifier, note_hash, counter);
}

#[oracle(notifyNullifiedNote)]
unconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}

unconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {
    notify_created_nullifier_oracle(nullifier);
}

#[oracle(notifyCreatedNullifier)]
unconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}

#[oracle(getNotes)]
unconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(
    _storage_slot: Field,
    _num_selects: u8,
    _select_by_indexes: [u8; M],
    _select_by_offsets: [u8; M],
    _select_by_lengths: [u8; M],
    _select_values: [Field; M],
    _select_comparators: [u8; M],
    _sort_by_indexes: [u8; M],
    _sort_by_offsets: [u8; M],
    _sort_by_lengths: [u8; M],
    _sort_order: [u8; M],
    _limit: u32,
    _offset: u32,
    _status: u8,
    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec
    _max_notes: u32,
    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to
    // correctly construct the BoundedVec there.
    _packed_retrieved_note_length: u32,
) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}

pub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(
    storage_slot: Field,
    num_selects: u8,
    select_by_indexes: [u8; M],
    select_by_offsets: [u8; M],
    select_by_lengths: [u8; M],
    select_values: [Field; M],
    select_comparators: [u8; M],
    sort_by_indexes: [u8; M],
    sort_by_offsets: [u8; M],
    sort_by_lengths: [u8; M],
    sort_order: [u8; M],
    limit: u32,
    offset: u32,
    status: u8,
) -> [Option<RetrievedNote<Note>>; MAX_NOTES]
where
    Note: NoteType + Packable<NOTE_PCKD_LEN>,
{
    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.
    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(
        storage_slot,
        num_selects,
        select_by_indexes,
        select_by_offsets,
        select_by_lengths,
        select_values,
        select_comparators,
        sort_by_indexes,
        sort_by_offsets,
        sort_by_lengths,
        sort_order,
        limit,
        offset,
        status,
        MAX_NOTES,
        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,
    );

    let mut notes = BoundedVec::<_, MAX_NOTES>::new();
    for i in 0..packed_retrieved_notes.len() {
        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));
        notes.push(retrieved_note);
    }

    // At last we convert the bounded vector to an array of options. We do this because that is what the filter
    // function needs to have on the output and we've decided to have the same type on the input and output of
    // the filter and preprocessor functions.
    //
    // We have decided to have the same type on the input and output of the filter and preprocessor functions because
    // it allows us to chain multiple filters and preprocessors together.
    //
    // So why do we want the array of options on the output of the filter function?
    //
    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options
    // allows setting values at known indices in the output array which is much more efficient than pushing to a
    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted
    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic
    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor
    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in
    // an unconstrained context. We, however, use the same return value type to be able to use the same function as
    // both a preprocessor and a filter.
    let mut notes_array = [Option::none(); MAX_NOTES];
    for i in 0..notes.len() {
        if i < notes.len() {
            notes_array[i] = Option::some(notes.get_unchecked(i));
        }
    }

    notes_array
}

/// Returns true if the nullifier exists. Note that a \`true\` value can be constrained by proving existence of the
/// nullifier, but a \`false\` value should not be relied upon since other transactions may emit this nullifier before the
/// current transaction is included in a block. While this might seem of little use at first, certain design patterns
/// benefit from this abstraction (see e.g. \`PrivateMutable\`).
pub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {
    check_nullifier_exists_oracle(inner_nullifier)
}

#[oracle(checkNullifierExists)]
unconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}

/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,
/// siloed for the current contract address.
pub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {
    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)
}

#[oracle(getIndexedTaggingSecretAsSender)]
unconstrained fn get_indexed_tagging_secret_as_sender_oracle(
    _sender: AztecAddress,
    _recipient: AztecAddress,
) -> IndexedTaggingSecret {}

/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that
/// future notes get a different tag and can be discovered by the recipient.
/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -
/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes
/// that are not found by the recipient.
pub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call.
    unsafe {
        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);
    }
}

unconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(
    sender: AztecAddress,
    recipient: AztecAddress,
) {
    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);
}

#[oracle(incrementAppTaggingSecretIndexAsSender)]
unconstrained fn increment_app_tagging_secret_index_as_sender_oracle(
    _sender: AztecAddress,
    _recipient: AztecAddress,
) {}
`},160:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/random.nr",source:`/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is
/// truly random: we assume that the oracle is cooperating and returning random values.
/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as
/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.
pub unconstrained fn random() -> Field {
    rand_oracle()
}

#[oracle(getRandomField)]
unconstrained fn rand_oracle() -> Field {}
`},161:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",source:`use protocol_types::{address::aztec_address::AztecAddress, point::Point};

// TODO(#12656): return an app-siloed secret + document this
#[oracle(getSharedSecret)]
unconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}

/// Returns an app-siloed shared secret between \`address\` and someone who knows the secret key behind an
/// ephemeral public key \`ephPk\`. The app-siloing means that contracts cannot retrieve secrets that belong to
/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration
/// given that both the \`address\` and \`ephPk\` are public information.
///
/// The shared secret \`S\` is computed as:
/// \`let S =  (ivsk + h) * ephPk\`
/// where \`ivsk + h\` is the 'preaddress' i.e. the preimage of the address, also called the address secret.
/// TODO(#12656): app-silo this secret
pub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {
    get_shared_secret_oracle(address, ephPk)
}
`},167:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",source:`use dep::protocol_types::{
    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,
    traits::Packable,
};

use crate::context::{PrivateContext, UtilityContext};
use crate::note::{
    lifecycle::create_note,
    note_emission::NoteEmission,
    note_getter::{get_note, view_notes},
    note_interface::{NoteHash, NoteType},
    note_viewer_options::NoteViewerOptions,
};
use crate::oracle::notes::check_nullifier_exists;
use crate::state_vars::storage::Storage;

// docs:start:struct
pub struct PrivateImmutable<Note, Context> {
    context: Context,
    storage_slot: Field,
}
// docs:end:struct

// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a
// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs
// just one slot to be reserved, regardless of what it stores.
impl<T, Context> Storage<1> for PrivateImmutable<T, Context> {
    fn get_storage_slot(self) -> Field {
        self.storage_slot
    }
}

impl<Note, Context> PrivateImmutable<Note, Context> {
    // docs:start:new
    pub fn new(context: Context, storage_slot: Field) -> Self {
        assert(storage_slot != 0, "Storage slot 0 not allowed. Storage slots must start from 1.");
        Self { context, storage_slot }
    }
    // docs:end:new

    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.
    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.
    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.
    // Under such circumstances, such application developers might wish to _not_ use this state variable type.
    // This is especially dangerous for initial assignment to elements of a \`Map<AztecAddress, PrivateImmutable>\` type (for example), because the storage slot often also identifies an actor.
    // e.g. the initial assignment to \`my_map.at(msg.sender)\` will leak: \`msg.sender\`, the fact that an element of \`my_map\` was assigned-to for the first time, and the contract_address.
    pub fn compute_initialization_nullifier(self) -> Field {
        poseidon2_hash_with_separator(
            [self.storage_slot],
            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,
        )
    }
}

impl<Note> PrivateImmutable<Note, &mut PrivateContext> {
    // docs:start:initialize
    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>
    where
        Note: NoteType + NoteHash + Packable<N>,
    {
        // Nullify the storage slot.
        let nullifier = self.compute_initialization_nullifier();
        self.context.push_nullifier(nullifier);

        create_note(self.context, self.storage_slot, note)
    }
    // docs:end:initialize

    // docs:start:get_note
    pub fn get_note<let N: u32>(self) -> Note
    where
        Note: NoteType + NoteHash + Packable<N>,
    {
        let storage_slot = self.storage_slot;
        let retrieved_note = get_note(self.context, storage_slot).0;

        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function
        // has already constrained the note (by pushing a read request to the context), we can return just the note
        // and skip the additional data in RetrievedNote.
        retrieved_note.note
    }
    // docs:end:get_note
}

impl<Note> PrivateImmutable<Note, UtilityContext>
where
    Note: NoteType + NoteHash + Eq,
{
    // docs:start:is_initialized
    pub unconstrained fn is_initialized(self) -> bool {
        let nullifier = self.compute_initialization_nullifier();
        check_nullifier_exists(nullifier)
    }
    // docs:end:is_initialized

    // view_note does not actually use the context, but it calls oracles that are only available in private
    // docs:start:view_note
    pub unconstrained fn view_note<let N: u32>(self) -> Note
    where
        Note: Packable<N>,
    {
        let mut options = NoteViewerOptions::new();
        view_notes(self.storage_slot, options.set_limit(1)).get(0)
    }
    // docs:end:view_note
}
`},188:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",source:`/// Appends two \`BoundedVec\`s together, returning one that contains all of the elements of the first one followed by all
/// of the elements of the second one. The resulting \`BoundedVec\` can have any arbitrary maximum length, but it must be
/// large enough to fit all of the elements of both the first and second vectors.
pub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(
    a: BoundedVec<T, A_LEN>,
    b: BoundedVec<T, B_LEN>,
) -> BoundedVec<T, DST_LEN> {
    let mut dst = BoundedVec::new();

    dst.extend_from_bounded_vec(a);
    dst.extend_from_bounded_vec(b);

    dst
}

mod test {
    use super::append;

    #[test]
    unconstrained fn append_empty_vecs() {
        let a: BoundedVec<_, 3> = BoundedVec::new();
        let b: BoundedVec<_, 14> = BoundedVec::new();

        let result: BoundedVec<Field, 5> = append(a, b);

        assert_eq(result.len(), 0);
        assert_eq(result.storage(), std::mem::zeroed());
    }

    #[test]
    unconstrained fn append_non_empty_vecs() {
        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);
        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);

        let result: BoundedVec<Field, 8> = append(a, b);

        assert_eq(result.len(), 6);
        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);
    }

    #[test(should_fail_with = "out of bounds")]
    unconstrained fn append_non_empty_vecs_insufficient_max_len() {
        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);
        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);

        let _: BoundedVec<Field, 5> = append(a, b);
    }
}
`},189:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",source:`/// Collapses an array of \`Option\`s with sparse \`Some\` values into a \`BoundedVec\`, essentially unwrapping the \`Option\`s
/// and removing the \`None\` values.
///
/// For example, given:
///   \`input: [some(3), none(), some(1)]\`
/// this returns
///   \`collapsed: [3, 1]\`
pub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>
where
    T: Eq,
{
    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop
    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the
    // proving backend.
    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then
    // verify that the input and collapsed arrays are equivalent.

    // Safety: The hints are verified by the \`verify_collapse_hints\` function.
    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };
    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);
    collapsed
}

fn verify_collapse_hints<T, let N: u32>(
    input: [Option<T>; N],
    collapsed: BoundedVec<T, N>,
    collapsed_to_input_index_mapping: BoundedVec<u32, N>,
)
where
    T: Eq,
{
    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down
    // multiple constraints to guarantee this.
    // First we check that the number of elements is correct
    let mut count = 0;
    for i in 0..N {
        if input[i].is_some() {
            count += 1;
        }
    }
    assert_eq(count, collapsed.len(), "Wrong collapsed vec length");

    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the
    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that
    // corresponds to the collapsed entry at index n.
    // Example:
    //  - input: [some(3), none(), some(1)]
    //  - collapsed: [3, 1]
    //  - collapsed_to_input_index_mapping: [0, 2]
    // These two arrays should therefore have the same length.
    assert_eq(
        collapsed.len(),
        collapsed_to_input_index_mapping.len(),
        "Collapse hint vec length mismatch",
    );

    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.
    let mut last_index = Option::none();
    for i in 0..N {
        if i < collapsed.len() {
            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);
            assert(input_index < N, "Out of bounds index hint");

            assert_eq(
                collapsed.get_unchecked(i),
                input[input_index].unwrap(),
                "Wrong collapsed vec content",
            );

            // By requiring increasing input indices, we both guarantee that we're not looking at the same input
            // element more than once, and that we're going over them in the original order.
            if last_index.is_some() {
                assert(input_index > last_index.unwrap_unchecked(), "Wrong collapsed vec order");
            }
            last_index = Option::some(input_index);
        } else {
            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make
            // sure that this property holds.
            assert_eq(
                collapsed.get_unchecked(i),
                std::mem::zeroed(),
                "Dirty collapsed vec storage",
            );
        }
    }
    // We now know that:
    //  - all values in the collapsed array exist in the input array
    //  - the order of the collapsed values is the same as in the input array
    //  - no input value is present more than once in the collapsed array
    //  - the number of elements in the collapsed array is the same as in the input array.
    // Therefore, the collapsed array is correct.
}

unconstrained fn get_collapse_hints<T, let N: u32>(
    input: [Option<T>; N],
) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {
    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();
    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();

    for i in 0..N {
        if input[i].is_some() {
            collapsed.push(input[i].unwrap_unchecked());
            collapsed_to_input_index_mapping.push(i);
        }
    }

    (collapsed, collapsed_to_input_index_mapping)
}

mod test {
    use super::{collapse, verify_collapse_hints};

    #[test]
    unconstrained fn collapse_empty_array() {
        let original: [Option<Field>; 2] = [Option::none(), Option::none()];
        let collapsed = collapse(original);

        assert_eq(collapsed.len(), 0);
    }

    #[test]
    unconstrained fn collapse_non_sparse_array() {
        let original = [Option::some(7), Option::some(3), Option::none()];
        let collapsed = collapse(original);

        assert_eq(collapsed.len(), 2);
        assert_eq(collapsed.get(0), 7);
        assert_eq(collapsed.get(1), 3);
    }

    #[test]
    unconstrained fn collapse_sparse_array() {
        let original = [Option::some(7), Option::none(), Option::some(3)];
        let collapsed = collapse(original);

        assert_eq(collapsed.len(), 2);
        assert_eq(collapsed.get(0), 7);
        assert_eq(collapsed.get(1), 3);
    }

    #[test]
    unconstrained fn collapse_front_padding() {
        let original =
            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];
        let collapsed = collapse(original);

        assert_eq(collapsed.len(), 2);
        assert_eq(collapsed.get(0), 7);
        assert_eq(collapsed.get(1), 3);
    }

    #[test]
    unconstrained fn collapse_back_padding() {
        let original =
            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];
        let collapsed = collapse(original);

        assert_eq(collapsed.len(), 2);
        assert_eq(collapsed.get(0), 7);
        assert_eq(collapsed.get(1), 3);
    }

    #[test]
    unconstrained fn verify_collapse_hints_good_hints() {
        let original = [Option::some(7), Option::none(), Option::some(3)];
        let collapsed = BoundedVec::from_array([7, 3]);
        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);

        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);
    }

    #[test(should_fail_with = "Wrong collapsed vec length")]
    unconstrained fn verify_collapse_hints_wrong_length() {
        let original = [Option::some(7), Option::none(), Option::some(3)];
        let collapsed = BoundedVec::from_array([7]);
        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);

        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);
    }

    #[test(should_fail_with = "Collapse hint vec length mismatch")]
    unconstrained fn verify_collapse_hints_hint_length_mismatch() {
        let original = [Option::some(7), Option::none(), Option::some(3)];
        let collapsed = BoundedVec::from_array([7, 3]);
        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);

        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);
    }

    #[test(should_fail_with = "Out of bounds index hint")]
    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {
        let original = [Option::some(7), Option::none(), Option::some(3)];
        let collapsed = BoundedVec::from_array([7, 3]);
        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);

        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);
    }

    #[test(should_fail)]
    unconstrained fn verify_collapse_hints_hint_to_none() {
        let original = [Option::some(7), Option::none(), Option::some(3)];
        let collapsed = BoundedVec::from_array([7, 0]);
        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);

        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);
    }

    #[test(should_fail_with = "Wrong collapsed vec content")]
    unconstrained fn verify_collapse_hints_wrong_vec_content() {
        let original = [Option::some(7), Option::none(), Option::some(3)];
        let collapsed = BoundedVec::from_array([7, 42]);
        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);

        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);
    }

    #[test(should_fail_with = "Wrong collapsed vec order")]
    unconstrained fn verify_collapse_hints_wrong_vec_order() {
        let original = [Option::some(7), Option::none(), Option::some(3)];
        let collapsed = BoundedVec::from_array([3, 7]);
        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);

        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);
    }

    #[test(should_fail_with = "Dirty collapsed vec storage")]
    unconstrained fn verify_collapse_hints_dirty_storage() {
        let original = [Option::some(7), Option::none(), Option::some(3)];

        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);
        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.
        collapsed.set_unchecked(2, 1);

        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);

        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);
    }

}
`},191:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",source:`/// Returns \`DST_LEN\` elements from a source array, starting at \`offset\`. \`DST_LEN\` must not be larger than the number
/// of elements past \`offset\`.
///
/// Examples:
/// \`\`\`
/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);
/// assert_eq(foo, [3, 4]);
///
/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain
/// \`\`\`
pub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(
    src: [T; SRC_LEN],
    offset: u32,
) -> [T; DST_LEN] {
    assert(offset + DST_LEN <= SRC_LEN, "DST_LEN too large for offset");

    let mut dst: [T; DST_LEN] = std::mem::zeroed();
    for i in 0..DST_LEN {
        dst[i] = src[i + offset];
    }

    dst
}

mod test {
    use super::subarray;

    #[test]
    unconstrained fn subarray_into_empty() {
        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.
        assert_eq(subarray::<Field, _, _>([], 0), []);
        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);
        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);
    }

    #[test]
    unconstrained fn subarray_complete() {
        assert_eq(subarray::<Field, _, _>([], 0), []);
        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);
    }

    #[test]
    unconstrained fn subarray_different_end_sizes() {
        // We implicitly select how many values to read in the size of the return array
        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);
        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);
        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);
        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);
    }

    #[test(should_fail_with = "DST_LEN too large for offset")]
    unconstrained fn subarray_offset_too_large() {
        // With an offset of 1 we can only request up to 4 elements
        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);
    }

    #[test(should_fail)]
    unconstrained fn subarray_bad_return_value() {
        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);
    }
}
`},192:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",source:`use crate::utils::array;

/// Returns \`DST_MAX_LEN\` elements from a source BoundedVec, starting at \`offset\`. \`offset\` must not be larger than the
/// original length, and \`DST_LEN\` must not be larger than the total number of elements past \`offset\` (including the
/// zeroed elements past \`len()\`).
///
/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end
/// of the vector by passing a value for \`DST_LEN\` that is smaller than \`len() - offset\`.
///
/// Examples:
/// \`\`\`
/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);
/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));
///
/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain
/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain
/// \`\`\`
pub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(
    bvec: BoundedVec<T, SRC_MAX_LEN>,
    offset: u32,
) -> BoundedVec<T, DST_MAX_LEN> {
    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case
    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed
    // storage past len), guaranteeing correctness. This is because \`subarray\` does not allow extending arrays past
    // their original length.
    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)
}

mod test {
    use super::subbvec;

    #[test]
    unconstrained fn subbvec_empty() {
        let bvec = BoundedVec::<Field, 0>::from_array([]);
        assert_eq(subbvec(bvec, 0), bvec);
    }

    #[test]
    unconstrained fn subbvec_complete() {
        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);
        assert_eq(subbvec(bvec, 0), bvec);

        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);
        assert_eq(subbvec(bvec, 0), smaller_capacity);
    }

    #[test]
    unconstrained fn subbvec_partial() {
        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);

        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));
        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));
    }

    #[test]
    unconstrained fn subbvec_into_empty() {
        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);
        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));
    }

    #[test(should_fail)]
    unconstrained fn subbvec_offset_past_len() {
        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);
        let _: BoundedVec<_, 1> = subbvec(bvec, 6);
    }

    #[test(should_fail)]
    unconstrained fn subbvec_insufficient_dst_len() {
        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);

        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause
        // for the capacity to reduce, but not the length (other than by len - offset).
        let _: BoundedVec<_, 1> = subbvec(bvec, 2);
    }

    #[test(should_fail_with = "DST_LEN too large for offset")]
    unconstrained fn subbvec_dst_len_causes_enlarge() {
        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);

        // subbvec does not supprt capacity increases
        let _: BoundedVec<_, 11> = subbvec(bvec, 0);
    }

    #[test(should_fail_with = "DST_LEN too large for offset")]
    unconstrained fn subbvec_dst_len_too_large_for_offset() {
        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);

        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,
        // which is less than 7.
        let _: BoundedVec<_, 7> = subbvec(bvec, 4);
    }
}
`},194:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",source:`use std::static_assert;

// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.
//
// \`bytes_to_fields\` uses fixed-size arrays since encryption contexts have compile-time size information.
// \`bytes_from_fields\` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.
//
// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.

/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole
/// bytes. Use \`bytes_from_fields\` to obtain the original bytes array.
///
/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted
/// into a Field.
/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]
/// Note: N must be a multiple of 31 bytes
pub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {
    // Assert that N is a multiple of 31
    static_assert(N % 31 == 0, "N must be a multiple of 31");

    let mut fields = [0; N / 31];

    // Since N is a multiple of 31, we can simply process all chunks fully
    for i in 0..N / 31 {
        let mut field = 0;
        for j in 0..31 {
            // Shift the existing value left by 8 bits and add the new byte
            field = field * 256 + bytes[i * 31 + j] as Field;
        }
        fields[i] = field;
    }

    fields
}

/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays
/// are not allowed: this is assumed to be an array obtained via \`bytes_to_fields\`, i.e. one that actually represents
/// bytes. To convert a Field array into bytes, use \`fields_to_bytes\`.
///
/// Each input field must contain at most 31 bytes (this is constrained to be so).
/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated
/// back together in the order of the original fields.
pub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {
    let mut bytes = BoundedVec::new();

    for i in 0..fields.len() {
        let field = fields.get(i);

        // We expect that the field contains at most 31 bytes of information.
        field.assert_max_bit_size::<248>();

        // Now we can safely convert the field to 31 bytes.
        let field_as_bytes: [u8; 31] = field.to_be_bytes();

        for j in 0..31 {
            bytes.push(field_as_bytes[j]);
        }
    }

    bytes
}

mod tests {
    use crate::utils::array::subarray;
    use super::{bytes_from_fields, bytes_to_fields};

    #[test]
    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {
        let fields = bytes_to_fields(input);

        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.
        // So we need to convert the field array to a BoundedVec to be able to feed it to the \`bytes_from_fields\`
        // function.
        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);

        let bytes_back = bytes_from_fields(fields_as_bounded_vec);

        // Compare the original input with the round-tripped result
        assert_eq(bytes_back.len(), input.len());
        assert_eq(subarray(bytes_back.storage(), 0), input);
    }

    #[test(should_fail_with = "N must be a multiple of 31")]
    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {
        // Try to convert 32 bytes (not a multiple of 31) to fields
        let _fields = bytes_to_fields([0; 32]);
    }

}
`},195:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",source:`// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.
//
// \`fields_to_bytes\` uses fixed-size arrays since encryption contexts have compile-time size information.
// \`fields_from_bytes\` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.
//
// Together they provide bidirectional conversion between fields and bytes.

/// Converts an input array of fields into a single array of bytes. Use \`fields_from_bytes\` to obtain the original
/// field array.
/// Each field is converted to a 32-byte big-endian array.
///
/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:
/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)
///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)
///
/// Since a field is ~254 bits, you'll end up with a subtle 2-bit "gap" at the big end, every 32 bytes. Be careful
/// that such a gap doesn't leak information! This could happen if you for example expected the output to be
/// indistinguishable from random bytes.
pub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {
    let mut bytes = [0; 32 * N];

    for i in 0..N {
        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();

        for j in 0..32 {
            bytes[i * 32 + j] = field_as_bytes[j];
        }
    }

    bytes
}

/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this
/// is assumed to be an array obtained via \`fields_to_bytes\`, i.e. one that actually represents fields. To convert
/// a byte array into Fields, use \`bytes_to_fields\`.
///
/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted
/// into a Field.
/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]
/// Note 1: N must be a multiple of 32 bytes
/// Note 2: The max value check code was taken from std::field::to_be_bytes function.
pub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {
    // Assert that input length is a multiple of 32
    assert(bytes.len() % 32 == 0, "Input length must be a multiple of 32");

    let mut fields = BoundedVec::new();

    let p = std::field::modulus_be_bytes();

    // Since input length is a multiple of 32, we can simply process all chunks fully
    for i in 0..bytes.len() / 32 {
        let mut field = 0;

        // Process each byte in the 32-byte chunk
        let mut ok = false;

        for j in 0..32 {
            let next_byte = bytes.get(i * 32 + j);
            field = field * 256 + next_byte as Field;

            if !ok {
                if next_byte != p[j] {
                    assert(next_byte < p[j], "Value does not fit in field");
                    ok = true;
                }
            }
        }
        assert(ok, "Value does not fit in field");

        fields.push(field);
    }

    fields
}

mod tests {
    use crate::utils::array::subarray;
    use super::{fields_from_bytes, fields_to_bytes};

    #[test]
    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {
        // Convert to bytes
        let bytes = fields_to_bytes(input);

        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.
        // So we need to convert the field array to a BoundedVec to be able to feed it to the \`fields_from_bytes\`
        // function.
        // 113 is an arbitrary max length that is larger than the input length of 96.
        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);

        // Convert back to fields
        let fields_back = fields_from_bytes(bytes_as_bounded_vec);

        // Compare the original input with the round-tripped result
        assert_eq(fields_back.len(), input.len());
        assert_eq(subarray(fields_back.storage(), 0), input);
    }

    #[test(should_fail_with = "Input length must be a multiple of 32")]
    unconstrained fn to_fields_assert() {
        // 143 is an arbitrary max length that is larger than 33
        let input = BoundedVec::<_, 143>::from_array([
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33,
        ]);

        // This should fail since 33 is not a multiple of 32
        let _fields = fields_from_bytes(input);
    }

    #[test]
    unconstrained fn fields_from_bytes_max_value() {
        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();
        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);

        let fields = fields_from_bytes(input);

        // The result should be a largest value storable in a field (-1 since we are modulo-ing)
        assert_eq(fields.get(0), -1);
    }

    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte
    // and then feeding it to \`fields_from_bytes\` as input.
    #[test(should_fail_with = "Value does not fit in field")]
    unconstrained fn fields_from_bytes_overflow(random_value: u8) {
        let index_of_byte_to_bump = random_value % 32;

        // Obtain the byte representation of the maximum field value
        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();

        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];

        // Skip test execution if the selected byte is already at maximum value (255).
        // This is acceptable since we are using fuzz testing to generate many test cases.
        if byte_to_bump != 255 {
            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);

            // Increment the selected byte to exceed the field's maximum value
            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);

            // Attempt the conversion, which should fail due to the value exceeding the field's capacity
            let _fields = fields_from_bytes(input);
        }
    }

}
`},197:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",source:`use std::option::Option;

global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.

global C1: u32 = 28;
global C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;
global C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;

// Power function of two Field arguments of arbitrary size.
// Adapted from std::field::pow_32.
pub fn pow(x: Field, y: Field) -> Field {
    let mut r = 1 as Field;
    let b: [u1; 254] = y.to_le_bits();

    for i in 0..254 {
        r *= r;
        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);
    }

    r
}

// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.
unconstrained fn is_square(x: Field) -> bool {
    let v = pow(x, -1 / 2);
    v * (v - 1) == 0
}

// Tonelli-Shanks algorithm for computing the square root of a Field element.
// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field
// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),
// and C5 = ZETA^C2, where ZETA is a non-square element of Field.
// These are pre-computed above as globals.
unconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {
    let mut z = pow(x, C3);
    let mut t = z * z * x;
    z *= x;
    let mut b = t;
    let mut c = C5;

    for i in 0..(C1 - 1) {
        for _j in 1..(C1 - i - 1) {
            b *= b;
        }

        z *= if b == 1 { 1 } else { c };

        c *= c;

        t *= if b == 1 { 1 } else { c };

        b = t;
    }

    z
}

// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.
pub unconstrained fn __sqrt(x: Field) -> (bool, Field) {
    let is_sq = is_square(x);
    if is_sq {
        let sqrt = tonelli_shanks_sqrt(x);
        (true, sqrt)
    } else {
        // Demonstrate that x is not a square (a.k.a. a "quadratic non-residue").
        // Facts:
        // The Legendre symbol ("LS") of x, is x^((p-1)/2) (mod p).
        // - If x is a square, LS(x) = 1
        // - If x is not a square, LS(x) = -1
        // - If x = 0, LS(x) = 0.
        //
        // Hence:
        // sq * sq = sq // 1 * 1 = 1
        // non-sq * non-sq = sq // -1 * -1 = 1
        // sq * non-sq = non-sq // -1 * 1 = -1
        //
        // See: https://en.wikipedia.org/wiki/Legendre_symbol
        let demo_x_not_square = x * KNOWN_NON_RESIDUE;
        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);
        (false, not_sqrt)
    }
}

// Returns (false, 0) if there is no square root.
// Returns (true, sqrt) if there is a square root.
pub fn sqrt(x: Field) -> Option<Field> {
    // Safety: if the hint returns the square root of x, then we simply square it
    // check the result equals x. If x is not square, we return a value that
    // enables us to prove that fact (see the \`else\` clause below).
    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };

    if is_sq {
        let sqrt = maybe_sqrt;
        validate_sqrt_hint(x, sqrt);
        Option::some(sqrt)
    } else {
        let not_sqrt_hint = maybe_sqrt;
        validate_not_sqrt_hint(x, not_sqrt_hint);
        Option::none()
    }
}

fn validate_sqrt_hint(x: Field, hint: Field) {
    assert(hint * hint == x, f"The claimed_sqrt {hint} is not the sqrt of x {x}");
}

fn validate_not_sqrt_hint(x: Field, hint: Field) {
    // We need this assertion, because x = 0 would pass the other assertions in this
    // function, and we don't want people to be able to prove that 0 is not square!
    assert(x != 0, "0 has a square root; you cannot claim it is not square");
    // Demonstrate that x is not a square (a.k.a. a "quadratic non-residue").
    //
    // Facts:
    // The Legendre symbol ("LS") of x, is x^((p-1)/2) (mod p).
    // - If x is a square, LS(x) = 1
    // - If x is not a square, LS(x) = -1
    // - If x = 0, LS(x) = 0.
    //
    // Hence:
    // 1. sq * sq = sq // 1 * 1 = 1
    // 2. non-sq * non-sq = sq // -1 * -1 = 1
    // 3. sq * non-sq = non-sq // -1 * 1 = -1
    //
    // See: https://en.wikipedia.org/wiki/Legendre_symbol
    //
    // We want to demonstrate that this below multiplication falls under bullet-point (2):
    let demo_x_not_square = x * KNOWN_NON_RESIDUE;
    // I.e. we want to demonstrate that \`demo_x_not_square\` has Legendre symbol 1
    // (i.e. that it is a square), so we prove that it is square below.
    // Why do we want to prove that it has LS 1?
    // Well, since it was computed with a known-non-residue, its squareness implies we're
    // in case 2 (something multiplied by a known-non-residue yielding a result which
    // has a LS of 1), which implies that x must be a non-square. The unconstrained
    // function gave us the sqrt of demo_x_not_square, so all we need to do is
    // assert its squareness:
    assert(
        hint * hint == demo_x_not_square,
        f"The hint {hint} does not demonstrate that {x} is not a square",
    );
}

#[test]
fn test_sqrt() {
    let x = 9;
    let maybe_sqrt = sqrt(x);
    assert(maybe_sqrt.is_some());
    let sqrt = maybe_sqrt.unwrap_unchecked();
    assert((sqrt == 3) | (sqrt == -3));
}

#[test]
fn test_non_square() {
    let x = 5;
    let maybe_sqrt = sqrt(x);
    assert(maybe_sqrt.is_none());
}

#[test]
unconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {
    assert(!is_square(KNOWN_NON_RESIDUE));
}

#[test]
fn test_sqrt_0() {
    let x = 0;
    let sqrt = sqrt(x).unwrap();
    assert(sqrt == 0);
}

#[test]
fn test_sqrt_1() {
    let x = 1;
    let sqrt = sqrt(x).unwrap();
    assert((sqrt == 1) | (sqrt == -1));
}

#[test(should_fail_with = "The claimed_sqrt 0x04 is not the sqrt of x 0x09")]
fn test_bad_sqrt_hint_fails() {
    validate_sqrt_hint(9, 4);
}

#[test(should_fail_with = "The hint 0x04 does not demonstrate that 0x0a is not a square")]
fn test_bad_not_sqrt_hint_fails() {
    validate_not_sqrt_hint(10, 4);
}

#[test(should_fail_with = "0 has a square root; you cannot claim it is not square")]
fn test_0_not_sqrt_hint_fails() {
    validate_not_sqrt_hint(0, 0);
}

#[test]
unconstrained fn test_is_square() {
    assert(is_square(25));
}

#[test]
unconstrained fn test_is_not_square() {
    assert(!is_square(10));
}
`},199:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",source:`use crate::utils::field::sqrt;
use dep::protocol_types::point::Point;

// I am storing the modulus minus 1 divided by 2 here because full modulus would throw "String literal too large" error
// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617
global BN254_FR_MODULUS_DIV_2: Field =
    10944121435919637611123202872628637544274182200208017171849102093287904247808;

/// Converts a point to a byte array.
///
/// We don't serialize the point at infinity flag because this function is used in situations where we do not want
/// to waste the extra byte (encrypted log).
pub fn point_to_bytes(p: Point) -> [u8; 32] {
    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for
    // the "sign") so it's possible to use that last bit as an "is_infinite" flag if desired in the future.
    assert(!p.is_infinite, "Cannot serialize point at infinity as bytes.");

    let mut result: [u8; 32] = p.x.to_be_bytes();

    if get_sign_of_point(p) {
        // y is <= (modulus - 1) / 2 so we set the sign bit to 1
        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32
        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of
        // the bits as a sign bit.
        result[0] += 128;
    }

    result
}

/**
 * Returns: true if p.y <= MOD_DIV_2, else false.
 */
pub fn get_sign_of_point(p: Point) -> bool {
    // We store only a "sign" of the y coordinate because the rest can be derived from the x coordinate. To get
    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.
    // Ideally we'd do \`y <= MOD_DIV_2\`, but there's no \`lte\` function, so instead we do \`!(y > MOD_DIV_2)\`, which is
    // equivalent, and then rewrite that as \`!(MOD_DIV_2 < y)\`, since we also have no \`gt\` function.
    !BN254_FR_MODULUS_DIV_2.lt(p.y)
}

pub fn point_from_x_coord(x: Field) -> Point {
    // y ^ 2 = x ^ 3 - 17
    let rhs = x * x * x - 17;
    let y = sqrt(rhs).unwrap();
    Point { x, y, is_infinite: false }
}

/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.
/// The y coordinate can be derived from the x coordinate and the "sign" flag by solving the grumpkin curve
/// equation for y.
/// @param x - The x coordinate of the point
/// @param sign - The "sign" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2
pub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {
    // y ^ 2 = x ^ 3 - 17
    let rhs = x * x * x - 17;
    let y = sqrt(rhs).unwrap();

    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y
    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);
    let final_y = if y_is_positive == sign { y } else { -y };

    Point { x, y: final_y, is_infinite: false }
}

mod test {
    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};
    use dep::protocol_types::point::Point;

    #[test]
    unconstrained fn test_point_to_bytes_positive_sign() {
        let p = Point {
            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,
            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,
            is_infinite: false,
        };

        let compressed_point = point_to_bytes(p);

        let expected_compressed_point_positive_sign = [
            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,
            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,
        ];
        assert_eq(expected_compressed_point_positive_sign, compressed_point);
    }

    #[test]
    unconstrained fn test_point_to_bytes_negative_sign() {
        let p = Point {
            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,
            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,
            is_infinite: false,
        };

        let compressed_point = point_to_bytes(p);

        let expected_compressed_point_negative_sign = [
            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,
            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,
        ];

        assert_eq(expected_compressed_point_negative_sign, compressed_point);
    }

    #[test]
    unconstrained fn test_point_from_x_coord_and_sign() {
        // Test positive y coordinate
        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;
        let sign = true;
        let p = point_from_x_coord_and_sign(x, sign);

        assert_eq(p.x, x);
        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);
        assert_eq(p.is_infinite, false);

        // Test negative y coordinate
        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;
        let sign2 = false;
        let p2 = point_from_x_coord_and_sign(x2, sign2);

        assert_eq(p2.x, x2);
        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);
        assert_eq(p2.is_infinite, false);
    }
}
`},200:{path:"/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/random.nr",source:`use crate::oracle::random::random;

/// Returns as many random bytes as specified through N.
pub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {
    let mut bytes = [0; N];
    let mut idx = 32;
    let mut randomness = [0; 32];
    for i in 0..N {
        if idx == 32 {
            randomness = random().to_be_bytes();
            idx = 1; // Skip the first byte as it's always 0.
        }
        bytes[i] = randomness[idx];
        idx += 1;
    }
    bytes
}
`},210:{path:"/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",source:`use std::default::Default;
use std::hash::Hasher;

comptime global RATE: u32 = 3;

pub struct Poseidon2 {
    cache: [Field; 3],
    state: [Field; 4],
    cache_size: u32,
    squeeze_mode: bool, // 0 => absorb, 1 => squeeze
}

impl Poseidon2 {
    #[no_predicates]
    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {
        Poseidon2::hash_internal(input, message_size, message_size != N)
    }

    pub(crate) fn new(iv: Field) -> Poseidon2 {
        let mut result =
            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };
        result.state[RATE] = iv;
        result
    }

    fn perform_duplex(&mut self) {
        // add the cache into sponge state
        for i in 0..RATE {
            // We effectively zero-pad the cache by only adding to the state
            // cache that is less than the specified \`cache_size\`
            if i < self.cache_size {
                self.state[i] += self.cache[i];
            }
        }
        self.state = crate::poseidon2_permutation(self.state, 4);
    }

    fn absorb(&mut self, input: Field) {
        assert(!self.squeeze_mode);
        if self.cache_size == RATE {
            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache
            self.perform_duplex();
            self.cache[0] = input;
            self.cache_size = 1;
        } else {
            // If we're absorbing, and the cache is not full, add the input into the cache
            self.cache[self.cache_size] = input;
            self.cache_size += 1;
        }
    }

    fn squeeze(&mut self) -> Field {
        assert(!self.squeeze_mode);
        // If we're in absorb mode, apply sponge permutation to compress the cache.
        self.perform_duplex();
        self.squeeze_mode = true;

        // Pop one item off the top of the permutation and return it.
        self.state[0]
    }

    fn hash_internal<let N: u32>(
        input: [Field; N],
        in_len: u32,
        is_variable_length: bool,
    ) -> Field {
        let two_pow_64 = 18446744073709551616;
        let iv: Field = (in_len as Field) * two_pow_64;
        let mut sponge = Poseidon2::new(iv);
        for i in 0..input.len() {
            if i < in_len {
                sponge.absorb(input[i]);
            }
        }

        // In the case where the hash preimage is variable-length, we append \`1\` to the end of the input, to distinguish
        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures
        // fixed-length and variable-length hashes do not collide)
        if is_variable_length {
            sponge.absorb(1);
        }
        sponge.squeeze()
    }
}

pub struct Poseidon2Hasher {
    _state: [Field],
}

impl Hasher for Poseidon2Hasher {
    fn finish(self) -> Field {
        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)
        let mut sponge = Poseidon2::new(iv);
        for i in 0..self._state.len() {
            sponge.absorb(self._state[i]);
        }
        sponge.squeeze()
    }

    fn write(&mut self, input: Field) {
        self._state = self._state.push_back(input);
    }
}

impl Default for Poseidon2Hasher {
    fn default() -> Self {
        Poseidon2Hasher { _state: &[] }
    }
}
`},227:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",source:`use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};

pub struct EventSelector {
    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.
    inner: u32,
}

impl Eq for EventSelector {
    fn eq(self, other: EventSelector) -> bool {
        other.inner == self.inner
    }
}

impl Serialize<1> for EventSelector {
    fn serialize(self: Self) -> [Field; 1] {
        [self.inner as Field]
    }
}

impl Deserialize<1> for EventSelector {
    fn deserialize(fields: [Field; 1]) -> Self {
        Self { inner: fields[0] as u32 }
    }
}

impl FromField for EventSelector {
    fn from_field(field: Field) -> Self {
        Self { inner: field as u32 }
    }
}

impl ToField for EventSelector {
    fn to_field(self) -> Field {
        self.inner as Field
    }
}

impl Empty for EventSelector {
    fn empty() -> Self {
        Self { inner: 0 as u32 }
    }
}

impl EventSelector {
    pub fn from_u32(value: u32) -> Self {
        Self { inner: value }
    }

    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {
        let bytes = signature.as_bytes();
        let hash = crate::hash::poseidon2_hash_bytes(bytes);

        // \`hash\` is automatically truncated to fit within 32 bits.
        EventSelector::from_field(hash)
    }

    pub fn zero() -> Self {
        Self { inner: 0 }
    }
}
`},272:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",source:`use crate::{
    address::{
        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,
    },
    constants::{
        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,
        MAX_PROTOCOL_CONTRACTS,
    },
    contract_class_id::ContractClassId,
    hash::poseidon2_hash_with_separator,
    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},
    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},
    utils::field::{pow, sqrt},
};

// We do below because \`use crate::point::Point;\` does not work
use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;

use crate::public_keys::AddressPoint;
use std::{
    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},
    ops::Add,
};

// Aztec address
pub struct AztecAddress {
    pub inner: Field,
}

impl Eq for AztecAddress {
    fn eq(self, other: Self) -> bool {
        self.to_field() == other.to_field()
    }
}

impl Empty for AztecAddress {
    fn empty() -> Self {
        Self { inner: 0 }
    }
}

impl ToField for AztecAddress {
    fn to_field(self) -> Field {
        self.inner
    }
}

impl FromField for AztecAddress {
    fn from_field(value: Field) -> AztecAddress {
        AztecAddress { inner: value }
    }
}

impl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {
    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {
        [self.to_field()]
    }
}

impl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {
    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {
        FromField::from_field(fields[0])
    }
}

/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there
/// the implementation of Packable is required).
impl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {
    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {
        self.serialize()
    }

    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {
        Self::deserialize(fields)
    }
}

impl AztecAddress {
    pub fn zero() -> Self {
        Self { inner: 0 }
    }

    pub fn to_address_point(self) -> AddressPoint {
        // We compute the address point by taking our address, setting it to x, and then solving for y in the
        // equation which defines our bn curve:
        // y^2 = x^3 - 17; x = address
        let x = self.inner;
        let y_squared = pow(x, 3) - 17;

        // TODO (#8970): Handle cases where we cannot recover a point from an address
        let mut y = sqrt(y_squared);

        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the
        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus
        // note: The field modulus is MAX_FIELD_VALUE + 1
        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {
            y = (MAX_FIELD_VALUE + 1) - y;
        }

        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }
    }

    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {
        let public_keys_hash = public_keys.hash();

        let pre_address = poseidon2_hash_with_separator(
            [public_keys_hash.to_field(), partial_address.to_field()],
            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,
        );

        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(
            public_keys.ivpk_m.to_point(),
        );

        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us
        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.
        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or
        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one
        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.
        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,
        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.
        AztecAddress::from_field(address_point.x)
    }

    pub fn compute_from_class_id(
        contract_class_id: ContractClassId,
        salted_initialization_hash: SaltedInitializationHash,
        public_keys: PublicKeys,
    ) -> Self {
        let partial_address = PartialAddress::compute_from_salted_initialization_hash(
            contract_class_id,
            salted_initialization_hash,
        );

        AztecAddress::compute(public_keys, partial_address)
    }

    pub fn is_protocol_contract(self) -> bool {
        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)
    }

    pub fn is_zero(self) -> bool {
        self.inner == 0
    }

    pub fn assert_is_zero(self) {
        assert(self.to_field() == 0);
    }
}

#[test]
fn compute_address_from_partial_and_pub_keys() {
    let public_keys = PublicKeys {
        npk_m: NpkM {
            inner: Point {
                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,
                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,
                is_infinite: false,
            },
        },
        ivpk_m: IvpkM {
            inner: Point {
                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,
                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,
                is_infinite: false,
            },
        },
        ovpk_m: OvpkM {
            inner: Point {
                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,
                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,
                is_infinite: false,
            },
        },
        tpk_m: TpkM {
            inner: Point {
                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,
                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,
                is_infinite: false,
            },
        },
    };

    let partial_address = PartialAddress::from_field(
        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,
    );

    let address = AztecAddress::compute(public_keys, partial_address);

    // The following value was generated by \`derivation.test.ts\`.
    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.
    let expected_computed_address_from_partial_and_pubkeys =
        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;
    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);
}

#[test]
fn compute_preaddress_from_partial_and_pub_keys() {
    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);
    let expected_computed_preaddress_from_partial_and_pubkey =
        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;
    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);
}

#[test]
fn from_field_to_field() {
    let address = AztecAddress { inner: 37 };
    assert_eq(FromField::from_field(address.to_field()), address);
}

#[test]
fn serde() {
    let address = AztecAddress { inner: 37 };
    assert_eq(Deserialize::deserialize(address.serialize()), address);
}
`},275:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",source:`use crate::{
    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},
    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,
    contract_class_id::ContractClassId,
    hash::poseidon2_hash_with_separator,
    traits::{Deserialize, Serialize, ToField},
};

global PARTIAL_ADDRESS_LENGTH: u32 = 1;

// Partial address
pub struct PartialAddress {
    pub inner: Field,
}

impl ToField for PartialAddress {
    fn to_field(self) -> Field {
        self.inner
    }
}

impl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {
    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {
        [self.to_field()]
    }
}

impl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {
    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {
        PartialAddress { inner: fields[0] }
    }
}

impl PartialAddress {
    pub fn from_field(field: Field) -> Self {
        Self { inner: field }
    }

    pub fn compute(
        contract_class_id: ContractClassId,
        salt: Field,
        initialization_hash: Field,
        deployer: AztecAddress,
    ) -> Self {
        PartialAddress::compute_from_salted_initialization_hash(
            contract_class_id,
            SaltedInitializationHash::compute(salt, initialization_hash, deployer),
        )
    }

    pub fn compute_from_salted_initialization_hash(
        contract_class_id: ContractClassId,
        salted_initialization_hash: SaltedInitializationHash,
    ) -> Self {
        PartialAddress::from_field(poseidon2_hash_with_separator(
            [contract_class_id.to_field(), salted_initialization_hash.to_field()],
            GENERATOR_INDEX__PARTIAL_ADDRESS,
        ))
    }

    pub fn to_field(self) -> Field {
        self.inner
    }

    pub fn is_zero(self) -> bool {
        self.to_field() == 0
    }

    pub fn assert_is_zero(self) {
        assert(self.to_field() == 0);
    }
}
`},277:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",source:`use crate::{
    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,
    hash::poseidon2_hash_with_separator, traits::ToField,
};

// Salted initialization hash. Used in the computation of a partial address.
pub struct SaltedInitializationHash {
    pub inner: Field,
}

impl ToField for SaltedInitializationHash {
    fn to_field(self) -> Field {
        self.inner
    }
}

impl SaltedInitializationHash {
    pub fn from_field(field: Field) -> Self {
        Self { inner: field }
    }

    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {
        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(
            [salt, initialization_hash, deployer.to_field()],
            GENERATOR_INDEX__PARTIAL_ADDRESS,
        ))
    }

    pub fn assert_is_zero(self) {
        assert(self.to_field() == 0);
    }
}
`},282:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",source:`use crate::{
    address::{aztec_address::AztecAddress, partial_address::PartialAddress},
    constants::CONTRACT_INSTANCE_LENGTH,
    contract_class_id::ContractClassId,
    public_keys::PublicKeys,
    traits::{Deserialize, FromField, Hash, Serialize, ToField},
};

pub struct ContractInstance {
    pub salt: Field,
    pub deployer: AztecAddress,
    pub contract_class_id: ContractClassId,
    pub initialization_hash: Field,
    pub public_keys: PublicKeys,
}

impl Eq for ContractInstance {
    fn eq(self, other: Self) -> bool {
        self.public_keys.eq(other.public_keys)
            & self.initialization_hash.eq(other.initialization_hash)
            & self.contract_class_id.eq(other.contract_class_id)
            & self.salt.eq(other.salt)
    }
}

impl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {
    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {
        let public_keys_serialized = self.public_keys.serialize();
        [
            self.salt,
            self.deployer.to_field(),
            self.contract_class_id.to_field(),
            self.initialization_hash,
            public_keys_serialized[0],
            public_keys_serialized[1],
            public_keys_serialized[2],
            public_keys_serialized[3],
            public_keys_serialized[4],
            public_keys_serialized[5],
            public_keys_serialized[6],
            public_keys_serialized[7],
            public_keys_serialized[8],
            public_keys_serialized[9],
            public_keys_serialized[10],
            public_keys_serialized[11],
        ]
    }
}

impl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {
    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {
        Self {
            salt: serialized[0],
            deployer: AztecAddress::from_field(serialized[1]),
            contract_class_id: ContractClassId::from_field(serialized[2]),
            initialization_hash: serialized[3],
            public_keys: PublicKeys::deserialize([
                serialized[4],
                serialized[5],
                serialized[6],
                serialized[7],
                serialized[8],
                serialized[9],
                serialized[10],
                serialized[11],
                serialized[12],
                serialized[13],
                serialized[14],
                serialized[15],
            ]),
        }
    }
}

impl Hash for ContractInstance {
    fn hash(self) -> Field {
        self.to_address().to_field()
    }
}

impl ContractInstance {
    pub fn to_address(self) -> AztecAddress {
        AztecAddress::compute(
            self.public_keys,
            PartialAddress::compute(
                self.contract_class_id,
                self.salt,
                self.initialization_hash,
                self.deployer,
            ),
        )
    }
}
`},289:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",source:`/// Utility function to console.log data in the acir simulator.
/// Example:
///   debug_log("blah blah this is a debug string");
pub fn debug_log<let N: u32>(msg: str<N>) {
    debug_log_format(msg, []);
}

/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the
/// \`\${k}\` tokens will be replaced with the k-eth value in the \`args\` array.
/// Examples:
///   debug_log_format("get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}", [storage_slot, note0_hash, note1_hash]);
///   debug_log_format("whole array: {}", [e1, e2, e3, e4]);
pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {
    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe
    // to call.
    unsafe { debug_log_oracle_wrapper(msg, args) };
}

pub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(
    msg: str<M>,
    args: [Field; N],
) {
    debug_log_oracle(msg, args.as_slice());
}

// WARNING: sometimes when using debug logs the ACVM errors with: \`thrown: "solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155"\`
#[oracle(debugLog)]
unconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}
`},290:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",source:`use crate::{
    abis::{
        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,
        contract_class_log::ContractClassLog,
        function_selector::FunctionSelector,
        note_hash::ScopedNoteHash,
        nullifier::ScopedNullifier,
        private_log::{PrivateLog, PrivateLogData},
        side_effect::{OrderedValue, scoped::Scoped},
    },
    address::{AztecAddress, EthAddress},
    constants::{
        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,
        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,
        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,
    },
    merkle_tree::root::root_from_sibling_path,
    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},
    poseidon2::Poseidon2Sponge,
    traits::{FromField, Hash, ToField},
    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},
};

pub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {
    let sha256_hashed = sha256::digest(bytes_to_hash);
    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);

    hash_in_a_field
}

pub fn private_functions_root_from_siblings(
    selector: FunctionSelector,
    vk_hash: Field,
    function_leaf_index: Field,
    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],
) -> Field {
    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };
    let function_leaf = function_leaf_preimage.hash();
    root_from_sibling_path(
        function_leaf,
        function_leaf_index,
        function_leaf_sibling_path,
    )
}

pub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {
    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also
    // unique).
    poseidon2_hash_with_separator(
        [first_nullifier_in_tx, note_index_in_tx as Field],
        GENERATOR_INDEX__NOTE_HASH_NONCE,
    )
}

pub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {
    let inputs = [nonce, siloed_note_hash];
    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)
}

pub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {
    poseidon2_hash_with_separator(
        [app.to_field(), note_hash],
        GENERATOR_INDEX__SILOED_NOTE_HASH,
    )
}

/// Computes unique note hashes from siloed note hashes
pub fn compute_unique_siloed_note_hash(
    siloed_note_hash: Field,
    first_nullifier: Field,
    note_index_in_tx: u32,
) -> Field {
    if siloed_note_hash == 0 {
        0
    } else {
        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);
        compute_unique_note_hash(nonce, siloed_note_hash)
    }
}

/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way
/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.
pub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {
    if note_hash.contract_address.is_zero() {
        0
    } else {
        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())
    }
}

pub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {
    poseidon2_hash_with_separator(
        [app.to_field(), nullifier],
        GENERATOR_INDEX__OUTER_NULLIFIER,
    )
}

pub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {
    if nullifier.contract_address.is_zero() {
        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.
    } else {
        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())
    }
}

pub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {
    poseidon2_hash([contract_address.to_field(), field])
}

pub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {
    if private_log.contract_address.is_zero() {
        private_log.inner.log
    } else {
        let mut fields = private_log.inner.log.fields;
        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);
        PrivateLog::new(fields, private_log.inner.log.length)
    }
}

pub fn compute_siloed_contract_class_log_field(
    contract_address: AztecAddress,
    first_field: Field,
) -> Field {
    poseidon2_hash([contract_address.to_field(), first_field])
}

pub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {
    if contract_class_log.contract_address.is_zero() {
        contract_class_log
    } else {
        let mut log = contract_class_log;
        log.log.fields[0] = compute_siloed_contract_class_log_field(
            contract_class_log.contract_address,
            log.log.fields[0],
        );
        log
    }
}

pub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {
    poseidon2_hash(log)
}

pub fn merkle_hash(left: Field, right: Field) -> Field {
    poseidon2_hash([left, right])
}

pub fn compute_l2_to_l1_hash(
    contract_address: AztecAddress,
    recipient: EthAddress,
    content: Field,
    rollup_version_id: Field,
    chain_id: Field,
) -> Field {
    let mut bytes: [u8; 160] = std::mem::zeroed();

    let inputs =
        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];
    for i in 0..5 {
        // TODO are bytes be in fr.to_buffer() ?
        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();
        for j in 0..32 {
            bytes[32 * i + j] = item_bytes[j];
        }
    }

    sha256_to_field(bytes)
}

pub fn silo_l2_to_l1_message(
    msg: ScopedL2ToL1Message,
    rollup_version_id: Field,
    chain_id: Field,
) -> Field {
    if msg.contract_address.is_zero() {
        0
    } else {
        compute_l2_to_l1_hash(
            msg.contract_address,
            msg.message.recipient,
            msg.message.content,
            rollup_version_id,
            chain_id,
        )
    }
}

// Computes sha256 hash of 2 input hashes.
//
// NB: This method now takes in two 31 byte fields - it assumes that any input
// is the result of a sha_to_field hash and => is truncated
//
// TODO(Jan and David): This is used for the encrypted_log hashes.
// Can we check to see if we can just use hash_to_field or pedersen_compress here?
//
pub fn accumulate_sha256(input: [Field; 2]) -> Field {
    // This is a note about the cpp code, since it takes an array of Fields
    // instead of a u128.
    // 4 Field elements when converted to bytes will usually
    // occupy 4 * 32 = 128 bytes.
    // However, this function is making the assumption that each Field
    // only occupies 128 bits.
    //
    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?
    // Concatentate two fields into 32x2 = 64 bytes
    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers
    let mut hash_input_flattened = [0; 64];
    for offset in 0..input.len() {
        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();
        for byte_index in 0..32 {
            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];
        }
    }

    sha256_to_field(hash_input_flattened)
}

pub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {
    crate::hash::poseidon2_hash(key)
}

#[inline_always]
pub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {
    std::hash::pedersen_hash_with_separator(inputs, hash_index)
}

pub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {
    poseidon::poseidon2::Poseidon2::hash(inputs, N)
}

#[no_predicates]
pub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field
where
    T: ToField,
{
    let inputs_with_separator = array_concat([separator.to_field()], inputs);
    poseidon2_hash(inputs_with_separator)
}

// Performs a fixed length hash with a subarray of the given input.
// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.
// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()
// or any ts implementation. Also checks that any remaining elts not hashed are empty.
#[no_predicates]
pub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {
    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);
    sponge.squeeze()
}

// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,
// and absorbing in chunks of 3 below.
#[no_predicates]
pub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {
    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);
    // In the case where the hash preimage is variable-length, we append \`1\` to the end of the input, to distinguish
    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures
    // fixed-length and variable-length hashes do not collide)
    if in_len != N {
        sponge.absorb(1);
    }
    sponge.squeeze()
}

// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)
// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know
// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.
// The below code forces the compiler to:
//  - absorb normally up to 2 times to set cache_size to 1
//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb
//  - absorb normally up to 2 times to add any remaining values to the hash
// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.
// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.

#[no_predicates]
fn poseidon2_absorb_chunks<let N: u32>(
    input: [Field; N],
    in_len: u32,
    variable: bool,
) -> Poseidon2Sponge {
    let iv: Field = (in_len as Field) * TWO_POW_64;
    let mut sponge = Poseidon2Sponge::new(iv);
    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow
    // since we cannot isolate computation branches. The below is just to avoid that.
    let shift = if in_len == 0 { 0 } else { 1 };
    if in_len != 0 {
        // cache_size = 0, init absorb
        sponge.cache[0] = input[0];
        sponge.cache_size = 1;
        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge
        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)
        // max_remainder = (N - 1) % 3;
        // max_chunks = (N - 1 - max_remainder) / 3;
        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(
            sponge,
            input,
            in_len,
            variable,
            shift,
        );
    }
    sponge
}

// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true
#[no_predicates]
pub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(
    in_sponge: Poseidon2Sponge,
    input: [Field; N],
    in_len: u32,
    skip_0_check: bool,
) -> Poseidon2Sponge {
    let mut sponge = in_sponge;
    // 'shift' is to account for already added inputs
    let mut shift = 0;
    // 'stop' is to avoid an underflow when inputting in_len = 0
    let mut stop = false;
    for i in 0..3 {
        if shift == in_len {
            stop = true;
        }
        if (sponge.cache_size != 1) & (!stop) {
            sponge.absorb(input[i]);
            shift += 1;
        }
    }
    sponge = if stop {
        sponge
    } else {
        // max_chunks = (N - (N % 3)) / 3;
        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(
            sponge,
            input,
            in_len,
            skip_0_check,
            shift,
        )
    };
    sponge
}

// The below is the loop to absorb elts into a poseidon sponge in chunks of 3
// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1
// M - the max number of chunks required to absorb N things (must be comptime to compile)
// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check
// for 0s costs 3N gates. Current approach is approx 2N gates.
#[no_predicates]
fn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(
    in_sponge: Poseidon2Sponge,
    input: [Field; N],
    in_len: u32,
    variable: bool,
    shift: u32,
) -> Poseidon2Sponge {
    assert(in_len <= N, "Given in_len to absorb is larger than the input array len");
    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N
    // The below avoids an overflow
    let skip_last = 3 * M == N;
    // Writing in_sponge: &mut does not compile
    let mut sponge = in_sponge;
    let mut should_add = true;
    // The num of things left over after absorbing in 3s
    let remainder = (in_len - shift) % 3;
    // The num of chunks of 3 to absorb (maximum M)
    let chunks = (in_len - shift - remainder) / 3;
    for i in 0..M {
        // Now we loop through cache size = 1 -> 3
        should_add &= i != chunks;
        // This is the index at the start of the chunk (for readability)
        let k = 3 * i + shift;
        if should_add {
            // cache_size = 1, 2 => just assign
            sponge.cache[1] = input[k];
            sponge.cache[2] = input[k + 1];
            // cache_size = 3 => duplex + perm
            for j in 0..3 {
                sponge.state[j] += sponge.cache[j];
            }
            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);
            sponge.cache[0] = input[k + 2];
            // cache_size is now 1 again, repeat loop
        } else if (!variable) & (i != chunks) {
            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0
            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below
            let last_0 = if (i == M - 1) & (skip_last) {
                0
            } else {
                input[k + 2]
            };
            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);
            assert(all_0, "Found non-zero field after breakpoint");
        }
    }
    // we have 'remainder' num of items left to absorb
    should_add = true;
    // below is to avoid overflows (i.e. if inlen is close to N)
    let mut should_check = !variable;
    for i in 0..3 {
        should_add &= i != remainder;
        should_check &= in_len - remainder + i != N;
        if should_add {
            // we want to absorb the final 'remainder' items
            sponge.absorb(input[in_len - remainder + i]);
        } else if should_check {
            assert(input[in_len - remainder + i] == 0, "Found non-zero field after breakpoint");
        }
    }
    sponge
}

pub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field
where
    T: ToField,
{
    let in_len = inputs.len() + 1;
    let iv: Field = (in_len as Field) * TWO_POW_64;
    let mut sponge = Poseidon2Sponge::new(iv);
    sponge.absorb(separator.to_field());

    for i in 0..inputs.len() {
        sponge.absorb(inputs[i]);
    }

    sponge.squeeze()
}

#[no_predicates]
pub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {
    let mut fields = [0; (N + 30) / 31];
    let mut field_index = 0;
    let mut current_field = [0; 31];
    for i in 0..inputs.len() {
        let index = i % 31;
        current_field[index] = inputs[i];
        if index == 30 {
            fields[field_index] = field_from_bytes(current_field, false);
            current_field = [0; 31];
            field_index += 1;
        }
    }
    if field_index != fields.len() {
        fields[field_index] = field_from_bytes(current_field, false);
    }
    poseidon2_hash(fields)
}

#[test]
fn poseidon_chunks_matches_fixed() {
    let in_len = 501;
    let mut input: [Field; 4096] = [0; 4096];
    let mut fixed_input = [3; 501];
    assert(in_len == fixed_input.len()); // sanity check
    for i in 0..in_len {
        input[i] = 3;
    }
    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);
    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());
    assert(sub_chunk_hash == fixed_len_hash);
}

#[test]
fn poseidon_chunks_matches_variable() {
    let in_len = 501;
    let mut input: [Field; 4096] = [0; 4096];
    for i in 0..in_len {
        input[i] = 3;
    }
    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);
    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);
    assert(variable_chunk_hash == variable_len_hash);
}

#[test]
fn existing_sponge_poseidon_chunks_matches_fixed() {
    let in_len = 501;
    let mut input: [Field; 4096] = [0; 4096];
    let mut fixed_input = [3; 501];
    assert(in_len == fixed_input.len()); // sanity check
    for i in 0..in_len {
        input[i] = 3;
    }
    // absorb 250 of the 501 things
    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);
    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);
    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)
    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);
    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());
    assert(final_sponge.squeeze() == fixed_len_hash);
}

#[test]
fn poseidon_chunks_empty_inputs() {
    let in_len = 0;
    let mut input: [Field; 4096] = [0; 4096];
    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);
    let mut first_sponge =
        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);
    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());
}

#[test]
fn smoke_sha256_to_field() {
    let full_buffer = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,
        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,
        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
    ];
    let result = sha256_to_field(full_buffer);

    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);

    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):
    let result_bytes = sha256::digest(full_buffer);
    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);
    assert(truncated_field == result);
    let mod_res = result + (result_bytes[31] as Field);
    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);
}

#[test]
fn compute_l2_l1_hash() {
    // All zeroes
    let hash_result =
        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);
    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);

    // Non-zero case
    let hash_result = compute_l2_to_l1_hash(
        AztecAddress::from_field(1),
        EthAddress::from_field(3),
        5,
        2,
        4,
    );
    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);
}

#[test]
fn silo_l2_to_l1_message_matches_typescript() {
    let version = 4;
    let chainId = 5;

    let hash = silo_l2_to_l1_message(
        ScopedL2ToL1Message {
            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },
            contract_address: AztecAddress::from_field(3),
        },
        version,
        chainId,
    );

    // The following value was generated by \`l2_to_l1_message.test.ts\`
    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;

    assert_eq(hash, hash_from_typescript);
}
`},291:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",source:`use crate::traits::{Deserialize, Serialize, ToField};
use super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};
use std::meta::derive;

pub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;

#[derive(Serialize, Deserialize)]
pub struct IndexedTaggingSecret {
    app_tagging_secret: Field,
    index: u32,
}

impl IndexedTaggingSecret {
    pub fn compute_tag(self, recipient: AztecAddress) -> Field {
        poseidon2_hash(
            [self.app_tagging_secret, recipient.to_field(), self.index as Field],
        )
    }
}
`},304:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",source:`use super::traits::{Deserialize, Packable, Serialize};

/// Returns the typed expression of a trait method implementation.
///
/// This helper function is preferred over directly inlining with \`$typ::target_method()\` in a quote,
/// as direct inlining would result in missing import warnings in the generated code (specifically,
/// warnings that the trait implementation is not in scope).
///
/// # Note
/// A copy of this function exists in \`aztec-nr/aztec/src/macros/utils.nr\`. We maintain separate copies
/// because importing it there from here would cause the \`target_trait\` to be interpreted in the context
/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).
comptime fn get_trait_impl_method(
    typ: Type,
    target_trait: Quoted,
    target_method: Quoted,
) -> TypedExpr {
    let trait_constraint = target_trait.as_trait_constraint();
    typ
        .get_trait_impl(trait_constraint)
        .expect(f"Could not find impl for {target_trait} for type {typ}")
        .methods()
        .filter(|m| m.name() == target_method)[0]
        .as_typed_expr()
}

/// Generates code that deserializes a struct, primitive type, array or string from a field array.
///
/// # Parameters
/// - \`name\`: The name of the current field being processed, used to identify fields for replacement.
/// - \`typ\`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).
/// - \`field_array_name\`: The name of the field array containing serialized field data (e.g., \`"values"\`).
/// - \`num_already_consumed\`: The number of fields already processed in previous recursion calls.
/// - \`should_unpack\`: A boolean indicating whether the type should be unpacked (see description of \`Packable\`
/// and \`Serialize\` trait for more information about the difference between packing and serialization).
///
/// # Returns
/// A tuple containing:
/// - \`Quoted\`: A code that deserializes a given struct, primitive type, array, or string from the field array.
/// - \`u32\`: The total number of fields consumed during deserialization (used for recursion).
///
/// # Nested Struct Example
/// Given the following setup:
/// \`\`\`
/// struct UintNote {
///     value: u128,
///     owner: AztecAddress,
///     randomness: Field,
/// }
///
/// struct AztecAddress {
///     inner: Field,
/// }
/// \`\`\`
///
/// If \`UintNote\` is the input type, the function will generate the following deserialization code:
/// \`\`\`
/// UintNote {
///     value: fields[0] as u128,
///     owner: AztecAddress {
///         inner: fields[1],
///     },
///     randomness: fields[2],
/// }
/// \`\`\`
/// # Nested Struct Example with Unpacking
/// - given the same setup as above and given that u128, AztecAddress and Field implement the \`Packable\` trait
///   the result we get is:
/// \`\`\`
/// UintNote {
///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),
///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),
///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),
/// }
/// \`\`\`
///
/// # Panics
/// - If the deserialization logic encounters a type it does not support.
/// - If an incorrect number of fields are consumed when deserializing a string.
pub comptime fn generate_deserialize_from_fields(
    name: Quoted,
    typ: Type,
    field_array_name: Quoted,
    num_already_consumed: u32,
    should_unpack: bool,
) -> (Quoted, u32) {
    let mut result = quote {};
    // Counter for the number of fields consumed
    let mut consumed_counter: u32 = 0;

    // If the type implements \`Packable\`, its length will be assigned to the \`maybe_packed_len_typ\` variable.
    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();
    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();

    if (should_unpack & typ.implements(packable_constraint)) {
        // Unpacking is enabled and the given type implements the \`Packable\` trait so we call the \`unpack()\`
        // method, add the resulting field array to \`aux_vars\` and each field to \`fields\`.
        let packed_len = maybe_packed_len_typ.as_constant().unwrap();

        // We copy the packed fields into a new array and pass that to the unpack function in a quote
        let mut packed_fields_quotes = &[];
        for i in 0..packed_len {
            let index_in_field_array = i + num_already_consumed;
            packed_fields_quotes =
                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });
        }
        let packed_fields = packed_fields_quotes.join(quote {,});

        // Now we call unpack on the type
        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });
        result = quote { $unpack_method([ $packed_fields ]) };

        consumed_counter = packed_len;
    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {
        // The field is a primitive so we just reference it in the field array
        result = quote { $field_array_name[$num_already_consumed] as $typ };
        consumed_counter = 1;
    } else if typ.as_data_type().is_some() {
        // The field is a struct so we iterate over each struct field and recursively call
        // \`generate_deserialize_from_fields\`
        let (nested_def, generics) = typ.as_data_type().unwrap();
        let nested_name = nested_def.name();
        let mut deserialized_fields_list = &[];

        // Iterate over each field in the struct
        for field in nested_def.fields(generics) {
            let (field_name, field_type) = field;
            // Recursively call \`generate_deserialize_from_fields\` for each field in the struct
            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(
                field_name,
                field_type,
                field_array_name,
                consumed_counter + num_already_consumed,
                should_unpack,
            );
            // We increment the consumed counter by the number of fields consumed in the recursion
            consumed_counter += num_consumed_in_recursion;
            // We add the deserialized field to the list of deserialized fields.
            // E.g. \`value: u128 { lo: fields[0], hi: fields[1] }\`
            deserialized_fields_list =
                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });
        }

        // We can construct the struct from the deserialized fields
        let deserialized_fields = deserialized_fields_list.join(quote {,});
        result = quote {
                $nested_name {
                    $deserialized_fields
                }
            };
    } else if typ.as_array().is_some() {
        // The field is an array so we iterate over each element and recursively call
        // \`generate_deserialize_from_fields\`
        let (element_type, array_len) = typ.as_array().unwrap();
        let array_len = array_len.as_constant().unwrap();
        let mut array_fields_list = &[];

        // Iterate over each element in the array
        for _ in 0..array_len {
            // Recursively call \`generate_deserialize_from_fields\` for each element in the array
            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(
                name,
                element_type,
                field_array_name,
                consumed_counter + num_already_consumed,
                should_unpack,
            );
            // We increment the consumed counter by the number of fields consumed in the recursion
            consumed_counter += num_consumed_in_recursion;
            // We add the deserialized field to the list of deserialized fields.
            array_fields_list = array_fields_list.push_back(deserialized_field);
        }

        // We can construct the array from the deserialized fields
        let array_fields = array_fields_list.join(quote {,});
        result = quote { [ $array_fields ] };
    } else if typ.as_str().is_some() {
        // The field is a string and we expect each byte of the string to be represented as 1 field in the field
        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call
        // to \`generate_deserialize_from_fields\`.
        let length_type = typ.as_str().unwrap();
        let str_len = length_type.as_constant().unwrap();
        let mut byte_list = &[];

        // Iterate over each character in the string
        for _ in 0..str_len {
            // Recursively call \`generate_deserialize_from_fields\` for each character in the string
            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(
                name,
                quote {u8}.as_type(),
                field_array_name,
                consumed_counter + num_already_consumed,
                should_unpack,
            );

            // We should consume just one field in the recursion so we sanity check that
            assert_eq(
                num_consumed_in_recursion,
                1,
                "Incorrect number of fields consumed in string deserialization",
            );

            // We increment the consumed counter by 1 as we have consumed one field
            consumed_counter += 1;

            // We add the deserialized field to the list of deserialized fields.
            // E.g. \`fields[6] as u8\`
            byte_list = byte_list.push_back(deserialized_field);
        }

        // We construct the string from the deserialized fields
        let bytes = byte_list.join(quote {,});
        result = quote { [ $bytes ].as_str_unchecked() };
    } else {
        panic(
            f"Unsupported type for serialization of argument {name} and type {typ}",
        )
    }

    (result, consumed_counter)
}

/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary
/// for serialization. If \`should_pack\` is true, we check if the type implements the \`Packable\` trait and pack it
/// if it does.
///
/// # Parameters
/// - \`name\`: The base identifier (e.g., \`self\`, \`some_var\`).
/// - \`typ\`: The type being serialized (e.g., a custom struct, array, or primitive type).
/// - \`should_pack\`: A boolean indicating whether the type should be packed.
///
/// # Returns
/// A tuple containing:
/// - A flattened array of \`Quoted\` field references representing the serialized fields.
/// - An array of \`Quoted\` auxiliary variables needed for serialization, such as byte arrays for strings.
///
/// # Examples
///
/// ## Struct
/// Given the following struct:
/// \`\`\`rust
/// struct MockStruct {
///     a: Field,
///     b: Field,
/// }
/// \`\`\`
///
/// Serializing the struct:
/// \`\`\`rust
/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)
/// // Returns:
/// // ([\`my_mock_struct.a\`, \`my_mock_struct.b\`], [])
/// \`\`\`
///
/// ## Nested Struct
/// For a more complex struct:
/// \`\`\`rust
/// struct NestedStruct {
///     m1: MockStruct,
///     m2: MockStruct,
/// }
/// \`\`\`
///
/// Serialization output:
/// \`\`\`rust
/// generate_serialize_to_fields(quote { self }, NestedStruct, false)
/// // Returns:
/// // ([\`self.m1.a\`, \`self.m1.b\`, \`self.m2.a\`, \`self.m2.b\`], [])
/// \`\`\`
///
/// ## Array
/// For an array type:
/// \`\`\`rust
/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)
/// // Returns:
/// // ([\`my_array[0]\`, \`my_array[1]\`, \`my_array[2]\`], [])
/// \`\`\`
///
/// ## String
/// For a string field, where each character is serialized as a \`Field\`:
/// \`\`\`rust
/// generate_serialize_to_fields(quote { my_string }, StringType, false)
/// // Returns:
/// // ([\`my_string_as_bytes[0] as Field\`, \`my_string_as_bytes[1] as Field\`, ...],
/// // [\`let my_string_as_bytes = my_string.as_bytes()\`])
/// \`\`\`
///
/// ## Nested Struct with packing enabled
/// - u128 has a \`Packable\` implementation hence it will be packed.
///
/// For a more complex struct:
/// \`\`\`rust
/// struct MyStruct {
///     value: u128,
///     value2: Field,
/// }
/// \`\`\`
///
/// # Panics
/// - If the type is unsupported for serialization.
/// - If the provided \`typ\` contains invalid constants or incompatible structures.
pub comptime fn generate_serialize_to_fields(
    name: Quoted,
    typ: Type,
    should_pack: bool,
) -> ([Quoted], [Quoted]) {
    let mut fields = &[];
    let mut aux_vars = &[];

    // If the type implements \`Packable\`, its length will be assigned to the \`maybe_packed_len_typ\` variable.
    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();
    let packable_constraint =
        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();

    if (should_pack & typ.implements(packable_constraint)) {
        // Packing is enabled and the given type implements the \`Packable\` trait so we call the \`pack()\`
        // method, add the resulting field array to \`aux_vars\` and each field to \`fields\`.
        let packed_len = maybe_packed_len_typ.as_constant().unwrap();

        // We collapse the name to a one that gets tokenized as a single token (e.g. "self.value" -> "self_value").
        let name_at_one_token = collapse_to_one_token(name);
        let packed_struct_name = f"{name_at_one_token}_aux_var".quoted_contents();

        // We add the individual fields to the fields array
        let pack_method = get_trait_impl_method(
            typ,
            quote { crate::traits::Packable<$packed_len> },
            quote { pack },
        );
        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };
        for i in 0..packed_len {
            fields = fields.push_back(quote { $packed_struct_name[$i] });
        }

        // We add the new auxiliary variable to the aux_vars array
        aux_vars = aux_vars.push_back(packed_struct);
    } else if typ.is_field() {
        // For field we just add the value to fields
        fields = fields.push_back(name);
    } else if typ.as_integer().is_some() | typ.is_bool() {
        // For integer and bool we just cast to Field and add the value to fields
        fields = fields.push_back(quote { $name as Field });
    } else if typ.as_data_type().is_some() {
        // For struct we pref
        let nested_struct = typ.as_data_type().unwrap();
        let params = nested_struct.0.fields(nested_struct.1);
        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {
            let maybe_prefixed_name = if name == quote {} {
                // Triggered when the param name is of a value available in the current scope (e.g. a function
                // argument) --> then we don't prefix the name with anything.
                param_name
            } else {
                // Triggered when we want to prefix the param name with the \`name\` from function input. This
                // can typically be \`self\` when implementing a method on a struct.
                quote { $name.$param_name }
            };
            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)
        });
        let struct_flattened_fields = struct_flattened.fold(
            &[],
            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),
        );
        let struct_flattened_aux_vars = struct_flattened.fold(
            &[],
            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),
        );
        fields = fields.append(struct_flattened_fields);
        aux_vars = aux_vars.append(struct_flattened_aux_vars);
    } else if typ.as_array().is_some() {
        // For array we recursively call \`generate_serialize_to_fields(...)\` for each element
        let (element_type, array_len) = typ.as_array().unwrap();
        let array_len = array_len.as_constant().unwrap();
        for i in 0..array_len {
            let (element_fields, element_aux_vars) =
                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);
            fields = fields.append(element_fields);
            aux_vars = aux_vars.append(element_aux_vars);
        }
    } else if typ.as_str().is_some() {
        // For string we convert the value to bytes, we store the \`as_bytes\` in an auxiliary variables and
        // then we add each byte to fields as a Field
        let length_type = typ.as_str().unwrap();
        let str_len = length_type.as_constant().unwrap();
        let as_member = name.as_expr().unwrap().as_member_access();
        let var_name = if as_member.is_some() {
            as_member.unwrap().1
        } else {
            name
        };
        let as_bytes_name = f"{var_name}_as_bytes".quoted_contents();
        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };
        for i in 0..str_len {
            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });
        }
        aux_vars = aux_vars.push_back(as_bytes);
    } else {
        panic(
            f"Unsupported type for serialization of argument {name} and type {typ}",
        )
    }

    (fields, aux_vars)
}

/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all \`.\` with \`_\`.
/// E.g. "self.values[0]" -> "self_values_0_"
comptime fn collapse_to_one_token(q: Quoted) -> Quoted {
    let tokens = q.tokens();

    let mut single_token = quote {};
    for token in tokens {
        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {
            quote {_}
        } else {
            token
        };
        single_token = f"{single_token}{new_token}".quoted_contents();
    }
    single_token
}

pub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {
    let typ = s.as_type();
    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);
    let aux_vars_for_serialization = if aux_vars.len() > 0 {
        let joint = aux_vars.join(quote {;});
        quote { $joint; }
    } else {
        quote {}
    };

    let field_serializations = fields.join(quote {,});
    let serialized_len = fields.len();
    quote {
        impl Serialize<$serialized_len> for $typ {
            #[inline_always]
            fn serialize(self) -> [Field; $serialized_len] {
                $aux_vars_for_serialization
                [ $field_serializations ]
            }
        }
    }
}

pub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {
    let typ = s.as_type();
    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);
    let serialized_len = fields.len();
    let (deserialized, _) =
        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);
    quote {
        impl Deserialize<$serialized_len> for $typ {
            #[inline_always]
            fn deserialize(serialized: [Field; $serialized_len]) -> Self {
                $deserialized
            }
        }
    }
}

/// Generates \`Packable\` implementation for a given struct and returns the packed length.
///
/// Note: We are having this function separate from \`derive_packable\` because we use this in the note macros to get
/// the packed length of a note as well as the \`Packable\` implementation. We need the length to be able to register
/// the note in the global \`NOTES\` map. There the length is used to generate partial note helper functions.
pub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {
    let packing_enabled = true;

    let typ = s.as_type();
    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);
    let aux_vars_for_packing = if aux_vars.len() > 0 {
        let joint = aux_vars.join(quote {;});
        quote { $joint; }
    } else {
        quote {}
    };

    let (unpacked, _) =
        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);

    let field_packings = fields.join(quote {,});
    let packed_len = fields.len();
    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();
    (
        quote {
        impl $packable_trait for $typ {
            fn pack(self) -> [Field; $packed_len] {
                $aux_vars_for_packing
                [ $field_packings ]
            }

            fn unpack(packed: [Field; $packed_len]) -> Self {
                $unpacked
            }
        }
    },
        packed_len,
    )
}

pub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {
    let (packable_impl, _) = derive_packable_and_get_packed_len(s);
    packable_impl
}

#[derive(Packable, Serialize, Deserialize, Eq)]
pub struct Smol {
    a: Field,
    b: Field,
}

#[derive(Serialize, Deserialize, Eq)]
pub struct HasArray {
    a: [Field; 2],
    b: bool,
}

#[derive(Serialize, Deserialize, Eq)]
pub struct Fancier {
    a: Smol,
    b: [Field; 2],
    c: [u8; 3],
    d: str<16>,
}

fn main() {
    assert(false);
}

#[test]
fn smol_test() {
    let smol = Smol { a: 1, b: 2 };
    let serialized = smol.serialize();
    assert(serialized == [1, 2], serialized);
    let deserialized = Smol::deserialize(serialized);
    assert(deserialized == smol);

    // None of the struct members implements the \`Packable\` trait so the packed and serialized data should be the same
    let packed = smol.pack();
    assert_eq(packed, serialized, "Packed does not match serialized");
}

#[test]
fn has_array_test() {
    let has_array = HasArray { a: [1, 2], b: true };
    let serialized = has_array.serialize();
    assert(serialized == [1, 2, 1], serialized);
    let deserialized = HasArray::deserialize(serialized);
    assert(deserialized == has_array);
}

#[test]
fn fancier_test() {
    let fancier =
        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: "metaprogramming!" };
    let serialized = fancier.serialize();
    assert(
        serialized
            == [
                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,
                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,
            ],
        serialized,
    );
    let deserialized = Fancier::deserialize(serialized);
    assert(deserialized == fancier);
}
`},306:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",source:`pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;
use crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};

pub global POINT_LENGTH: u32 = 3;

impl Serialize<POINT_LENGTH> for Point {
    fn serialize(self: Self) -> [Field; POINT_LENGTH] {
        [self.x, self.y, self.is_infinite as Field]
    }
}

impl Hash for Point {
    fn hash(self) -> Field {
        poseidon2_hash(self.serialize())
    }
}

impl Empty for Point {
    /// Note: Does not return a valid point on curve - instead represents an empty/"unpopulated" point struct (e.g.
    /// empty/unpopulated value in an array of points).
    fn empty() -> Self {
        Point { x: 0, y: 0, is_infinite: false }
    }
}

impl Deserialize<POINT_LENGTH> for Point {
    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {
        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }
    }
}
// TODO(#11356): use compact representation here.
impl Packable<POINT_LENGTH> for Point {
    fn pack(self) -> [Field; POINT_LENGTH] {
        self.serialize()
    }

    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {
        Self::deserialize(packed)
    }
}
`},307:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",source:`use crate::constants::TWO_POW_64;

// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr
// It exists as we sometimes need to perform custom absorption, but the stdlib version
// has a private absorb() method (it's also designed to just be a hasher)
// Can be removed when standalone noir poseidon lib exists: See noir#6679

comptime global RATE: u32 = 3;

pub struct Poseidon2Sponge {
    pub cache: [Field; 3],
    pub state: [Field; 4],
    pub cache_size: u32,
    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze
}

impl Poseidon2Sponge {
    #[no_predicates]
    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {
        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)
    }

    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {
        let mut result =
            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };
        result.state[RATE] = iv;
        result
    }

    fn perform_duplex(&mut self) {
        // add the cache into sponge state
        for i in 0..RATE {
            // We effectively zero-pad the cache by only adding to the state
            // cache that is less than the specified \`cache_size\`
            if i < self.cache_size {
                self.state[i] += self.cache[i];
            }
        }
        self.state = std::hash::poseidon2_permutation(self.state, 4);
    }

    pub fn absorb(&mut self, input: Field) {
        assert(!self.squeeze_mode);
        if self.cache_size == RATE {
            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache
            self.perform_duplex();
            self.cache[0] = input;
            self.cache_size = 1;
        } else {
            // If we're absorbing, and the cache is not full, add the input into the cache
            self.cache[self.cache_size] = input;
            self.cache_size += 1;
        }
    }

    pub fn squeeze(&mut self) -> Field {
        assert(!self.squeeze_mode);
        // If we're in absorb mode, apply sponge permutation to compress the cache.
        self.perform_duplex();
        self.squeeze_mode = true;

        // Pop one item off the top of the permutation and return it.
        self.state[0]
    }

    fn hash_internal<let N: u32>(
        input: [Field; N],
        in_len: u32,
        is_variable_length: bool,
    ) -> Field {
        let iv: Field = (in_len as Field) * TWO_POW_64;
        let mut sponge = Poseidon2Sponge::new(iv);
        for i in 0..input.len() {
            if i < in_len {
                sponge.absorb(input[i]);
            }
        }

        // In the case where the hash preimage is variable-length, we append \`1\` to the end of the input, to distinguish
        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures
        // fixed-length and variable-length hashes do not collide)
        if is_variable_length {
            sponge.absorb(1);
        }
        sponge.squeeze()
    }
}
`},317:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",source:`use crate::{
    address::public_keys_hash::PublicKeysHash,
    constants::{
        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,
        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,
    },
    hash::poseidon2_hash_with_separator,
    point::POINT_LENGTH,
    traits::{Deserialize, Hash, Serialize},
};

use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;
use std::default::Default;

pub global PUBLIC_KEYS_LENGTH: u32 = 12;

pub struct PublicKeys {
    pub npk_m: NpkM,
    pub ivpk_m: IvpkM,
    pub ovpk_m: OvpkM,
    pub tpk_m: TpkM,
}

pub trait ToPoint {
    fn to_point(self) -> Point;
}

pub struct NpkM {
    pub inner: Point,
}

impl ToPoint for NpkM {
    fn to_point(self) -> Point {
        self.inner
    }
}

impl Serialize<POINT_LENGTH> for NpkM {
    fn serialize(self) -> [Field; POINT_LENGTH] {
        self.inner.serialize()
    }
}

// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091
impl Hash for NpkM {
    fn hash(self) -> Field {
        self.inner.hash()
    }
}

pub struct IvpkM {
    pub inner: Point,
}

impl ToPoint for IvpkM {
    fn to_point(self) -> Point {
        self.inner
    }
}

impl Serialize<POINT_LENGTH> for IvpkM {
    fn serialize(self) -> [Field; POINT_LENGTH] {
        self.inner.serialize()
    }
}

pub struct OvpkM {
    pub inner: Point,
}

impl Hash for OvpkM {
    fn hash(self) -> Field {
        self.inner.hash()
    }
}

impl ToPoint for OvpkM {
    fn to_point(self) -> Point {
        self.inner
    }
}

impl Serialize<POINT_LENGTH> for OvpkM {
    fn serialize(self) -> [Field; POINT_LENGTH] {
        self.inner.serialize()
    }
}

pub struct TpkM {
    pub inner: Point,
}

impl ToPoint for TpkM {
    fn to_point(self) -> Point {
        self.inner
    }
}

impl Serialize<POINT_LENGTH> for TpkM {
    fn serialize(self) -> [Field; POINT_LENGTH] {
        self.inner.serialize()
    }
}

impl Default for PublicKeys {
    fn default() -> Self {
        PublicKeys {
            npk_m: NpkM {
                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },
            },
            ivpk_m: IvpkM {
                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },
            },
            ovpk_m: OvpkM {
                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },
            },
            tpk_m: TpkM {
                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },
            },
        }
    }
}

impl Eq for PublicKeys {
    fn eq(self, other: PublicKeys) -> bool {
        (self.npk_m.inner == other.npk_m.inner)
            & (self.ivpk_m.inner == other.ivpk_m.inner)
            & (self.ovpk_m.inner == other.ovpk_m.inner)
            & (self.tpk_m.inner == other.tpk_m.inner)
    }
}

impl PublicKeys {
    pub fn hash(self) -> PublicKeysHash {
        PublicKeysHash::from_field(poseidon2_hash_with_separator(
            self.serialize(),
            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,
        ))
    }
}

impl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {
    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {
        [
            self.npk_m.inner.x,
            self.npk_m.inner.y,
            self.npk_m.inner.is_infinite as Field,
            self.ivpk_m.inner.x,
            self.ivpk_m.inner.y,
            self.ivpk_m.inner.is_infinite as Field,
            self.ovpk_m.inner.x,
            self.ovpk_m.inner.y,
            self.ovpk_m.inner.is_infinite as Field,
            self.tpk_m.inner.x,
            self.tpk_m.inner.y,
            self.tpk_m.inner.is_infinite as Field,
        ]
    }
}

impl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {
    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {
        PublicKeys {
            npk_m: NpkM {
                inner: Point {
                    x: serialized[0],
                    y: serialized[1],
                    is_infinite: serialized[2] as bool,
                },
            },
            ivpk_m: IvpkM {
                inner: Point {
                    x: serialized[3],
                    y: serialized[4],
                    is_infinite: serialized[5] as bool,
                },
            },
            ovpk_m: OvpkM {
                inner: Point {
                    x: serialized[6],
                    y: serialized[7],
                    is_infinite: serialized[8] as bool,
                },
            },
            tpk_m: TpkM {
                inner: Point {
                    x: serialized[9],
                    y: serialized[10],
                    is_infinite: serialized[11] as bool,
                },
            },
        }
    }
}

pub struct AddressPoint {
    pub inner: Point,
}

impl ToPoint for AddressPoint {
    fn to_point(self) -> Point {
        self.inner
    }
}

#[test]
unconstrained fn compute_public_keys_hash() {
    let keys = PublicKeys {
        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },
        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },
        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },
        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },
    };

    let actual = keys.hash();
    let expected_public_keys_hash =
        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;

    assert(actual.to_field() == expected_public_keys_hash);
}

#[test]
unconstrained fn compute_default_hash() {
    let keys = PublicKeys::default();

    let actual = keys.hash();
    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;

    assert(actual.to_field() == test_data_default_hash);
}

#[test]
unconstrained fn test_public_keys_serialization() {
    let keys = PublicKeys {
        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },
        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },
        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },
        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },
    };

    let serialized = keys.serialize();
    let deserialized = PublicKeys::deserialize(serialized);

    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);
    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);
    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);
    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);
    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);
    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);
    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);
    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);
}
`},347:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",source:`use crate::traits::{Deserialize, Serialize};

global BOOL_SERIALIZED_LEN: u32 = 1;
global U8_SERIALIZED_LEN: u32 = 1;
global U16_SERIALIZED_LEN: u32 = 1;
global U32_SERIALIZED_LEN: u32 = 1;
global U64_SERIALIZED_LEN: u32 = 1;
global U128_SERIALIZED_LEN: u32 = 1;
global FIELD_SERIALIZED_LEN: u32 = 1;
global I8_SERIALIZED_LEN: u32 = 1;
global I16_SERIALIZED_LEN: u32 = 1;
global I32_SERIALIZED_LEN: u32 = 1;
global I64_SERIALIZED_LEN: u32 = 1;

impl Serialize<BOOL_SERIALIZED_LEN> for bool {
    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<BOOL_SERIALIZED_LEN> for bool {
    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {
        fields[0] as bool
    }
}

impl Serialize<U8_SERIALIZED_LEN> for u8 {
    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U8_SERIALIZED_LEN> for u8 {
    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {
        fields[0] as u8
    }
}

impl Serialize<U16_SERIALIZED_LEN> for u16 {
    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U16_SERIALIZED_LEN> for u16 {
    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {
        fields[0] as u16
    }
}

impl Serialize<U32_SERIALIZED_LEN> for u32 {
    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U32_SERIALIZED_LEN> for u32 {
    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {
        fields[0] as u32
    }
}

impl Serialize<U64_SERIALIZED_LEN> for u64 {
    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U64_SERIALIZED_LEN> for u64 {
    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {
        fields[0] as u64
    }
}

impl Serialize<U128_SERIALIZED_LEN> for u128 {
    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<U128_SERIALIZED_LEN> for u128 {
    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {
        fields[0] as u128
    }
}

impl Serialize<FIELD_SERIALIZED_LEN> for Field {
    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {
        [self]
    }
}

impl Deserialize<FIELD_SERIALIZED_LEN> for Field {
    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {
        fields[0]
    }
}

impl Serialize<I8_SERIALIZED_LEN> for i8 {
    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<I8_SERIALIZED_LEN> for i8 {
    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {
        fields[0] as i8
    }
}

impl Serialize<I16_SERIALIZED_LEN> for i16 {
    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<I16_SERIALIZED_LEN> for i16 {
    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {
        fields[0] as i16
    }
}

impl Serialize<I32_SERIALIZED_LEN> for i32 {
    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<I32_SERIALIZED_LEN> for i32 {
    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {
        fields[0] as i32
    }
}

impl Serialize<I64_SERIALIZED_LEN> for i64 {
    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {
        [self as Field]
    }
}

impl Deserialize<I64_SERIALIZED_LEN> for i64 {
    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {
        fields[0] as i64
    }
}

impl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]
where
    T: Serialize<M>,
{
    fn serialize(self) -> [Field; N * M] {
        let mut result: [Field; N * M] = std::mem::zeroed();
        let mut serialized: [Field; M] = std::mem::zeroed();
        for i in 0..N {
            serialized = self[i].serialize();
            for j in 0..M {
                result[i * M + j] = serialized[j];
            }
        }
        result
    }
}

impl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]
where
    T: Deserialize<M>,
{
    fn deserialize(fields: [Field; N * M]) -> Self {
        let mut reader = crate::utils::reader::Reader::new(fields);
        let mut result: [T; N] = std::mem::zeroed();
        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)
    }
}

#[test]
fn test_u16_serialization() {
    let a: u16 = 10;
    assert_eq(a, u16::deserialize(a.serialize()));
}

#[test]
fn test_i8_serialization() {
    let a: i8 = -10;
    assert_eq(a, i8::deserialize(a.serialize()));
}

#[test]
fn test_i16_serialization() {
    let a: i16 = -10;
    assert_eq(a, i16::deserialize(a.serialize()));
}

#[test]
fn test_i32_serialization() {
    let a: i32 = -10;
    assert_eq(a, i32::deserialize(a.serialize()));
}

#[test]
fn test_i64_serialization() {
    let a: i64 = -10;
    assert_eq(a, i64::deserialize(a.serialize()));
}
`},363:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",source:`pub mod assert_array_appended;
pub mod assert_array_prepended;
pub mod assert_combined_array;
pub mod assert_combined_transformed_array;
pub mod assert_exposed_sorted_transformed_value_array;
pub mod assert_sorted_array;
pub mod assert_sorted_transformed_value_array;
pub mod assert_split_sorted_transformed_value_arrays;
pub mod assert_split_transformed_value_arrays;
pub mod get_sorted_result;
pub mod get_sorted_tuple;
pub mod sort_by;
pub mod sort_by_counter;

// Re-exports.
pub use assert_array_appended::{
    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,
    assert_array_appended_scoped,
};
pub use assert_array_prepended::assert_array_prepended;
pub use assert_combined_array::{assert_combined_array, combine_arrays};
pub use assert_combined_transformed_array::{
    assert_combined_transformed_array, combine_and_transform_arrays,
};
pub use assert_exposed_sorted_transformed_value_array::{
    assert_exposed_sorted_transformed_value_array,
    get_order_hints::{get_order_hints_asc, OrderHint},
};
pub use assert_sorted_array::assert_sorted_array;
pub use assert_sorted_transformed_value_array::{
    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,
};
pub use assert_split_sorted_transformed_value_arrays::{
    assert_split_sorted_transformed_value_arrays_asc,
    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},
};
pub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;
pub use get_sorted_result::{get_sorted_result, SortedResult};
pub use sort_by_counter::sort_by_counter_asc;

use crate::traits::{Empty, is_empty};

pub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(
    src: [Field; SRC_LEN],
    offset: u32,
) -> [Field; DST_LEN] {
    assert(offset + DST_LEN <= SRC_LEN, "offset too large");

    let mut dst: [Field; DST_LEN] = std::mem::zeroed();
    for i in 0..DST_LEN {
        dst[i] = src[i + offset];
    }

    dst
}

// Helper function to convert a validated array to BoundedVec.
// Important: Only use it for validated arrays: validate_array(array) should be true.
pub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>
where
    T: Empty + Eq,
{
    let len = array_length(array);
    BoundedVec::from_parts_unchecked(array, len)
}

// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element
// is not found, the function returns N as the index.
pub unconstrained fn find_index_hint<T, let N: u32, Env>(
    array: [T; N],
    find: fn[Env](T) -> bool,
) -> u32 {
    let mut index = N;
    for i in 0..N {
        // We check \`index == N\` to ensure that we only update the index if we haven't found a match yet.
        if (index == N) & find(array[i]) {
            index = i;
        }
    }
    index
}

// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,
// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is
// valid.
pub fn validate_array<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    let mut seen_empty = false;
    let mut length = 0;
    for i in 0..N {
        if is_empty(array[i]) {
            seen_empty = true;
        } else {
            assert(seen_empty == false, "invalid array");
            length += 1;
        }
    }
    length
}

// Helper function to count the number of non-empty elements in a validated array.
// Important: Only use it for validated arrays where validate_array(array) returns true,
// which ensures that:
// 1. All elements before the first empty element are non-empty
// 2. All elements after and including the first empty element are empty
// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements
pub fn array_length<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    // We get the length by checking the index of the first empty element.

    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness
    // of the element and non-emptiness of the previous element is checked below.
    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };
    if length != 0 {
        assert(!is_empty(array[length - 1]));
    }
    if length != N {
        assert(is_empty(array[length]));
    }
    length
}

// Returns the number of consecutive elements at the start of the array for which the predicate returns false.
// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.
pub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {
    let mut length = 0;
    let mut stop = false;
    for i in 0..N {
        if predicate(array[i]) {
            stop = true;
        } else {
            assert(
                stop == false,
                "matching element found after already encountering a non-matching element",
            );
            length += 1;
        }
    }
    length
}

pub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {
    let mut result = [array1[0]; N + M];
    for i in 1..N {
        result[i] = array1[i];
    }
    for i in 0..M {
        result[i + N] = array2[i];
    }
    result
}

/// This function assumes that \`array1\` and \`array2\` contain no more than N non-empty elements between them,
/// if this is not the case then elements from the end of \`array2\` will be dropped.
pub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]
where
    T: Empty + Eq,
{
    // Safety: we constrain this array below
    let result = unsafe { array_merge_helper(array1, array2) };
    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.
    let array1_len = array_length(array1);
    let mut add_from_left = true;
    for i in 0..N {
        add_from_left &= i != array1_len;
        if add_from_left {
            assert_eq(result[i], array1[i]);
        } else {
            assert_eq(result[i], array2[i - array1_len]);
        }
    }
    result
}

unconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]
where
    T: Empty + Eq,
{
    let mut result: [T; N] = [T::empty(); N];
    let mut i = 0;
    for elem in array1 {
        if !is_empty(elem) {
            result[i] = elem;
            i += 1;
        }
    }
    for elem in array2 {
        if !is_empty(elem) {
            result[i] = elem;
            i += 1;
        }
    }
    result
}

// Helper fn to create a subarray from a given array
pub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]
where
    T: Empty,
{
    assert(M + offset <= N, "Subarray length larger than array length");
    let mut result: [T; M] = [T::empty(); M];
    for i in 0..M {
        result[i] = array[offset + i];
    }
    result
}

pub fn check_permutation<T, let N: u32>(
    original_array: [T; N],
    permuted_array: [T; N],
    original_indexes: [u32; N],
)
where
    T: Eq + Empty,
{
    let mut seen_value = [false; N];
    for i in 0..N {
        let index = original_indexes[i];
        let original_value = original_array[index];
        assert(permuted_array[i].eq(original_value), "Invalid index");
        assert(!seen_value[index], "Duplicated index");
        seen_value[index] = true;
    }
}

// Helper function to find the index of the last element in an array, allowing empty elements.
// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]
// Nothing to do with validated arrays. Correctness constrained by padded_array_length.
pub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    let mut index = N;
    for i in 0..N {
        let j = N - i - 1;
        // We check \`index == N\` to ensure that we only update the index if we haven't found a match yet.
        if (index == N) & !is_empty(array[j]) {
            index = j;
        }
    }
    index
}

// Routine which returns the length of an array right padded by empty elements
// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).
// See smoke_validate_array_trailing for examples.
// Nothing to do with validated arrays. Correctness constrained by padded_array_length.
pub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    let index = find_last_value_index(array);
    if index == N {
        0
    } else {
        index + 1
    }
}

// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,
// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).
pub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32
where
    T: Empty + Eq,
{
    // Safety: this value is constrained in the below loop.
    let length = unsafe { unsafe_padded_array_length(array) };
    // Check the elt just before length is non-zero:
    if length != 0 {
        assert(!is_empty(array[length - 1]), "invalid right padded array");
    }
    // Check all beyond length are zero:
    let mut check_zero = false;
    for i in 0..N {
        check_zero |= i == length;
        if check_zero {
            assert(is_empty(array[i]), "invalid right padded array");
        }
    }
    length
}

// Helper function to check if an array is padded with a given value from a given index.
// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.
pub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool
where
    T: Eq,
{
    let mut is_valid = true;
    let mut should_check = false;
    for i in 0..N {
        should_check |= i == from_index;
        is_valid &= !should_check | (array[i] == padded_with);
    }
    is_valid
}

#[test]
fn smoke_validate_array() {
    let valid_array: [Field; 0] = [];
    assert(validate_array(valid_array) == 0);

    let valid_array = [0];
    assert(validate_array(valid_array) == 0);

    let valid_array = [3];
    assert(validate_array(valid_array) == 1);

    let valid_array = [1, 2, 3];
    assert(validate_array(valid_array) == 3);

    let valid_array = [1, 2, 3, 0];
    assert(validate_array(valid_array) == 3);

    let valid_array = [1, 2, 3, 0, 0];
    assert(validate_array(valid_array) == 3);
}

#[test]
fn smoke_validate_array_trailing() {
    let valid_array: [Field; 0] = [];
    assert(padded_array_length(valid_array) == 0);

    let valid_array = [0];
    assert(padded_array_length(valid_array) == 0);

    let valid_array = [3];
    assert(padded_array_length(valid_array) == 1);

    let valid_array = [1, 0, 3];
    assert(padded_array_length(valid_array) == 3);

    let valid_array = [1, 0, 3, 0];
    assert(padded_array_length(valid_array) == 3);

    let valid_array = [1, 2, 3, 0, 0];
    assert(padded_array_length(valid_array) == 3);

    let valid_array = [0, 0, 3, 0, 0];
    assert(padded_array_length(valid_array) == 3);
}

#[test(should_fail_with = "invalid array")]
fn smoke_validate_array_invalid_case0() {
    let invalid_array = [0, 1];
    let _ = validate_array(invalid_array);
}

#[test(should_fail_with = "invalid array")]
fn smoke_validate_array_invalid_case1() {
    let invalid_array = [1, 0, 0, 1, 0];
    let _ = validate_array(invalid_array);
}

#[test(should_fail_with = "invalid array")]
fn smoke_validate_array_invalid_case2() {
    let invalid_array = [0, 0, 0, 0, 1];
    let _ = validate_array(invalid_array);
}

#[test]
fn test_empty_array_length() {
    assert_eq(array_length([0]), 0);
    assert_eq(array_length([0, 0, 0]), 0);
}

#[test]
fn test_array_length() {
    assert_eq(array_length([123]), 1);
    assert_eq(array_length([123, 0, 0]), 1);
    assert_eq(array_length([123, 456]), 2);
    assert_eq(array_length([123, 456, 0]), 2);
}

#[test]
fn test_array_length_invalid_arrays() {
    // Result can be misleading (but correct) for invalid arrays.
    assert_eq(array_length([0, 0, 123]), 0);
    assert_eq(array_length([0, 123, 0]), 0);
    assert_eq(array_length([0, 123, 456]), 0);
    assert_eq(array_length([123, 0, 456]), 1);
}

#[test]
fn test_array_length_until() {
    let array = [11, 22, 33, 44, 55];
    assert_eq(array_length_until(array, |x| x == 55), 4);
    assert_eq(array_length_until(array, |x| x == 56), 5);
    assert_eq(array_length_until(array, |x| x > 40), 3);
    assert_eq(array_length_until(array, |x| x > 10), 0);
}

#[test(should_fail_with = "matching element found after already encountering a non-matching element")]
fn test_array_length_until_non_consecutive_fails() {
    let array = [1, 1, 0, 1, 0];
    let _ = array_length_until(array, |x| x == 0);
}

#[test(should_fail_with = "matching element found after already encountering a non-matching element")]
fn test_array_length_until_first_non_matching_fails() {
    let array = [1, 0, 0, 0, 0];
    let _ = array_length_until(array, |x| x == 1);
}

#[test]
unconstrained fn find_index_greater_than_min() {
    let values = [10, 20, 30, 40];
    let min = 22;
    let index = find_index_hint(values, |v: Field| min.lt(v));
    assert_eq(index, 2);
}

#[test]
unconstrained fn find_index_not_found() {
    let values = [10, 20, 30, 40];
    let min = 100;
    let index = find_index_hint(values, |v: Field| min.lt(v));
    assert_eq(index, 4);
}

#[test]
fn test_array_concat() {
    let array0 = [1, 2, 3];
    let array1 = [4, 5];
    let concatenated = array_concat(array0, array1);
    assert_eq(concatenated, [1, 2, 3, 4, 5]);
}

#[test]
fn check_permutation_basic_test() {
    let original_array = [1, 2, 3];
    let permuted_array = [3, 1, 2];
    let indexes = [2, 0, 1];
    check_permutation(original_array, permuted_array, indexes);
}

#[test(should_fail_with = "Duplicated index")]
fn check_permutation_duplicated_index() {
    let original_array = [0, 1, 0];
    let permuted_array = [1, 0, 0];
    let indexes = [1, 0, 0];
    check_permutation(original_array, permuted_array, indexes);
}

#[test(should_fail_with = "Invalid index")]
fn check_permutation_invalid_index() {
    let original_array = [0, 1, 2];
    let permuted_array = [1, 0, 0];
    let indexes = [1, 0, 2];
    check_permutation(original_array, permuted_array, indexes);
}

#[test]
fn test_array_padded_with() {
    let array = [11, 22, 33, 44, 44];
    assert_eq(array_padded_with(array, 0, 44), false);
    assert_eq(array_padded_with(array, 1, 44), false);
    assert_eq(array_padded_with(array, 2, 44), false);
    assert_eq(array_padded_with(array, 3, 44), true);
    assert_eq(array_padded_with(array, 4, 44), true);
    assert_eq(array_padded_with(array, 4, 33), false);
    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.
    assert_eq(array_padded_with(array, 0, 11), false);
}
`},364:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",source:`pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {
    assert(bytes.len() < 32, "field_from_bytes: N must be less than 32");
    let mut as_field = 0;
    let mut offset = 1;
    for i in 0..N {
        let mut index = i;
        if big_endian {
            index = N - i - 1;
        }
        as_field += (bytes[index] as Field) * offset;
        offset *= 256;
    }

    as_field
}

// Convert a 32 byte array to a field element by truncating the final byte
pub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {
    // Convert it to a field element
    let mut v = 1;
    let mut high = 0 as Field;
    let mut low = 0 as Field;

    for i in 0..15 {
        // covers bytes 16..30 (31 is truncated and ignored)
        low = low + (bytes32[15 + 15 - i] as Field) * v;
        v = v * 256;
        // covers bytes 0..14
        high = high + (bytes32[14 - i] as Field) * v;
    }
    // covers byte 15
    low = low + (bytes32[15] as Field) * v;

    low + high * v
}

// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports
pub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {
    lhs.lt(rhs)
}

pub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {
    rhs.lt(lhs)
}

pub fn min(f1: Field, f2: Field) -> Field {
    if f1.lt(f2) {
        f1
    } else {
        f2
    }
}

global C1: u32 = 28;
global C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;
global C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;

pub(crate) fn pow(x: Field, y: Field) -> Field {
    let mut r = 1 as Field;
    let b: [u1; 254] = y.to_le_bits();

    for i in 0..254 {
        r *= r;
        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);
    }

    r
}

// Tonelli-Shanks algorithm for computing the square root of a Field element.
// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field
// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),
// and C5 = ZETA^C2, where ZETA is a non-square element of Field.
// These are pre-computed above as globals.
pub(crate) fn sqrt(x: Field) -> Field {
    let mut z = pow(x, C3);
    let mut t = z * z * x;
    z *= x;
    let mut b = t;
    let mut c = C5;

    for i in 0..(C1 - 1) {
        for _j in 1..(C1 - i - 1) {
            b *= b;
        }

        z *= if b == 1 { 1 } else { c };

        c *= c;

        t *= if b == 1 { 1 } else { c };

        b = t;
    }

    z
}

#[test]
unconstrained fn bytes_field_test() {
    // Tests correctness of field_from_bytes_32_trunc against existing methods
    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7
    let inputs = [
        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,
        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,
    ];
    let field = field_from_bytes(inputs, true);
    let return_bytes: [u8; 31] = field.to_be_bytes();
    assert_eq(inputs, return_bytes);
    // 32 bytes - we remove the final byte, and check it matches the field
    let inputs2 = [
        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,
        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,
    ];
    let field2 = field_from_bytes_32_trunc(inputs2);
    let return_bytes2: [u8; 31] = field.to_be_bytes();

    assert_eq(return_bytes2, return_bytes);
    assert_eq(field2, field);
}

#[test]
unconstrained fn max_field_test() {
    // Tests the hardcoded value in constants.nr vs underlying modulus
    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files
    let max_value = crate::constants::MAX_FIELD_VALUE;
    assert_eq(max_value, 0 - 1);
    // modulus == 0 is tested elsewhere, so below is more of a sanity check
    let max_bytes: [u8; 32] = max_value.to_be_bytes();
    let mod_bytes = std::field::modulus_be_bytes();
    for i in 0..31 {
        assert_eq(max_bytes[i], mod_bytes[i]);
    }
    assert_eq(max_bytes[31], mod_bytes[31] - 1);
}
`},366:{path:"/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",source:`pub struct Reader<let N: u32> {
    data: [Field; N],
    offset: u32,
}

impl<let N: u32> Reader<N> {
    pub fn new(data: [Field; N]) -> Self {
        Self { data, offset: 0 }
    }

    pub fn read(&mut self) -> Field {
        let result = self.data[self.offset];
        self.offset += 1;
        result
    }

    pub fn read_u32(&mut self) -> u32 {
        self.read() as u32
    }

    pub fn read_bool(&mut self) -> bool {
        self.read() as bool
    }

    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {
        let mut result = [0; K];
        for i in 0..K {
            result[i] = self.data[self.offset + i];
        }
        self.offset += K;
        result
    }

    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {
        let result = deserialise(self.read_array());
        result
    }

    pub fn read_struct_array<T, let K: u32, let C: u32>(
        &mut self,
        deserialise: fn([Field; K]) -> T,
        mut result: [T; C],
    ) -> [T; C] {
        for i in 0..C {
            result[i] = self.read_struct(deserialise);
        }
        result
    }

    pub fn finish(self) {
        assert(self.offset == self.data.len(), "Reader did not read all data");
    }
}
`},376:{path:"/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",source:`use std::hash::sha256_compression;
use std::runtime::is_unconstrained;

use constants::{
    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,
    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,
};

mod constants;
mod tests;

// Implementation of SHA-256 mapping a byte array of variable length to
// 32 bytes.

// Deprecated in favour of \`sha256_var\`
// docs:start:sha256
pub fn sha256<let N: u32>(input: [u8; N]) -> HASH
// docs:end:sha256
{
    digest(input)
}

// SHA-256 hash function
#[no_predicates]
pub fn digest<let N: u32>(msg: [u8; N]) -> HASH {
    sha256_var(msg, N as u64)
}

// Variable size SHA-256 hash
pub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {
    let message_size = message_size as u32;
    assert(message_size <= N);

    if std::runtime::is_unconstrained() {
        // Safety: SHA256 is running as an unconstrained function.
        unsafe {
            __sha256_var(msg, message_size)
        }
    } else {
        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];
        // Intermediate hash, starting with the canonical initial value
        let mut h: STATE = INITIAL_STATE;
        // Pointer into msg_block on a 64 byte scale
        let mut msg_byte_ptr = 0;
        let num_blocks = N / BLOCK_SIZE;
        for i in 0..num_blocks {
            let msg_start = BLOCK_SIZE * i;
            let (new_msg_block, new_msg_byte_ptr) =
                unsafe { build_msg_block(msg, message_size, msg_start) };

            if msg_start < message_size {
                msg_block = new_msg_block;
            }

            // Verify the block we are compressing was appropriately constructed
            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);
            if msg_start < message_size {
                msg_byte_ptr = new_msg_byte_ptr;
            }

            // If the block is filled, compress it.
            // An un-filled block is handled after this loop.
            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {
                h = sha256_compression(msg_block, h);
            }
        }

        let modulo = N % BLOCK_SIZE;
        // Handle setup of the final msg block.
        // This case is only hit if the msg is less than the block size,
        // or our message cannot be evenly split into blocks.
        if modulo != 0 {
            let msg_start = BLOCK_SIZE * num_blocks;
            let (new_msg_block, new_msg_byte_ptr) =
                unsafe { build_msg_block(msg, message_size, msg_start) };

            if msg_start < message_size {
                msg_block = new_msg_block;
            }

            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);
            if msg_start < message_size {
                msg_byte_ptr = new_msg_byte_ptr;
                verify_msg_block_padding(msg_block, msg_byte_ptr);
            }
        }

        // If we had modulo == 0 then it means the last block was full,
        // and we can reset the pointer to zero to overwrite it.
        if msg_byte_ptr == BLOCK_SIZE {
            msg_byte_ptr = 0;
        }

        // Pad the rest such that we have a [u32; 2] block at the end representing the length
        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).
        // Here we rely on the fact that everything beyond the available input is set to 0.
        let index = msg_byte_ptr / INT_SIZE;
        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);

        msg_byte_ptr = msg_byte_ptr + 1;
        let last_block = msg_block;

        // If we don't have room to write the size, compress the block and reset it.
        if msg_byte_ptr > MSG_SIZE_PTR {
            h = sha256_compression(msg_block, h);
            // \`attach_len_to_msg_block\` will zero out everything after the \`msg_byte_ptr\`.
            msg_byte_ptr = 0;
        }

        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };

        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);

        hash_final_block(msg_block, h)
    }
}

// Variable size SHA-256 hash
unconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {
    let num_full_blocks = message_size / BLOCK_SIZE;
    // Intermediate hash, starting with the canonical initial value
    let mut h: STATE = INITIAL_STATE;
    // Pointer into msg_block on a 64 byte scale
    for i in 0..num_full_blocks {
        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);
        h = sha256_compression(msg_block, h);
    }

    // Handle setup of the final msg block.
    // This case is only hit if the msg is less than the block size,
    // or our message cannot be evenly split into blocks.
    let modulo = message_size % BLOCK_SIZE;
    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {
        let msg_start = BLOCK_SIZE * num_full_blocks;
        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);

        (new_msg_block, new_msg_byte_ptr)
    } else {
        // If we had modulo == 0 then it means the last block was full,
        // and we can reset the pointer to zero to overwrite it.
        ([0; INT_BLOCK_SIZE], 0)
    };

    // Pad the rest such that we have a [u32; 2] block at the end representing the length
    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).
    // Here we rely on the fact that everything beyond the available input is set to 0.
    let index = msg_byte_ptr / INT_SIZE;
    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);

    // If we don't have room to write the size, compress the block and reset it.
    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {
        // \`attach_len_to_msg_block\` will zero out everything after the \`msg_byte_ptr\`.
        (sha256_compression(msg_block, h), 0)
    } else {
        (h, msg_byte_ptr + 1)
    };
    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);

    hash_final_block(msg_block, h)
}

// Take \`BLOCK_SIZE\` number of bytes from \`msg\` starting at \`msg_start\`.
// Returns the block and the length that has been copied rather than padded with zeros.
unconstrained fn build_msg_block<let N: u32>(
    msg: [u8; N],
    message_size: u32,
    msg_start: u32,
) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {
    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];

    // We insert \`BLOCK_SIZE\` bytes (or up to the end of the message)
    let block_input = if message_size < msg_start {
        // This function is sometimes called with \`msg_start\` past the end of the message.
        // In this case we return an empty block and zero pointer to signal that the result should be ignored.
        0
    } else if message_size < msg_start + BLOCK_SIZE {
        message_size - msg_start
    } else {
        BLOCK_SIZE
    };

    // Figure out the number of items in the int array that we have to pack.
    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]
    let mut int_input = block_input / INT_SIZE;
    if block_input % INT_SIZE != 0 {
        int_input = int_input + 1;
    };

    for i in 0..int_input {
        let mut msg_item: u32 = 0;
        // Always construct the integer as 4 bytes, even if it means going beyond the input.
        for j in 0..INT_SIZE {
            let k = i * INT_SIZE + j;
            let msg_byte = if k < block_input {
                msg[msg_start + k]
            } else {
                0
            };
            msg_item = lshift8(msg_item, 1) + msg_byte as u32;
        }
        msg_block[i] = msg_item;
    }

    // Returning the index as if it was a 64 byte array.
    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.
    (msg_block, block_input)
}

// Verify the block we are compressing was appropriately constructed by \`build_msg_block\`
// and matches the input data. Returns the index of the first unset item.
// If \`message_size\` is less than \`msg_start\` then this is called with the old non-empty block;
// in that case we can skip verification, ie. no need to check that everything is zero.
fn verify_msg_block<let N: u32>(
    msg: [u8; N],
    message_size: u32,
    msg_block: MSG_BLOCK,
    msg_start: u32,
) -> BLOCK_BYTE_PTR {
    let mut msg_byte_ptr = 0;
    let mut msg_end = msg_start + BLOCK_SIZE;
    if msg_end > N {
        msg_end = N;
    }
    // We might have to go beyond the input to pad the fields.
    if msg_end % INT_SIZE != 0 {
        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;
    }

    // Reconstructed packed item.
    let mut msg_item: u32 = 0;

    // Inclusive at the end so that we can compare the last item.
    let mut i: u32 = 0;
    for k in msg_start..=msg_end {
        if k % INT_SIZE == 0 {
            // If we consumed some input we can compare against the block.
            if (msg_start < message_size) & (k > msg_start) {
                assert_eq(msg_block[i], msg_item as u32);
                i = i + 1;
                msg_item = 0;
            }
        }
        // Shift the accumulator
        msg_item = lshift8(msg_item, 1);
        // If we have input to consume, add it at the rightmost position.
        if k < message_size & k < msg_end {
            msg_item = msg_item + msg[k] as u32;
            msg_byte_ptr = msg_byte_ptr + 1;
        }
    }

    msg_byte_ptr
}

// Verify the block we are compressing was appropriately padded with zeros by \`build_msg_block\`.
// This is only relevant for the last, potentially partially filled block.
fn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {
    // Check all the way to the end of the block.
    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);
}

// Verify that a region of ints in the message block are (partially) zeroed,
// up to an (exclusive) maximum which can either be the end of the block
// or just where the size is to be written.
fn verify_msg_block_zeros(
    msg_block: MSG_BLOCK,
    mut msg_byte_ptr: BLOCK_BYTE_PTR,
    max_int_byte_ptr: u32,
) {
    // This variable is used to get around the compiler under-constrained check giving a warning.
    // We want to check against a constant zero, but if it does not come from the circuit inputs
    // or return values the compiler check will issue a warning.
    let zero = msg_block[0] - msg_block[0];

    // First integer which is supposed to be (partially) zero.
    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;

    // Check partial zeros.
    let modulo = msg_byte_ptr % INT_SIZE;
    if modulo != 0 {
        let zeros = INT_SIZE - modulo;
        let mask = if zeros == 3 {
            TWO_POW_24
        } else if zeros == 2 {
            TWO_POW_16
        } else {
            TWO_POW_8
        };
        assert_eq(msg_block[int_byte_ptr] % mask, zero);
        int_byte_ptr = int_byte_ptr + 1;
    }

    // Check the rest of the items.
    for i in 0..max_int_byte_ptr {
        if i >= int_byte_ptr {
            assert_eq(msg_block[i], zero);
        }
    }
}

// Verify that up to the byte pointer the two blocks are equal.
// At the byte pointer the new block can be partially zeroed.
fn verify_msg_block_equals_last(
    msg_block: MSG_BLOCK,
    last_block: MSG_BLOCK,
    mut msg_byte_ptr: BLOCK_BYTE_PTR,
) {
    // msg_byte_ptr is the position at which they are no longer have to be the same.
    // First integer which is supposed to be (partially) zero contains that pointer.
    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;

    // Check partial zeros.
    let modulo = msg_byte_ptr % INT_SIZE;
    if modulo != 0 {
        // Reconstruct the partially zero item from the last block.
        let last_field = last_block[int_byte_ptr];
        let mut msg_item: u32 = 0;
        // Reset to where they are still equal.
        msg_byte_ptr = msg_byte_ptr - modulo;
        for i in 0..INT_SIZE {
            msg_item = lshift8(msg_item, 1);
            if i < modulo {
                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;
                msg_byte_ptr = msg_byte_ptr + 1;
            }
        }
        assert_eq(msg_block[int_byte_ptr], msg_item);
    }

    for i in 0..INT_SIZE_PTR {
        if i < int_byte_ptr {
            assert_eq(msg_block[i], last_block[i]);
        }
    }
}

// Set the rightmost \`zeros\` number of bytes to 0.
#[inline_always]
fn set_item_zeros(item: u32, zeros: u8) -> u32 {
    lshift8(rshift8(item, zeros), zeros)
}

// Replace one byte in the item with a value, and set everything after it to zero.
fn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {
    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;
    let zeroed_item = set_item_zeros(msg_item, zeros as u8);
    let new_item = byte_into_item(msg_byte, msg_byte_ptr);
    zeroed_item + new_item
}

// Get a byte of a message item according to its overall position in the \`BLOCK_SIZE\` space.
fn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {
    // How many times do we have to shift to the right to get to the position we want?
    let max_shifts = INT_SIZE - 1;
    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;
    msg_item = rshift8(msg_item, shifts as u8);
    // At this point the byte we want is in the rightmost position.
    msg_item as u8
}

// Project a byte into a position in a field based on the overall block pointer.
// For example putting 1 into pointer 5 would be 100, because overall we would
// have [____, 0100] with indexes [0123,4567].
#[inline_always]
fn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {
    let mut msg_item = msg_byte as u32;
    // How many times do we have to shift to the left to get to the position we want?
    let max_shifts = INT_SIZE - 1;
    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;
    lshift8(msg_item, shifts as u8)
}

// Construct a field out of 4 bytes.
#[inline_always]
fn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {
    let mut item = b0 as u32;
    item = lshift8(item, 1) + b1 as u32;
    item = lshift8(item, 1) + b2 as u32;
    item = lshift8(item, 1) + b3 as u32;
    item
}

// Shift by 8 bits to the left between 0 and 4 times.
// Checks \`is_unconstrained()\` to just use a bitshift if we're running in an unconstrained context,
// otherwise multiplies by 256.
#[inline_always]
fn lshift8(item: u32, shifts: u8) -> u32 {
    if is_unconstrained() {
        // Brillig wouldn't shift 0<<4 without overflow.
        if shifts >= 4 {
            0
        } else {
            item << (8 * shifts)
        }
    } else {
        // We can do a for loop up to INT_SIZE or an if-else.
        if shifts == 0 {
            item
        } else if shifts == 1 {
            item * TWO_POW_8
        } else if shifts == 2 {
            item * TWO_POW_16
        } else if shifts == 3 {
            item * TWO_POW_24
        } else {
            // Doesn't make sense, but it's most likely called on 0 anyway.
            0
        }
    }
}

// Shift by 8 bits to the right between 0 and 4 times.
// Checks \`is_unconstrained()\` to just use a bitshift if we're running in an unconstrained context,
// otherwise divides by 256.
fn rshift8(item: u32, shifts: u8) -> u32 {
    if is_unconstrained() {
        item >> (8 * shifts)
    } else {
        // Division wouldn't work on \`Field\`.
        if shifts == 0 {
            item
        } else if shifts == 1 {
            item / TWO_POW_8
        } else if shifts == 2 {
            item / TWO_POW_16
        } else if shifts == 3 {
            item / TWO_POW_24
        } else {
            0
        }
    }
}

// Zero out all bytes between the end of the message and where the length is appended,
// then write the length into the last 8 bytes of the block.
unconstrained fn attach_len_to_msg_block(
    mut msg_block: MSG_BLOCK,
    mut msg_byte_ptr: BLOCK_BYTE_PTR,
    message_size: u32,
) -> MSG_BLOCK {
    // We assume that \`msg_byte_ptr\` is less than 57 because if not then it is reset to zero before calling this function.
    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).
    // There can be one item which has to be partially zeroed.
    let modulo = msg_byte_ptr % INT_SIZE;
    if modulo != 0 {
        // Index of the block in which we find the item we need to partially zero.
        let i = msg_byte_ptr / INT_SIZE;
        let zeros = INT_SIZE - modulo;
        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);
        msg_byte_ptr = msg_byte_ptr + zeros;
    }

    // The rest can be zeroed without bit shifting anything.
    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {
        msg_block[i] = 0;
    }

    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.
    let len = 8 * message_size;
    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();
    for i in 0..=1 {
        let shift = i * 4;
        msg_block[INT_SIZE_PTR + i] = make_item(
            len_bytes[shift],
            len_bytes[shift + 1],
            len_bytes[shift + 2],
            len_bytes[shift + 3],
        );
    }
    msg_block
}

// Verify that the message length was correctly written by \`attach_len_to_msg_block\`,
// and that everything between the byte pointer and the size pointer was zeroed,
// and that everything before the byte pointer was untouched.
fn verify_msg_len(
    msg_block: MSG_BLOCK,
    last_block: MSG_BLOCK,
    msg_byte_ptr: BLOCK_BYTE_PTR,
    message_size: u32,
) {
    // Check zeros up to the size pointer.
    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);

    // Check that up to the pointer we match the last block.
    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);

    // We verify the message length was inserted correctly by reversing the byte decomposition.
    let mut reconstructed_len: u64 = 0;
    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {
        reconstructed_len = reconstructed_len * TWO_POW_32;
        reconstructed_len = reconstructed_len + msg_block[i] as u64;
    }
    let len = 8 * message_size as u64;
    assert_eq(reconstructed_len, len);
}

// Perform the final compression, then transform the \`STATE\` into \`HASH\`.
fn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {
    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes
    // Hash final padded block
    state = sha256_compression(msg_block, state);

    // Return final hash as byte array
    for j in 0..8 {
        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();
        for k in 0..4 {
            out_h[4 * j + k] = h_bytes[k];
        }
    }

    out_h
}

mod equivalence_test {

    #[test]
    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {
        let message_size = message_size % 100;
        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };
        let sha = super::sha256_var(msg, message_size);
        assert_eq(sha, unconstrained_sha);
    }
}
`},377:{path:"/home/aztec-dev/nargo/github.com/noir-lang/schnorr/v0.1.2/src/lib.nr",source:`use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};
use std::hash::{blake2s, pedersen_hash};

// the multiples of BN_P that are still less than 2^254 split into (lo, hi)
global BN_P_m: [(Field, Field); 6] = [
    (0, 0),
    (201385395114098847380338600778089168199, 64323764613183177041862057485226039389),
    (62488423307259231297302594124410124942, 128647529226366354083724114970452078779),
    (263873818421358078677641194902499293141, 192971293839549531125586172455678118168),
    (124976846614518462594605188248820249884, 257295058452732708167448229940904157558),
    (326362241728617309974943789026909418083, 321618823065915885209310287426130196947),
];

global TWO_POW_128: Field = 0x100000000000000000000000000000000;

pub fn verify_signature<let N: u32>(
    public_key: EmbeddedCurvePoint,
    signature: [u8; 64],
    message: [u8; N],
) -> bool {
    //scalar lo/hi from bytes
    let sig_s = scalar_from_bytes(signature, 0);
    let sig_e = scalar_from_bytes(signature, 32);
    // pub_key is on Grumpkin curve
    let mut is_ok = (public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17)
        & (!public_key.is_infinite);

    if ((sig_s.lo != 0) | (sig_s.hi != 0)) & ((sig_e.lo != 0) | (sig_e.hi != 0)) {
        let (r_is_infinite, result) =
            calculate_signature_challenge(public_key, sig_s, sig_e, message);

        is_ok &= !r_is_infinite;
        for i in 0..32 {
            is_ok &= result[i] == signature[32 + i];
        }
    } else {
        is_ok = false;
    }
    is_ok
}

pub fn assert_valid_signature<let N: u32>(
    public_key: EmbeddedCurvePoint,
    signature: [u8; 64],
    message: [u8; N],
) {
    //scalar lo/hi from bytes
    let sig_s = scalar_from_bytes(signature, 0);
    let sig_e = scalar_from_bytes(signature, 32);

    // assert pub_key is on Grumpkin curve
    assert(public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17);
    assert(public_key.is_infinite == false);
    // assert signature is not null
    assert((sig_s.lo != 0) | (sig_s.hi != 0));
    assert((sig_e.lo != 0) | (sig_e.hi != 0));

    let (r_is_infinite, result) = calculate_signature_challenge(public_key, sig_s, sig_e, message);

    assert(!r_is_infinite);
    for i in 0..32 {
        assert(result[i] == signature[32 + i]);
    }
}

fn calculate_signature_challenge<let N: u32>(
    public_key: EmbeddedCurvePoint,
    sig_s: EmbeddedCurveScalar,
    sig_e: EmbeddedCurveScalar,
    message: [u8; N],
) -> (bool, [u8; 32]) {
    let g1 = EmbeddedCurvePoint {
        x: 1,
        y: 17631683881184975370165255887551781615748388533673675138860,
        is_infinite: false,
    };
    let reduced_sig_e = normalize_signature(sig_e);
    let r = multi_scalar_mul([g1, public_key], [sig_s, reduced_sig_e]);
    // compare the _hashes_ rather than field elements modulo r
    let pedersen_hash = pedersen_hash([r.x, public_key.x, public_key.y]);
    let pde: [u8; 32] = pedersen_hash.to_be_bytes();

    let mut hash_input = [0; N + 32];
    for i in 0..32 {
        hash_input[i] = pde[i];
    }
    for i in 0..N {
        hash_input[32 + i] = message[i];
    }

    let result = blake2s(hash_input);
    (r.is_infinite, result)
}

unconstrained fn __gt(a: Field, b: Field) -> bool {
    b.lt(a)
}

// gets the quotient of lo/hi when divided by BN254_Fq modulus
unconstrained fn __get_quotient(hi: Field, lo: Field) -> Field {
    let mut q: Field = 0;
    let mut r_hi = hi;
    let mut r_lo = lo;
    let MODULUS = BN_P_m[1];

    for _ in 1..6 {
        // check if rhi, rlo is larger than BN_P
        let borrow = r_lo.lt(MODULUS.0);

        if borrow {
            r_lo = r_lo + TWO_POW_128;
            // rlo is always larger than BN_P lo now
            r_hi = r_hi - 1;
        }

        let MODULUS_hi = MODULUS.1;

        let gt_flag = !r_hi.lt(MODULUS_hi);

        if gt_flag {
            r_hi = r_hi - MODULUS.1;
            r_lo = r_lo - MODULUS.0;
            if TWO_POW_128.lt(r_lo) | TWO_POW_128.lt(r_hi) {
                break;
            }
            q += 1;
        }
    }
    q
}

// this method reduces the signature to the range [0, BN254_Fq_MODULUS)
fn normalize_signature(sig_e: EmbeddedCurveScalar) -> EmbeddedCurveScalar {
    let mut hi = sig_e.hi;
    let mut lo = sig_e.lo;
    // get the quotient
    let q = unsafe { __get_quotient(hi, lo) };
    let MODULUSmq = (BN_P_m[q].0, BN_P_m[q].1);
    let MODULUS = BN_P_m[1];
    // remove MODULUS * q from lo/hi
    let borrow = unsafe { __gt(MODULUSmq.0, lo) };
    // rlo, rhi is the signature without the multiple of MODULUS
    let rlo = lo - MODULUSmq.0 + borrow as Field * TWO_POW_128;
    let rhi = hi - borrow as Field - MODULUSmq.1;
    // now we validate that rlo and rhi are positive
    rlo.assert_max_bit_size::<128>();
    rhi.assert_max_bit_size::<128>();
    // validate that rlo, rhi is smaller than MODULUS
    // if the lo is larger than the modulus lo we have to get a borrow
    let borrow = unsafe { __gt(rlo, MODULUS.0) };
    let rplo = MODULUS.0 - rlo + borrow as Field * TWO_POW_128;
    let rphi = MODULUS.1 - rhi - borrow as Field;
    // check that rplo and rphi are positive
    rplo.assert_max_bit_size::<128>();
    rphi.assert_max_bit_size::<128>();
    EmbeddedCurveScalar::new(rlo, rhi)
}

//Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value
fn scalar_from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {
    let mut v: Field = 1;
    let mut lo: Field = 0;
    let mut hi: Field = 0;
    for i in 0..16 {
        lo = lo + (bytes[offset + 31 - i] as Field) * v;
        hi = hi + (bytes[offset + 15 - i] as Field) * v;
        v = v * 256;
    }
    let sig_s = EmbeddedCurveScalar::new(lo, hi);
    sig_s
}

mod test {
    use super::normalize_signature;
    use super::verify_signature;
    use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar};

    #[test]
    fn test_zero_signature() {
        let public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {
            x: 1,
            y: 17631683881184975370165255887551781615748388533673675138860,
            is_infinite: false,
        };
        let signature: [u8; 64] = [0; 64];
        let message: [u8; _] = [2; 64]; // every message
        let verified = verify_signature(public_key, signature, message);
        assert(!verified);
    }

    #[test]
    fn smoke_test() {
        let message: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        let pub_key_x: Field = 0x04b260954662e97f00cab9adb773a259097f7a274b83b113532bce27fa3fb96a;
        let pub_key_y: Field = 0x2fd51571db6c08666b0edfbfbc57d432068bccd0110a39b166ab243da0037197;
        let signature: [u8; 64] = [
            1, 13, 119, 112, 212, 39, 233, 41, 84, 235, 255, 93, 245, 172, 186, 83, 157, 253, 76,
            77, 33, 128, 178, 15, 214, 67, 105, 107, 177, 234, 77, 48, 27, 237, 155, 84, 39, 84,
            247, 27, 22, 8, 176, 230, 24, 115, 145, 220, 254, 122, 135, 179, 171, 4, 214, 202, 64,
            199, 19, 84, 239, 138, 124, 12,
        ];

        let pub_key = EmbeddedCurvePoint { x: pub_key_x, y: pub_key_y, is_infinite: false };
        let valid_signature = verify_signature(pub_key, signature, message);
        assert(valid_signature);
        super::assert_valid_signature(pub_key, signature, message);
    }

    #[test]
    fn test_normalize_signature() {
        let sig_e = EmbeddedCurveScalar::new(
            201385395114098847380338600778112493540,
            64323764613183177041862057485226039389,
        );
        let normalized = normalize_signature(sig_e);
        let expected = EmbeddedCurveScalar::new(23325341, 0);
        assert(normalized == expected);
    }

    #[test]
    fn test_normalize_signature_2() {
        let sig_e = EmbeddedCurveScalar::new(
            263873818421358078677641194902522618482,
            192971293839549531125586172455678118168,
        );
        let normalized = normalize_signature(sig_e);
        let expected = EmbeddedCurveScalar::new(23325341, 0);
        assert(normalized == expected);
    }

}

mod bench {
    use super::{assert_valid_signature, verify_signature};
    use std::embedded_curve_ops::EmbeddedCurvePoint;

    #[export]
    pub fn bench_verify_signature(
        public_key: EmbeddedCurvePoint,
        signature: [u8; 64],
        message: [u8; 32],
    ) -> bool {
        verify_signature(public_key, signature, message)
    }

    #[export]
    pub fn bench_assert_valid_signature(
        public_key: EmbeddedCurvePoint,
        signature: [u8; 64],
        message: [u8; 32],
    ) {
        assert_valid_signature(public_key, signature, message)
    }
}

`}},Dl={transpiled:El,noir_version:Ll,name:Sl,functions:Hl,outputs:Xl,file_map:Cl},Mp=Object.freeze(Object.defineProperty({__proto__:null,default:Dl,file_map:Cl,functions:Hl,name:Sl,noir_version:Ll,outputs:Xl,transpiled:El},Symbol.toStringTag,{value:"Module"})),Rp=Be(Dl);class Vp extends xo{constructor(e){super(e)}getContractArtifact(){return Promise.resolve(Rp)}}async function Yp(n,e,t){const s=t??md(n),a=new Vp(s);return await Ad(a,n,e)}const jl=[f.fromHexString("2153536ff6628eee01cf4024889ff977a18d9fa61d0e414422f7681cf085c281"),f.fromHexString("aebd1b4be76efa44f5ee655c20bf9ea60f7ae44b9a7fd1fd9f189c7a0b0cdae"),f.fromHexString("0f6addf0da06c33293df974a565b03d1ab096090d907d98055a8b7f4954e120c")],Il=jl.map(n=>gd(n)),Gp=Il,ji=[f.ZERO,f.ZERO,f.ZERO];function Zp(){return Promise.all(jl.map(async(n,e)=>({secret:n,signingKey:Il[e],salt:ji[e],address:await Yp(n,ji[e],Gp[e])})))}const Kp=!0,Ii=V("wallet"),Bi="aztec-account";var vn,bs;class nh{constructor(e){w(this,vn);this.nodeUrl=e,this.connectedAccount=null}async initialize(){const e=await bd(this.nodeUrl),t=_u();t.l1Contracts=await e.getL1ContractAddresses(),t.proverEnabled=Kp,this.pxe=await Wp(e,t),await this.pxe.registerContract({instance:await v(this,vn,bs).call(this),artifact:ti});const s=await this.pxe.getNodeInfo();Ii.info("PXE Connected to node",s)}getConnectedAccount(){return this.connectedAccount?this.connectedAccount:null}async connectTestAccount(e){const s=(await Zp())[e],a=await cu(this.pxe,s.secret,s.signingKey,s.salt);await a.register();const r=await a.getWallet();return this.connectedAccount=r,r}async createAccountAndConnect(){if(!this.pxe)throw new Error("PXE not initialized");const e=f.random(),t=f.random(),s=ys(32),a=await ni(this.pxe,t,s,e),r=await a.getDeployMethod(),i=await v(this,vn,bs).call(this),o={contractAddressSalt:f.fromString(a.salt.toString()),fee:{paymentMethod:await a.getSelfPaymentMethod(new Gr(i.address))},universalDeploy:!0,skipClassRegistration:!0,skipPublicDeployment:!0},d=await(await r.prove(o)).send().wait({timeout:120});Ii.info("Account deployed",d);const _=await a.getWallet();return localStorage.setItem(Bi,JSON.stringify({address:_.getAddress().toString(),signingKey:s.toString("hex"),secretKey:t.toString(),salt:e.toString()})),await a.register(),this.connectedAccount=_,_}async connectExistingAccount(){const e=localStorage.getItem(Bi);if(!e)return null;const t=JSON.parse(e),s=await ni(this.pxe,f.fromString(t.secretKey),Buffer.from(t.signingKey,"hex"),f.fromString(t.salt));await s.register();const a=await s.getWallet();return this.connectedAccount=a,a}async registerContract(e,t,s,a){const r=await xa(e,{constructorArtifact:vd(e),constructorArgs:a,deployer:t,salt:s});await this.pxe.registerContract({instance:r,artifact:e})}async sendTransaction(e){const t=await v(this,vn,bs).call(this);await(await e.prove({fee:{paymentMethod:new Gr(t.address)}})).send().wait({timeout:120})}async simulateTransaction(e){return await e.simulate()}}vn=new WeakSet,bs=async function(){return await xa(ti,{salt:new f(yd)})};export{nh as EmbeddedWallet};
